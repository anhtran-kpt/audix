
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model UserSubscription
 * 
 */
export type UserSubscription = $Result.DefaultSelection<Prisma.$UserSubscriptionPayload>
/**
 * Model Artist
 * 
 */
export type Artist = $Result.DefaultSelection<Prisma.$ArtistPayload>
/**
 * Model Album
 * 
 */
export type Album = $Result.DefaultSelection<Prisma.$AlbumPayload>
/**
 * Model Song
 * 
 */
export type Song = $Result.DefaultSelection<Prisma.$SongPayload>
/**
 * Model Genre
 * 
 */
export type Genre = $Result.DefaultSelection<Prisma.$GenrePayload>
/**
 * Model SongArtist
 * 
 */
export type SongArtist = $Result.DefaultSelection<Prisma.$SongArtistPayload>
/**
 * Model SongCredit
 * 
 */
export type SongCredit = $Result.DefaultSelection<Prisma.$SongCreditPayload>
/**
 * Model SongGenre
 * 
 */
export type SongGenre = $Result.DefaultSelection<Prisma.$SongGenrePayload>
/**
 * Model AlbumGenre
 * 
 */
export type AlbumGenre = $Result.DefaultSelection<Prisma.$AlbumGenrePayload>
/**
 * Model ArtistGenre
 * 
 */
export type ArtistGenre = $Result.DefaultSelection<Prisma.$ArtistGenrePayload>
/**
 * Model Playlist
 * 
 */
export type Playlist = $Result.DefaultSelection<Prisma.$PlaylistPayload>
/**
 * Model PlaylistItem
 * 
 */
export type PlaylistItem = $Result.DefaultSelection<Prisma.$PlaylistItemPayload>
/**
 * Model UserLikedSong
 * 
 */
export type UserLikedSong = $Result.DefaultSelection<Prisma.$UserLikedSongPayload>
/**
 * Model UserLikedAlbum
 * 
 */
export type UserLikedAlbum = $Result.DefaultSelection<Prisma.$UserLikedAlbumPayload>
/**
 * Model UserLikedArtist
 * 
 */
export type UserLikedArtist = $Result.DefaultSelection<Prisma.$UserLikedArtistPayload>
/**
 * Model UserLikedPlaylist
 * 
 */
export type UserLikedPlaylist = $Result.DefaultSelection<Prisma.$UserLikedPlaylistPayload>
/**
 * Model UserFollow
 * 
 */
export type UserFollow = $Result.DefaultSelection<Prisma.$UserFollowPayload>
/**
 * Model PlayHistory
 * 
 */
export type PlayHistory = $Result.DefaultSelection<Prisma.$PlayHistoryPayload>
/**
 * Model SearchHistory
 * 
 */
export type SearchHistory = $Result.DefaultSelection<Prisma.$SearchHistoryPayload>
/**
 * Model UserRecommendation
 * 
 */
export type UserRecommendation = $Result.DefaultSelection<Prisma.$UserRecommendationPayload>
/**
 * Model UserQueue
 * 
 */
export type UserQueue = $Result.DefaultSelection<Prisma.$UserQueuePayload>
/**
 * Model Chart
 * 
 */
export type Chart = $Result.DefaultSelection<Prisma.$ChartPayload>
/**
 * Model ChartItem
 * 
 */
export type ChartItem = $Result.DefaultSelection<Prisma.$ChartItemPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER',
  PREFER_NOT_TO_SAY: 'PREFER_NOT_TO_SAY'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const SubscriptionType: {
  FREE: 'FREE',
  PREMIUM: 'PREMIUM'
};

export type SubscriptionType = (typeof SubscriptionType)[keyof typeof SubscriptionType]


export const SubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  CANCELLED: 'CANCELLED',
  EXPIRED: 'EXPIRED',
  SUSPENDED: 'SUSPENDED'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const AlbumType: {
  SINGLE: 'SINGLE',
  EP: 'EP',
  ALBUM: 'ALBUM',
  COMPILATION: 'COMPILATION'
};

export type AlbumType = (typeof AlbumType)[keyof typeof AlbumType]


export const ArtistRole: {
  MAIN_ARTIST: 'MAIN_ARTIST',
  FEATURED_ARTIST: 'FEATURED_ARTIST',
  REMIX_ARTIST: 'REMIX_ARTIST'
};

export type ArtistRole = (typeof ArtistRole)[keyof typeof ArtistRole]


export const CreditRole: {
  LEAD_VOCALS: 'LEAD_VOCALS',
  BACKING_VOCALS: 'BACKING_VOCALS',
  RAP: 'RAP',
  FEATURED_ARTIST: 'FEATURED_ARTIST',
  SONGWRITER: 'SONGWRITER',
  COMPOSER: 'COMPOSER',
  LYRICIST: 'LYRICIST',
  PRODUCER: 'PRODUCER',
  EXECUTIVE_PRODUCER: 'EXECUTIVE_PRODUCER',
  CO_PRODUCER: 'CO_PRODUCER',
  VOCAL_PRODUCER: 'VOCAL_PRODUCER',
  MIXING_ENGINEER: 'MIXING_ENGINEER',
  MASTERING_ENGINEER: 'MASTERING_ENGINEER',
  RECORDING_ENGINEER: 'RECORDING_ENGINEER',
  ASSISTANT_ENGINEER: 'ASSISTANT_ENGINEER',
  GUITAR: 'GUITAR',
  BASS: 'BASS',
  DRUMS: 'DRUMS',
  PIANO: 'PIANO',
  KEYBOARD: 'KEYBOARD',
  VIOLIN: 'VIOLIN',
  SAXOPHONE: 'SAXOPHONE',
  TRUMPET: 'TRUMPET',
  OTHER_INSTRUMENT: 'OTHER_INSTRUMENT',
  ARRANGER: 'ARRANGER',
  CONDUCTOR: 'CONDUCTOR',
  PROGRAMMER: 'PROGRAMMER',
  ADDITIONAL_PRODUCTION: 'ADDITIONAL_PRODUCTION',
  REMIXER: 'REMIXER',
  PUBLISHER: 'PUBLISHER',
  RECORD_LABEL: 'RECORD_LABEL',
  MANAGEMENT: 'MANAGEMENT'
};

export type CreditRole = (typeof CreditRole)[keyof typeof CreditRole]


export const ChartType: {
  TOP_SONGS: 'TOP_SONGS',
  TOP_ALBUMS: 'TOP_ALBUMS',
  TOP_ARTISTS: 'TOP_ARTISTS',
  TRENDING: 'TRENDING'
};

export type ChartType = (typeof ChartType)[keyof typeof ChartType]

}

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type SubscriptionType = $Enums.SubscriptionType

export const SubscriptionType: typeof $Enums.SubscriptionType

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type AlbumType = $Enums.AlbumType

export const AlbumType: typeof $Enums.AlbumType

export type ArtistRole = $Enums.ArtistRole

export const ArtistRole: typeof $Enums.ArtistRole

export type CreditRole = $Enums.CreditRole

export const CreditRole: typeof $Enums.CreditRole

export type ChartType = $Enums.ChartType

export const ChartType: typeof $Enums.ChartType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSubscription`: Exposes CRUD operations for the **UserSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSubscriptions
    * const userSubscriptions = await prisma.userSubscription.findMany()
    * ```
    */
  get userSubscription(): Prisma.UserSubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.artist`: Exposes CRUD operations for the **Artist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Artists
    * const artists = await prisma.artist.findMany()
    * ```
    */
  get artist(): Prisma.ArtistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.album`: Exposes CRUD operations for the **Album** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Albums
    * const albums = await prisma.album.findMany()
    * ```
    */
  get album(): Prisma.AlbumDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.song`: Exposes CRUD operations for the **Song** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Songs
    * const songs = await prisma.song.findMany()
    * ```
    */
  get song(): Prisma.SongDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.genre`: Exposes CRUD operations for the **Genre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Genres
    * const genres = await prisma.genre.findMany()
    * ```
    */
  get genre(): Prisma.GenreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.songArtist`: Exposes CRUD operations for the **SongArtist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SongArtists
    * const songArtists = await prisma.songArtist.findMany()
    * ```
    */
  get songArtist(): Prisma.SongArtistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.songCredit`: Exposes CRUD operations for the **SongCredit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SongCredits
    * const songCredits = await prisma.songCredit.findMany()
    * ```
    */
  get songCredit(): Prisma.SongCreditDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.songGenre`: Exposes CRUD operations for the **SongGenre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SongGenres
    * const songGenres = await prisma.songGenre.findMany()
    * ```
    */
  get songGenre(): Prisma.SongGenreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.albumGenre`: Exposes CRUD operations for the **AlbumGenre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AlbumGenres
    * const albumGenres = await prisma.albumGenre.findMany()
    * ```
    */
  get albumGenre(): Prisma.AlbumGenreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.artistGenre`: Exposes CRUD operations for the **ArtistGenre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArtistGenres
    * const artistGenres = await prisma.artistGenre.findMany()
    * ```
    */
  get artistGenre(): Prisma.ArtistGenreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playlist`: Exposes CRUD operations for the **Playlist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Playlists
    * const playlists = await prisma.playlist.findMany()
    * ```
    */
  get playlist(): Prisma.PlaylistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playlistItem`: Exposes CRUD operations for the **PlaylistItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlaylistItems
    * const playlistItems = await prisma.playlistItem.findMany()
    * ```
    */
  get playlistItem(): Prisma.PlaylistItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userLikedSong`: Exposes CRUD operations for the **UserLikedSong** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLikedSongs
    * const userLikedSongs = await prisma.userLikedSong.findMany()
    * ```
    */
  get userLikedSong(): Prisma.UserLikedSongDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userLikedAlbum`: Exposes CRUD operations for the **UserLikedAlbum** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLikedAlbums
    * const userLikedAlbums = await prisma.userLikedAlbum.findMany()
    * ```
    */
  get userLikedAlbum(): Prisma.UserLikedAlbumDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userLikedArtist`: Exposes CRUD operations for the **UserLikedArtist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLikedArtists
    * const userLikedArtists = await prisma.userLikedArtist.findMany()
    * ```
    */
  get userLikedArtist(): Prisma.UserLikedArtistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userLikedPlaylist`: Exposes CRUD operations for the **UserLikedPlaylist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLikedPlaylists
    * const userLikedPlaylists = await prisma.userLikedPlaylist.findMany()
    * ```
    */
  get userLikedPlaylist(): Prisma.UserLikedPlaylistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userFollow`: Exposes CRUD operations for the **UserFollow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFollows
    * const userFollows = await prisma.userFollow.findMany()
    * ```
    */
  get userFollow(): Prisma.UserFollowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playHistory`: Exposes CRUD operations for the **PlayHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayHistories
    * const playHistories = await prisma.playHistory.findMany()
    * ```
    */
  get playHistory(): Prisma.PlayHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.searchHistory`: Exposes CRUD operations for the **SearchHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SearchHistories
    * const searchHistories = await prisma.searchHistory.findMany()
    * ```
    */
  get searchHistory(): Prisma.SearchHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRecommendation`: Exposes CRUD operations for the **UserRecommendation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRecommendations
    * const userRecommendations = await prisma.userRecommendation.findMany()
    * ```
    */
  get userRecommendation(): Prisma.UserRecommendationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userQueue`: Exposes CRUD operations for the **UserQueue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserQueues
    * const userQueues = await prisma.userQueue.findMany()
    * ```
    */
  get userQueue(): Prisma.UserQueueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chart`: Exposes CRUD operations for the **Chart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Charts
    * const charts = await prisma.chart.findMany()
    * ```
    */
  get chart(): Prisma.ChartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chartItem`: Exposes CRUD operations for the **ChartItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChartItems
    * const chartItems = await prisma.chartItem.findMany()
    * ```
    */
  get chartItem(): Prisma.ChartItemDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.13.0
   * Query Engine version: 361e86d0ea4987e9f53a565309b3eed797a6bcbd
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    UserSubscription: 'UserSubscription',
    Artist: 'Artist',
    Album: 'Album',
    Song: 'Song',
    Genre: 'Genre',
    SongArtist: 'SongArtist',
    SongCredit: 'SongCredit',
    SongGenre: 'SongGenre',
    AlbumGenre: 'AlbumGenre',
    ArtistGenre: 'ArtistGenre',
    Playlist: 'Playlist',
    PlaylistItem: 'PlaylistItem',
    UserLikedSong: 'UserLikedSong',
    UserLikedAlbum: 'UserLikedAlbum',
    UserLikedArtist: 'UserLikedArtist',
    UserLikedPlaylist: 'UserLikedPlaylist',
    UserFollow: 'UserFollow',
    PlayHistory: 'PlayHistory',
    SearchHistory: 'SearchHistory',
    UserRecommendation: 'UserRecommendation',
    UserQueue: 'UserQueue',
    Chart: 'Chart',
    ChartItem: 'ChartItem'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "account" | "session" | "verificationToken" | "userSubscription" | "artist" | "album" | "song" | "genre" | "songArtist" | "songCredit" | "songGenre" | "albumGenre" | "artistGenre" | "playlist" | "playlistItem" | "userLikedSong" | "userLikedAlbum" | "userLikedArtist" | "userLikedPlaylist" | "userFollow" | "playHistory" | "searchHistory" | "userRecommendation" | "userQueue" | "chart" | "chartItem"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      UserSubscription: {
        payload: Prisma.$UserSubscriptionPayload<ExtArgs>
        fields: Prisma.UserSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.UserSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          findMany: {
            args: Prisma.UserSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>[]
          }
          create: {
            args: Prisma.UserSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          createMany: {
            args: Prisma.UserSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.UserSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          update: {
            args: Prisma.UserSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.UserSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.UserSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.UserSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSubscription>
          }
          groupBy: {
            args: Prisma.UserSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Artist: {
        payload: Prisma.$ArtistPayload<ExtArgs>
        fields: Prisma.ArtistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArtistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArtistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload>
          }
          findFirst: {
            args: Prisma.ArtistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArtistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload>
          }
          findMany: {
            args: Prisma.ArtistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload>[]
          }
          create: {
            args: Prisma.ArtistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload>
          }
          createMany: {
            args: Prisma.ArtistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArtistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload>[]
          }
          delete: {
            args: Prisma.ArtistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload>
          }
          update: {
            args: Prisma.ArtistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload>
          }
          deleteMany: {
            args: Prisma.ArtistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArtistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArtistUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload>[]
          }
          upsert: {
            args: Prisma.ArtistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload>
          }
          aggregate: {
            args: Prisma.ArtistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArtist>
          }
          groupBy: {
            args: Prisma.ArtistGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArtistGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArtistCountArgs<ExtArgs>
            result: $Utils.Optional<ArtistCountAggregateOutputType> | number
          }
        }
      }
      Album: {
        payload: Prisma.$AlbumPayload<ExtArgs>
        fields: Prisma.AlbumFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlbumFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlbumFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>
          }
          findFirst: {
            args: Prisma.AlbumFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlbumFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>
          }
          findMany: {
            args: Prisma.AlbumFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>[]
          }
          create: {
            args: Prisma.AlbumCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>
          }
          createMany: {
            args: Prisma.AlbumCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlbumCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>[]
          }
          delete: {
            args: Prisma.AlbumDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>
          }
          update: {
            args: Prisma.AlbumUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>
          }
          deleteMany: {
            args: Prisma.AlbumDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlbumUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlbumUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>[]
          }
          upsert: {
            args: Prisma.AlbumUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>
          }
          aggregate: {
            args: Prisma.AlbumAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlbum>
          }
          groupBy: {
            args: Prisma.AlbumGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlbumGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlbumCountArgs<ExtArgs>
            result: $Utils.Optional<AlbumCountAggregateOutputType> | number
          }
        }
      }
      Song: {
        payload: Prisma.$SongPayload<ExtArgs>
        fields: Prisma.SongFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SongFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SongFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongPayload>
          }
          findFirst: {
            args: Prisma.SongFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SongFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongPayload>
          }
          findMany: {
            args: Prisma.SongFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongPayload>[]
          }
          create: {
            args: Prisma.SongCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongPayload>
          }
          createMany: {
            args: Prisma.SongCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SongCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongPayload>[]
          }
          delete: {
            args: Prisma.SongDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongPayload>
          }
          update: {
            args: Prisma.SongUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongPayload>
          }
          deleteMany: {
            args: Prisma.SongDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SongUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SongUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongPayload>[]
          }
          upsert: {
            args: Prisma.SongUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongPayload>
          }
          aggregate: {
            args: Prisma.SongAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSong>
          }
          groupBy: {
            args: Prisma.SongGroupByArgs<ExtArgs>
            result: $Utils.Optional<SongGroupByOutputType>[]
          }
          count: {
            args: Prisma.SongCountArgs<ExtArgs>
            result: $Utils.Optional<SongCountAggregateOutputType> | number
          }
        }
      }
      Genre: {
        payload: Prisma.$GenrePayload<ExtArgs>
        fields: Prisma.GenreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GenreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GenreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          findFirst: {
            args: Prisma.GenreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GenreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          findMany: {
            args: Prisma.GenreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[]
          }
          create: {
            args: Prisma.GenreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          createMany: {
            args: Prisma.GenreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GenreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[]
          }
          delete: {
            args: Prisma.GenreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          update: {
            args: Prisma.GenreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          deleteMany: {
            args: Prisma.GenreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GenreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GenreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[]
          }
          upsert: {
            args: Prisma.GenreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          aggregate: {
            args: Prisma.GenreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGenre>
          }
          groupBy: {
            args: Prisma.GenreGroupByArgs<ExtArgs>
            result: $Utils.Optional<GenreGroupByOutputType>[]
          }
          count: {
            args: Prisma.GenreCountArgs<ExtArgs>
            result: $Utils.Optional<GenreCountAggregateOutputType> | number
          }
        }
      }
      SongArtist: {
        payload: Prisma.$SongArtistPayload<ExtArgs>
        fields: Prisma.SongArtistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SongArtistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongArtistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SongArtistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongArtistPayload>
          }
          findFirst: {
            args: Prisma.SongArtistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongArtistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SongArtistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongArtistPayload>
          }
          findMany: {
            args: Prisma.SongArtistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongArtistPayload>[]
          }
          create: {
            args: Prisma.SongArtistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongArtistPayload>
          }
          createMany: {
            args: Prisma.SongArtistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SongArtistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongArtistPayload>[]
          }
          delete: {
            args: Prisma.SongArtistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongArtistPayload>
          }
          update: {
            args: Prisma.SongArtistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongArtistPayload>
          }
          deleteMany: {
            args: Prisma.SongArtistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SongArtistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SongArtistUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongArtistPayload>[]
          }
          upsert: {
            args: Prisma.SongArtistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongArtistPayload>
          }
          aggregate: {
            args: Prisma.SongArtistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSongArtist>
          }
          groupBy: {
            args: Prisma.SongArtistGroupByArgs<ExtArgs>
            result: $Utils.Optional<SongArtistGroupByOutputType>[]
          }
          count: {
            args: Prisma.SongArtistCountArgs<ExtArgs>
            result: $Utils.Optional<SongArtistCountAggregateOutputType> | number
          }
        }
      }
      SongCredit: {
        payload: Prisma.$SongCreditPayload<ExtArgs>
        fields: Prisma.SongCreditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SongCreditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongCreditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SongCreditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongCreditPayload>
          }
          findFirst: {
            args: Prisma.SongCreditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongCreditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SongCreditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongCreditPayload>
          }
          findMany: {
            args: Prisma.SongCreditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongCreditPayload>[]
          }
          create: {
            args: Prisma.SongCreditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongCreditPayload>
          }
          createMany: {
            args: Prisma.SongCreditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SongCreditCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongCreditPayload>[]
          }
          delete: {
            args: Prisma.SongCreditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongCreditPayload>
          }
          update: {
            args: Prisma.SongCreditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongCreditPayload>
          }
          deleteMany: {
            args: Prisma.SongCreditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SongCreditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SongCreditUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongCreditPayload>[]
          }
          upsert: {
            args: Prisma.SongCreditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongCreditPayload>
          }
          aggregate: {
            args: Prisma.SongCreditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSongCredit>
          }
          groupBy: {
            args: Prisma.SongCreditGroupByArgs<ExtArgs>
            result: $Utils.Optional<SongCreditGroupByOutputType>[]
          }
          count: {
            args: Prisma.SongCreditCountArgs<ExtArgs>
            result: $Utils.Optional<SongCreditCountAggregateOutputType> | number
          }
        }
      }
      SongGenre: {
        payload: Prisma.$SongGenrePayload<ExtArgs>
        fields: Prisma.SongGenreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SongGenreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongGenrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SongGenreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongGenrePayload>
          }
          findFirst: {
            args: Prisma.SongGenreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongGenrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SongGenreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongGenrePayload>
          }
          findMany: {
            args: Prisma.SongGenreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongGenrePayload>[]
          }
          create: {
            args: Prisma.SongGenreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongGenrePayload>
          }
          createMany: {
            args: Prisma.SongGenreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SongGenreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongGenrePayload>[]
          }
          delete: {
            args: Prisma.SongGenreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongGenrePayload>
          }
          update: {
            args: Prisma.SongGenreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongGenrePayload>
          }
          deleteMany: {
            args: Prisma.SongGenreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SongGenreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SongGenreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongGenrePayload>[]
          }
          upsert: {
            args: Prisma.SongGenreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongGenrePayload>
          }
          aggregate: {
            args: Prisma.SongGenreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSongGenre>
          }
          groupBy: {
            args: Prisma.SongGenreGroupByArgs<ExtArgs>
            result: $Utils.Optional<SongGenreGroupByOutputType>[]
          }
          count: {
            args: Prisma.SongGenreCountArgs<ExtArgs>
            result: $Utils.Optional<SongGenreCountAggregateOutputType> | number
          }
        }
      }
      AlbumGenre: {
        payload: Prisma.$AlbumGenrePayload<ExtArgs>
        fields: Prisma.AlbumGenreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlbumGenreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumGenrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlbumGenreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumGenrePayload>
          }
          findFirst: {
            args: Prisma.AlbumGenreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumGenrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlbumGenreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumGenrePayload>
          }
          findMany: {
            args: Prisma.AlbumGenreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumGenrePayload>[]
          }
          create: {
            args: Prisma.AlbumGenreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumGenrePayload>
          }
          createMany: {
            args: Prisma.AlbumGenreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlbumGenreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumGenrePayload>[]
          }
          delete: {
            args: Prisma.AlbumGenreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumGenrePayload>
          }
          update: {
            args: Prisma.AlbumGenreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumGenrePayload>
          }
          deleteMany: {
            args: Prisma.AlbumGenreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlbumGenreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlbumGenreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumGenrePayload>[]
          }
          upsert: {
            args: Prisma.AlbumGenreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumGenrePayload>
          }
          aggregate: {
            args: Prisma.AlbumGenreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlbumGenre>
          }
          groupBy: {
            args: Prisma.AlbumGenreGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlbumGenreGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlbumGenreCountArgs<ExtArgs>
            result: $Utils.Optional<AlbumGenreCountAggregateOutputType> | number
          }
        }
      }
      ArtistGenre: {
        payload: Prisma.$ArtistGenrePayload<ExtArgs>
        fields: Prisma.ArtistGenreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArtistGenreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistGenrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArtistGenreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistGenrePayload>
          }
          findFirst: {
            args: Prisma.ArtistGenreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistGenrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArtistGenreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistGenrePayload>
          }
          findMany: {
            args: Prisma.ArtistGenreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistGenrePayload>[]
          }
          create: {
            args: Prisma.ArtistGenreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistGenrePayload>
          }
          createMany: {
            args: Prisma.ArtistGenreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArtistGenreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistGenrePayload>[]
          }
          delete: {
            args: Prisma.ArtistGenreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistGenrePayload>
          }
          update: {
            args: Prisma.ArtistGenreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistGenrePayload>
          }
          deleteMany: {
            args: Prisma.ArtistGenreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArtistGenreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArtistGenreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistGenrePayload>[]
          }
          upsert: {
            args: Prisma.ArtistGenreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistGenrePayload>
          }
          aggregate: {
            args: Prisma.ArtistGenreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArtistGenre>
          }
          groupBy: {
            args: Prisma.ArtistGenreGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArtistGenreGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArtistGenreCountArgs<ExtArgs>
            result: $Utils.Optional<ArtistGenreCountAggregateOutputType> | number
          }
        }
      }
      Playlist: {
        payload: Prisma.$PlaylistPayload<ExtArgs>
        fields: Prisma.PlaylistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaylistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaylistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          findFirst: {
            args: Prisma.PlaylistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaylistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          findMany: {
            args: Prisma.PlaylistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>[]
          }
          create: {
            args: Prisma.PlaylistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          createMany: {
            args: Prisma.PlaylistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlaylistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>[]
          }
          delete: {
            args: Prisma.PlaylistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          update: {
            args: Prisma.PlaylistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          deleteMany: {
            args: Prisma.PlaylistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaylistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlaylistUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>[]
          }
          upsert: {
            args: Prisma.PlaylistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          aggregate: {
            args: Prisma.PlaylistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaylist>
          }
          groupBy: {
            args: Prisma.PlaylistGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaylistGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaylistCountArgs<ExtArgs>
            result: $Utils.Optional<PlaylistCountAggregateOutputType> | number
          }
        }
      }
      PlaylistItem: {
        payload: Prisma.$PlaylistItemPayload<ExtArgs>
        fields: Prisma.PlaylistItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaylistItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaylistItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistItemPayload>
          }
          findFirst: {
            args: Prisma.PlaylistItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaylistItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistItemPayload>
          }
          findMany: {
            args: Prisma.PlaylistItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistItemPayload>[]
          }
          create: {
            args: Prisma.PlaylistItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistItemPayload>
          }
          createMany: {
            args: Prisma.PlaylistItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlaylistItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistItemPayload>[]
          }
          delete: {
            args: Prisma.PlaylistItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistItemPayload>
          }
          update: {
            args: Prisma.PlaylistItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistItemPayload>
          }
          deleteMany: {
            args: Prisma.PlaylistItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaylistItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlaylistItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistItemPayload>[]
          }
          upsert: {
            args: Prisma.PlaylistItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistItemPayload>
          }
          aggregate: {
            args: Prisma.PlaylistItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaylistItem>
          }
          groupBy: {
            args: Prisma.PlaylistItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaylistItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaylistItemCountArgs<ExtArgs>
            result: $Utils.Optional<PlaylistItemCountAggregateOutputType> | number
          }
        }
      }
      UserLikedSong: {
        payload: Prisma.$UserLikedSongPayload<ExtArgs>
        fields: Prisma.UserLikedSongFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserLikedSongFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedSongPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserLikedSongFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedSongPayload>
          }
          findFirst: {
            args: Prisma.UserLikedSongFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedSongPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserLikedSongFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedSongPayload>
          }
          findMany: {
            args: Prisma.UserLikedSongFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedSongPayload>[]
          }
          create: {
            args: Prisma.UserLikedSongCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedSongPayload>
          }
          createMany: {
            args: Prisma.UserLikedSongCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserLikedSongCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedSongPayload>[]
          }
          delete: {
            args: Prisma.UserLikedSongDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedSongPayload>
          }
          update: {
            args: Prisma.UserLikedSongUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedSongPayload>
          }
          deleteMany: {
            args: Prisma.UserLikedSongDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserLikedSongUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserLikedSongUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedSongPayload>[]
          }
          upsert: {
            args: Prisma.UserLikedSongUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedSongPayload>
          }
          aggregate: {
            args: Prisma.UserLikedSongAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserLikedSong>
          }
          groupBy: {
            args: Prisma.UserLikedSongGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserLikedSongGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserLikedSongCountArgs<ExtArgs>
            result: $Utils.Optional<UserLikedSongCountAggregateOutputType> | number
          }
        }
      }
      UserLikedAlbum: {
        payload: Prisma.$UserLikedAlbumPayload<ExtArgs>
        fields: Prisma.UserLikedAlbumFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserLikedAlbumFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedAlbumPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserLikedAlbumFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedAlbumPayload>
          }
          findFirst: {
            args: Prisma.UserLikedAlbumFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedAlbumPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserLikedAlbumFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedAlbumPayload>
          }
          findMany: {
            args: Prisma.UserLikedAlbumFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedAlbumPayload>[]
          }
          create: {
            args: Prisma.UserLikedAlbumCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedAlbumPayload>
          }
          createMany: {
            args: Prisma.UserLikedAlbumCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserLikedAlbumCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedAlbumPayload>[]
          }
          delete: {
            args: Prisma.UserLikedAlbumDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedAlbumPayload>
          }
          update: {
            args: Prisma.UserLikedAlbumUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedAlbumPayload>
          }
          deleteMany: {
            args: Prisma.UserLikedAlbumDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserLikedAlbumUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserLikedAlbumUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedAlbumPayload>[]
          }
          upsert: {
            args: Prisma.UserLikedAlbumUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedAlbumPayload>
          }
          aggregate: {
            args: Prisma.UserLikedAlbumAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserLikedAlbum>
          }
          groupBy: {
            args: Prisma.UserLikedAlbumGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserLikedAlbumGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserLikedAlbumCountArgs<ExtArgs>
            result: $Utils.Optional<UserLikedAlbumCountAggregateOutputType> | number
          }
        }
      }
      UserLikedArtist: {
        payload: Prisma.$UserLikedArtistPayload<ExtArgs>
        fields: Prisma.UserLikedArtistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserLikedArtistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedArtistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserLikedArtistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedArtistPayload>
          }
          findFirst: {
            args: Prisma.UserLikedArtistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedArtistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserLikedArtistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedArtistPayload>
          }
          findMany: {
            args: Prisma.UserLikedArtistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedArtistPayload>[]
          }
          create: {
            args: Prisma.UserLikedArtistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedArtistPayload>
          }
          createMany: {
            args: Prisma.UserLikedArtistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserLikedArtistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedArtistPayload>[]
          }
          delete: {
            args: Prisma.UserLikedArtistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedArtistPayload>
          }
          update: {
            args: Prisma.UserLikedArtistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedArtistPayload>
          }
          deleteMany: {
            args: Prisma.UserLikedArtistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserLikedArtistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserLikedArtistUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedArtistPayload>[]
          }
          upsert: {
            args: Prisma.UserLikedArtistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedArtistPayload>
          }
          aggregate: {
            args: Prisma.UserLikedArtistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserLikedArtist>
          }
          groupBy: {
            args: Prisma.UserLikedArtistGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserLikedArtistGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserLikedArtistCountArgs<ExtArgs>
            result: $Utils.Optional<UserLikedArtistCountAggregateOutputType> | number
          }
        }
      }
      UserLikedPlaylist: {
        payload: Prisma.$UserLikedPlaylistPayload<ExtArgs>
        fields: Prisma.UserLikedPlaylistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserLikedPlaylistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedPlaylistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserLikedPlaylistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedPlaylistPayload>
          }
          findFirst: {
            args: Prisma.UserLikedPlaylistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedPlaylistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserLikedPlaylistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedPlaylistPayload>
          }
          findMany: {
            args: Prisma.UserLikedPlaylistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedPlaylistPayload>[]
          }
          create: {
            args: Prisma.UserLikedPlaylistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedPlaylistPayload>
          }
          createMany: {
            args: Prisma.UserLikedPlaylistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserLikedPlaylistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedPlaylistPayload>[]
          }
          delete: {
            args: Prisma.UserLikedPlaylistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedPlaylistPayload>
          }
          update: {
            args: Prisma.UserLikedPlaylistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedPlaylistPayload>
          }
          deleteMany: {
            args: Prisma.UserLikedPlaylistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserLikedPlaylistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserLikedPlaylistUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedPlaylistPayload>[]
          }
          upsert: {
            args: Prisma.UserLikedPlaylistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLikedPlaylistPayload>
          }
          aggregate: {
            args: Prisma.UserLikedPlaylistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserLikedPlaylist>
          }
          groupBy: {
            args: Prisma.UserLikedPlaylistGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserLikedPlaylistGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserLikedPlaylistCountArgs<ExtArgs>
            result: $Utils.Optional<UserLikedPlaylistCountAggregateOutputType> | number
          }
        }
      }
      UserFollow: {
        payload: Prisma.$UserFollowPayload<ExtArgs>
        fields: Prisma.UserFollowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFollowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFollowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>
          }
          findFirst: {
            args: Prisma.UserFollowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFollowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>
          }
          findMany: {
            args: Prisma.UserFollowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>[]
          }
          create: {
            args: Prisma.UserFollowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>
          }
          createMany: {
            args: Prisma.UserFollowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserFollowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>[]
          }
          delete: {
            args: Prisma.UserFollowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>
          }
          update: {
            args: Prisma.UserFollowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>
          }
          deleteMany: {
            args: Prisma.UserFollowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFollowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserFollowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>[]
          }
          upsert: {
            args: Prisma.UserFollowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>
          }
          aggregate: {
            args: Prisma.UserFollowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFollow>
          }
          groupBy: {
            args: Prisma.UserFollowGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFollowGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFollowCountArgs<ExtArgs>
            result: $Utils.Optional<UserFollowCountAggregateOutputType> | number
          }
        }
      }
      PlayHistory: {
        payload: Prisma.$PlayHistoryPayload<ExtArgs>
        fields: Prisma.PlayHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayHistoryPayload>
          }
          findFirst: {
            args: Prisma.PlayHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayHistoryPayload>
          }
          findMany: {
            args: Prisma.PlayHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayHistoryPayload>[]
          }
          create: {
            args: Prisma.PlayHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayHistoryPayload>
          }
          createMany: {
            args: Prisma.PlayHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayHistoryPayload>[]
          }
          delete: {
            args: Prisma.PlayHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayHistoryPayload>
          }
          update: {
            args: Prisma.PlayHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayHistoryPayload>
          }
          deleteMany: {
            args: Prisma.PlayHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlayHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayHistoryPayload>[]
          }
          upsert: {
            args: Prisma.PlayHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayHistoryPayload>
          }
          aggregate: {
            args: Prisma.PlayHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayHistory>
          }
          groupBy: {
            args: Prisma.PlayHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<PlayHistoryCountAggregateOutputType> | number
          }
        }
      }
      SearchHistory: {
        payload: Prisma.$SearchHistoryPayload<ExtArgs>
        fields: Prisma.SearchHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SearchHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SearchHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          findFirst: {
            args: Prisma.SearchHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SearchHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          findMany: {
            args: Prisma.SearchHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>[]
          }
          create: {
            args: Prisma.SearchHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          createMany: {
            args: Prisma.SearchHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SearchHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>[]
          }
          delete: {
            args: Prisma.SearchHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          update: {
            args: Prisma.SearchHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          deleteMany: {
            args: Prisma.SearchHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SearchHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SearchHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>[]
          }
          upsert: {
            args: Prisma.SearchHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          aggregate: {
            args: Prisma.SearchHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSearchHistory>
          }
          groupBy: {
            args: Prisma.SearchHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SearchHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SearchHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<SearchHistoryCountAggregateOutputType> | number
          }
        }
      }
      UserRecommendation: {
        payload: Prisma.$UserRecommendationPayload<ExtArgs>
        fields: Prisma.UserRecommendationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRecommendationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecommendationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRecommendationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecommendationPayload>
          }
          findFirst: {
            args: Prisma.UserRecommendationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecommendationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRecommendationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecommendationPayload>
          }
          findMany: {
            args: Prisma.UserRecommendationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecommendationPayload>[]
          }
          create: {
            args: Prisma.UserRecommendationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecommendationPayload>
          }
          createMany: {
            args: Prisma.UserRecommendationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRecommendationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecommendationPayload>[]
          }
          delete: {
            args: Prisma.UserRecommendationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecommendationPayload>
          }
          update: {
            args: Prisma.UserRecommendationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecommendationPayload>
          }
          deleteMany: {
            args: Prisma.UserRecommendationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRecommendationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserRecommendationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecommendationPayload>[]
          }
          upsert: {
            args: Prisma.UserRecommendationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecommendationPayload>
          }
          aggregate: {
            args: Prisma.UserRecommendationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRecommendation>
          }
          groupBy: {
            args: Prisma.UserRecommendationGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRecommendationGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRecommendationCountArgs<ExtArgs>
            result: $Utils.Optional<UserRecommendationCountAggregateOutputType> | number
          }
        }
      }
      UserQueue: {
        payload: Prisma.$UserQueuePayload<ExtArgs>
        fields: Prisma.UserQueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserQueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserQueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQueuePayload>
          }
          findFirst: {
            args: Prisma.UserQueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserQueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQueuePayload>
          }
          findMany: {
            args: Prisma.UserQueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQueuePayload>[]
          }
          create: {
            args: Prisma.UserQueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQueuePayload>
          }
          createMany: {
            args: Prisma.UserQueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserQueueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQueuePayload>[]
          }
          delete: {
            args: Prisma.UserQueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQueuePayload>
          }
          update: {
            args: Prisma.UserQueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQueuePayload>
          }
          deleteMany: {
            args: Prisma.UserQueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserQueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserQueueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQueuePayload>[]
          }
          upsert: {
            args: Prisma.UserQueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQueuePayload>
          }
          aggregate: {
            args: Prisma.UserQueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserQueue>
          }
          groupBy: {
            args: Prisma.UserQueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserQueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserQueueCountArgs<ExtArgs>
            result: $Utils.Optional<UserQueueCountAggregateOutputType> | number
          }
        }
      }
      Chart: {
        payload: Prisma.$ChartPayload<ExtArgs>
        fields: Prisma.ChartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartPayload>
          }
          findFirst: {
            args: Prisma.ChartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartPayload>
          }
          findMany: {
            args: Prisma.ChartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartPayload>[]
          }
          create: {
            args: Prisma.ChartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartPayload>
          }
          createMany: {
            args: Prisma.ChartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChartCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartPayload>[]
          }
          delete: {
            args: Prisma.ChartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartPayload>
          }
          update: {
            args: Prisma.ChartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartPayload>
          }
          deleteMany: {
            args: Prisma.ChartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChartUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartPayload>[]
          }
          upsert: {
            args: Prisma.ChartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartPayload>
          }
          aggregate: {
            args: Prisma.ChartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChart>
          }
          groupBy: {
            args: Prisma.ChartGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChartGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChartCountArgs<ExtArgs>
            result: $Utils.Optional<ChartCountAggregateOutputType> | number
          }
        }
      }
      ChartItem: {
        payload: Prisma.$ChartItemPayload<ExtArgs>
        fields: Prisma.ChartItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChartItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChartItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartItemPayload>
          }
          findFirst: {
            args: Prisma.ChartItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChartItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartItemPayload>
          }
          findMany: {
            args: Prisma.ChartItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartItemPayload>[]
          }
          create: {
            args: Prisma.ChartItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartItemPayload>
          }
          createMany: {
            args: Prisma.ChartItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChartItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartItemPayload>[]
          }
          delete: {
            args: Prisma.ChartItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartItemPayload>
          }
          update: {
            args: Prisma.ChartItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartItemPayload>
          }
          deleteMany: {
            args: Prisma.ChartItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChartItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChartItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartItemPayload>[]
          }
          upsert: {
            args: Prisma.ChartItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartItemPayload>
          }
          aggregate: {
            args: Prisma.ChartItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChartItem>
          }
          groupBy: {
            args: Prisma.ChartItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChartItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChartItemCountArgs<ExtArgs>
            result: $Utils.Optional<ChartItemCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    userSubscription?: UserSubscriptionOmit
    artist?: ArtistOmit
    album?: AlbumOmit
    song?: SongOmit
    genre?: GenreOmit
    songArtist?: SongArtistOmit
    songCredit?: SongCreditOmit
    songGenre?: SongGenreOmit
    albumGenre?: AlbumGenreOmit
    artistGenre?: ArtistGenreOmit
    playlist?: PlaylistOmit
    playlistItem?: PlaylistItemOmit
    userLikedSong?: UserLikedSongOmit
    userLikedAlbum?: UserLikedAlbumOmit
    userLikedArtist?: UserLikedArtistOmit
    userLikedPlaylist?: UserLikedPlaylistOmit
    userFollow?: UserFollowOmit
    playHistory?: PlayHistoryOmit
    searchHistory?: SearchHistoryOmit
    userRecommendation?: UserRecommendationOmit
    userQueue?: UserQueueOmit
    chart?: ChartOmit
    chartItem?: ChartItemOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    playlists: number
    likedSongs: number
    likedAlbums: number
    likedPlaylists: number
    likedArtists: number
    playHistory: number
    searchHistory: number
    followers: number
    following: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    playlists?: boolean | UserCountOutputTypeCountPlaylistsArgs
    likedSongs?: boolean | UserCountOutputTypeCountLikedSongsArgs
    likedAlbums?: boolean | UserCountOutputTypeCountLikedAlbumsArgs
    likedPlaylists?: boolean | UserCountOutputTypeCountLikedPlaylistsArgs
    likedArtists?: boolean | UserCountOutputTypeCountLikedArtistsArgs
    playHistory?: boolean | UserCountOutputTypeCountPlayHistoryArgs
    searchHistory?: boolean | UserCountOutputTypeCountSearchHistoryArgs
    followers?: boolean | UserCountOutputTypeCountFollowersArgs
    following?: boolean | UserCountOutputTypeCountFollowingArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlaylistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLikedSongsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLikedSongWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLikedAlbumsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLikedAlbumWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLikedPlaylistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLikedPlaylistWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLikedArtistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLikedArtistWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlayHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSearchHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFollowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFollowWhereInput
  }


  /**
   * Count Type ArtistCountOutputType
   */

  export type ArtistCountOutputType = {
    albums: number
    songs: number
    genres: number
    likedBy: number
    credits: number
  }

  export type ArtistCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    albums?: boolean | ArtistCountOutputTypeCountAlbumsArgs
    songs?: boolean | ArtistCountOutputTypeCountSongsArgs
    genres?: boolean | ArtistCountOutputTypeCountGenresArgs
    likedBy?: boolean | ArtistCountOutputTypeCountLikedByArgs
    credits?: boolean | ArtistCountOutputTypeCountCreditsArgs
  }

  // Custom InputTypes
  /**
   * ArtistCountOutputType without action
   */
  export type ArtistCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistCountOutputType
     */
    select?: ArtistCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ArtistCountOutputType without action
   */
  export type ArtistCountOutputTypeCountAlbumsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlbumWhereInput
  }

  /**
   * ArtistCountOutputType without action
   */
  export type ArtistCountOutputTypeCountSongsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SongArtistWhereInput
  }

  /**
   * ArtistCountOutputType without action
   */
  export type ArtistCountOutputTypeCountGenresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtistGenreWhereInput
  }

  /**
   * ArtistCountOutputType without action
   */
  export type ArtistCountOutputTypeCountLikedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLikedArtistWhereInput
  }

  /**
   * ArtistCountOutputType without action
   */
  export type ArtistCountOutputTypeCountCreditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SongCreditWhereInput
  }


  /**
   * Count Type AlbumCountOutputType
   */

  export type AlbumCountOutputType = {
    songs: number
    genres: number
    likedBy: number
  }

  export type AlbumCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    songs?: boolean | AlbumCountOutputTypeCountSongsArgs
    genres?: boolean | AlbumCountOutputTypeCountGenresArgs
    likedBy?: boolean | AlbumCountOutputTypeCountLikedByArgs
  }

  // Custom InputTypes
  /**
   * AlbumCountOutputType without action
   */
  export type AlbumCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumCountOutputType
     */
    select?: AlbumCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AlbumCountOutputType without action
   */
  export type AlbumCountOutputTypeCountSongsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SongWhereInput
  }

  /**
   * AlbumCountOutputType without action
   */
  export type AlbumCountOutputTypeCountGenresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlbumGenreWhereInput
  }

  /**
   * AlbumCountOutputType without action
   */
  export type AlbumCountOutputTypeCountLikedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLikedAlbumWhereInput
  }


  /**
   * Count Type SongCountOutputType
   */

  export type SongCountOutputType = {
    artists: number
    credits: number
    genres: number
    likedBy: number
    playlistItems: number
    playHistory: number
  }

  export type SongCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artists?: boolean | SongCountOutputTypeCountArtistsArgs
    credits?: boolean | SongCountOutputTypeCountCreditsArgs
    genres?: boolean | SongCountOutputTypeCountGenresArgs
    likedBy?: boolean | SongCountOutputTypeCountLikedByArgs
    playlistItems?: boolean | SongCountOutputTypeCountPlaylistItemsArgs
    playHistory?: boolean | SongCountOutputTypeCountPlayHistoryArgs
  }

  // Custom InputTypes
  /**
   * SongCountOutputType without action
   */
  export type SongCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongCountOutputType
     */
    select?: SongCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SongCountOutputType without action
   */
  export type SongCountOutputTypeCountArtistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SongArtistWhereInput
  }

  /**
   * SongCountOutputType without action
   */
  export type SongCountOutputTypeCountCreditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SongCreditWhereInput
  }

  /**
   * SongCountOutputType without action
   */
  export type SongCountOutputTypeCountGenresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SongGenreWhereInput
  }

  /**
   * SongCountOutputType without action
   */
  export type SongCountOutputTypeCountLikedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLikedSongWhereInput
  }

  /**
   * SongCountOutputType without action
   */
  export type SongCountOutputTypeCountPlaylistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistItemWhereInput
  }

  /**
   * SongCountOutputType without action
   */
  export type SongCountOutputTypeCountPlayHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayHistoryWhereInput
  }


  /**
   * Count Type GenreCountOutputType
   */

  export type GenreCountOutputType = {
    songs: number
    albums: number
    artists: number
  }

  export type GenreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    songs?: boolean | GenreCountOutputTypeCountSongsArgs
    albums?: boolean | GenreCountOutputTypeCountAlbumsArgs
    artists?: boolean | GenreCountOutputTypeCountArtistsArgs
  }

  // Custom InputTypes
  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreCountOutputType
     */
    select?: GenreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeCountSongsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SongGenreWhereInput
  }

  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeCountAlbumsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlbumGenreWhereInput
  }

  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeCountArtistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtistGenreWhereInput
  }


  /**
   * Count Type PlaylistCountOutputType
   */

  export type PlaylistCountOutputType = {
    items: number
    likedBy: number
  }

  export type PlaylistCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PlaylistCountOutputTypeCountItemsArgs
    likedBy?: boolean | PlaylistCountOutputTypeCountLikedByArgs
  }

  // Custom InputTypes
  /**
   * PlaylistCountOutputType without action
   */
  export type PlaylistCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistCountOutputType
     */
    select?: PlaylistCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlaylistCountOutputType without action
   */
  export type PlaylistCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistItemWhereInput
  }

  /**
   * PlaylistCountOutputType without action
   */
  export type PlaylistCountOutputTypeCountLikedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLikedPlaylistWhereInput
  }


  /**
   * Count Type ChartCountOutputType
   */

  export type ChartCountOutputType = {
    items: number
  }

  export type ChartCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ChartCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * ChartCountOutputType without action
   */
  export type ChartCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartCountOutputType
     */
    select?: ChartCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChartCountOutputType without action
   */
  export type ChartCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChartItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    name: string | null
    password: string | null
    imageId: string | null
    emailVerified: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    bio: string | null
    country: string | null
    dateOfBirth: Date | null
    gender: $Enums.Gender | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    name: string | null
    password: string | null
    imageId: string | null
    emailVerified: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    bio: string | null
    country: string | null
    dateOfBirth: Date | null
    gender: $Enums.Gender | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    name: number
    password: number
    imageId: number
    emailVerified: number
    createdAt: number
    updatedAt: number
    bio: number
    country: number
    dateOfBirth: number
    gender: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    name?: true
    password?: true
    imageId?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    bio?: true
    country?: true
    dateOfBirth?: true
    gender?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    name?: true
    password?: true
    imageId?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    bio?: true
    country?: true
    dateOfBirth?: true
    gender?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    name?: true
    password?: true
    imageId?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    bio?: true
    country?: true
    dateOfBirth?: true
    gender?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    username: string | null
    name: string | null
    password: string | null
    imageId: string | null
    emailVerified: Date | null
    createdAt: Date
    updatedAt: Date
    bio: string | null
    country: string | null
    dateOfBirth: Date | null
    gender: $Enums.Gender | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    name?: boolean
    password?: boolean
    imageId?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bio?: boolean
    country?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    playlists?: boolean | User$playlistsArgs<ExtArgs>
    likedSongs?: boolean | User$likedSongsArgs<ExtArgs>
    likedAlbums?: boolean | User$likedAlbumsArgs<ExtArgs>
    likedPlaylists?: boolean | User$likedPlaylistsArgs<ExtArgs>
    likedArtists?: boolean | User$likedArtistsArgs<ExtArgs>
    playHistory?: boolean | User$playHistoryArgs<ExtArgs>
    searchHistory?: boolean | User$searchHistoryArgs<ExtArgs>
    followers?: boolean | User$followersArgs<ExtArgs>
    following?: boolean | User$followingArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    name?: boolean
    password?: boolean
    imageId?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bio?: boolean
    country?: boolean
    dateOfBirth?: boolean
    gender?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    name?: boolean
    password?: boolean
    imageId?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bio?: boolean
    country?: boolean
    dateOfBirth?: boolean
    gender?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    name?: boolean
    password?: boolean
    imageId?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bio?: boolean
    country?: boolean
    dateOfBirth?: boolean
    gender?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "username" | "name" | "password" | "imageId" | "emailVerified" | "createdAt" | "updatedAt" | "bio" | "country" | "dateOfBirth" | "gender", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    playlists?: boolean | User$playlistsArgs<ExtArgs>
    likedSongs?: boolean | User$likedSongsArgs<ExtArgs>
    likedAlbums?: boolean | User$likedAlbumsArgs<ExtArgs>
    likedPlaylists?: boolean | User$likedPlaylistsArgs<ExtArgs>
    likedArtists?: boolean | User$likedArtistsArgs<ExtArgs>
    playHistory?: boolean | User$playHistoryArgs<ExtArgs>
    searchHistory?: boolean | User$searchHistoryArgs<ExtArgs>
    followers?: boolean | User$followersArgs<ExtArgs>
    following?: boolean | User$followingArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      subscription: Prisma.$UserSubscriptionPayload<ExtArgs> | null
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      playlists: Prisma.$PlaylistPayload<ExtArgs>[]
      likedSongs: Prisma.$UserLikedSongPayload<ExtArgs>[]
      likedAlbums: Prisma.$UserLikedAlbumPayload<ExtArgs>[]
      likedPlaylists: Prisma.$UserLikedPlaylistPayload<ExtArgs>[]
      likedArtists: Prisma.$UserLikedArtistPayload<ExtArgs>[]
      playHistory: Prisma.$PlayHistoryPayload<ExtArgs>[]
      searchHistory: Prisma.$SearchHistoryPayload<ExtArgs>[]
      followers: Prisma.$UserFollowPayload<ExtArgs>[]
      following: Prisma.$UserFollowPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string | null
      name: string | null
      password: string | null
      imageId: string | null
      emailVerified: Date | null
      createdAt: Date
      updatedAt: Date
      bio: string | null
      country: string | null
      dateOfBirth: Date | null
      gender: $Enums.Gender | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends User$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    playlists<T extends User$playlistsArgs<ExtArgs> = {}>(args?: Subset<T, User$playlistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likedSongs<T extends User$likedSongsArgs<ExtArgs> = {}>(args?: Subset<T, User$likedSongsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLikedSongPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likedAlbums<T extends User$likedAlbumsArgs<ExtArgs> = {}>(args?: Subset<T, User$likedAlbumsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLikedAlbumPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likedPlaylists<T extends User$likedPlaylistsArgs<ExtArgs> = {}>(args?: Subset<T, User$likedPlaylistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLikedPlaylistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likedArtists<T extends User$likedArtistsArgs<ExtArgs> = {}>(args?: Subset<T, User$likedArtistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLikedArtistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    playHistory<T extends User$playHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$playHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    searchHistory<T extends User$searchHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$searchHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followers<T extends User$followersArgs<ExtArgs> = {}>(args?: Subset<T, User$followersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    following<T extends User$followingArgs<ExtArgs> = {}>(args?: Subset<T, User$followingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly imageId: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly bio: FieldRef<"User", 'String'>
    readonly country: FieldRef<"User", 'String'>
    readonly dateOfBirth: FieldRef<"User", 'DateTime'>
    readonly gender: FieldRef<"User", 'Gender'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.subscription
   */
  export type User$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    where?: UserSubscriptionWhereInput
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.playlists
   */
  export type User$playlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    where?: PlaylistWhereInput
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[]
    cursor?: PlaylistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaylistScalarFieldEnum | PlaylistScalarFieldEnum[]
  }

  /**
   * User.likedSongs
   */
  export type User$likedSongsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedSong
     */
    select?: UserLikedSongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedSong
     */
    omit?: UserLikedSongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedSongInclude<ExtArgs> | null
    where?: UserLikedSongWhereInput
    orderBy?: UserLikedSongOrderByWithRelationInput | UserLikedSongOrderByWithRelationInput[]
    cursor?: UserLikedSongWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLikedSongScalarFieldEnum | UserLikedSongScalarFieldEnum[]
  }

  /**
   * User.likedAlbums
   */
  export type User$likedAlbumsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedAlbum
     */
    select?: UserLikedAlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedAlbum
     */
    omit?: UserLikedAlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedAlbumInclude<ExtArgs> | null
    where?: UserLikedAlbumWhereInput
    orderBy?: UserLikedAlbumOrderByWithRelationInput | UserLikedAlbumOrderByWithRelationInput[]
    cursor?: UserLikedAlbumWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLikedAlbumScalarFieldEnum | UserLikedAlbumScalarFieldEnum[]
  }

  /**
   * User.likedPlaylists
   */
  export type User$likedPlaylistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedPlaylist
     */
    select?: UserLikedPlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedPlaylist
     */
    omit?: UserLikedPlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedPlaylistInclude<ExtArgs> | null
    where?: UserLikedPlaylistWhereInput
    orderBy?: UserLikedPlaylistOrderByWithRelationInput | UserLikedPlaylistOrderByWithRelationInput[]
    cursor?: UserLikedPlaylistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLikedPlaylistScalarFieldEnum | UserLikedPlaylistScalarFieldEnum[]
  }

  /**
   * User.likedArtists
   */
  export type User$likedArtistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedArtist
     */
    select?: UserLikedArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedArtist
     */
    omit?: UserLikedArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedArtistInclude<ExtArgs> | null
    where?: UserLikedArtistWhereInput
    orderBy?: UserLikedArtistOrderByWithRelationInput | UserLikedArtistOrderByWithRelationInput[]
    cursor?: UserLikedArtistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLikedArtistScalarFieldEnum | UserLikedArtistScalarFieldEnum[]
  }

  /**
   * User.playHistory
   */
  export type User$playHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayHistory
     */
    select?: PlayHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayHistory
     */
    omit?: PlayHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayHistoryInclude<ExtArgs> | null
    where?: PlayHistoryWhereInput
    orderBy?: PlayHistoryOrderByWithRelationInput | PlayHistoryOrderByWithRelationInput[]
    cursor?: PlayHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayHistoryScalarFieldEnum | PlayHistoryScalarFieldEnum[]
  }

  /**
   * User.searchHistory
   */
  export type User$searchHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    where?: SearchHistoryWhereInput
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    cursor?: SearchHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * User.followers
   */
  export type User$followersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    where?: UserFollowWhereInput
    orderBy?: UserFollowOrderByWithRelationInput | UserFollowOrderByWithRelationInput[]
    cursor?: UserFollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFollowScalarFieldEnum | UserFollowScalarFieldEnum[]
  }

  /**
   * User.following
   */
  export type User$followingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    where?: UserFollowWhereInput
    orderBy?: UserFollowOrderByWithRelationInput | UserFollowOrderByWithRelationInput[]
    cursor?: UserFollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFollowScalarFieldEnum | UserFollowScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model UserSubscription
   */

  export type AggregateUserSubscription = {
    _count: UserSubscriptionCountAggregateOutputType | null
    _min: UserSubscriptionMinAggregateOutputType | null
    _max: UserSubscriptionMaxAggregateOutputType | null
  }

  export type UserSubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.SubscriptionType | null
    status: $Enums.SubscriptionStatus | null
    startDate: Date | null
    endDate: Date | null
    autoRenew: boolean | null
    paymentMethod: string | null
  }

  export type UserSubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.SubscriptionType | null
    status: $Enums.SubscriptionStatus | null
    startDate: Date | null
    endDate: Date | null
    autoRenew: boolean | null
    paymentMethod: string | null
  }

  export type UserSubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    status: number
    startDate: number
    endDate: number
    autoRenew: number
    paymentMethod: number
    _all: number
  }


  export type UserSubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    status?: true
    startDate?: true
    endDate?: true
    autoRenew?: true
    paymentMethod?: true
  }

  export type UserSubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    status?: true
    startDate?: true
    endDate?: true
    autoRenew?: true
    paymentMethod?: true
  }

  export type UserSubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    status?: true
    startDate?: true
    endDate?: true
    autoRenew?: true
    paymentMethod?: true
    _all?: true
  }

  export type UserSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSubscription to aggregate.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSubscriptions
    **/
    _count?: true | UserSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSubscriptionMaxAggregateInputType
  }

  export type GetUserSubscriptionAggregateType<T extends UserSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSubscription[P]>
      : GetScalarType<T[P], AggregateUserSubscription[P]>
  }




  export type UserSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSubscriptionWhereInput
    orderBy?: UserSubscriptionOrderByWithAggregationInput | UserSubscriptionOrderByWithAggregationInput[]
    by: UserSubscriptionScalarFieldEnum[] | UserSubscriptionScalarFieldEnum
    having?: UserSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSubscriptionCountAggregateInputType | true
    _min?: UserSubscriptionMinAggregateInputType
    _max?: UserSubscriptionMaxAggregateInputType
  }

  export type UserSubscriptionGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.SubscriptionType
    status: $Enums.SubscriptionStatus
    startDate: Date
    endDate: Date | null
    autoRenew: boolean
    paymentMethod: string | null
    _count: UserSubscriptionCountAggregateOutputType | null
    _min: UserSubscriptionMinAggregateOutputType | null
    _max: UserSubscriptionMaxAggregateOutputType | null
  }

  type GetUserSubscriptionGroupByPayload<T extends UserSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type UserSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    autoRenew?: boolean
    paymentMethod?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSubscription"]>

  export type UserSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    autoRenew?: boolean
    paymentMethod?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSubscription"]>

  export type UserSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    autoRenew?: boolean
    paymentMethod?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSubscription"]>

  export type UserSubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    autoRenew?: boolean
    paymentMethod?: boolean
  }

  export type UserSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "status" | "startDate" | "endDate" | "autoRenew" | "paymentMethod", ExtArgs["result"]["userSubscription"]>
  export type UserSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSubscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.SubscriptionType
      status: $Enums.SubscriptionStatus
      startDate: Date
      endDate: Date | null
      autoRenew: boolean
      paymentMethod: string | null
    }, ExtArgs["result"]["userSubscription"]>
    composites: {}
  }

  type UserSubscriptionGetPayload<S extends boolean | null | undefined | UserSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$UserSubscriptionPayload, S>

  type UserSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSubscriptionCountAggregateInputType | true
    }

  export interface UserSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSubscription'], meta: { name: 'UserSubscription' } }
    /**
     * Find zero or one UserSubscription that matches the filter.
     * @param {UserSubscriptionFindUniqueArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSubscriptionFindUniqueArgs>(args: SelectSubset<T, UserSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionFindFirstArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSubscriptionFindFirstArgs>(args?: SelectSubset<T, UserSubscriptionFindFirstArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionFindFirstOrThrowArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSubscriptions
     * const userSubscriptions = await prisma.userSubscription.findMany()
     * 
     * // Get first 10 UserSubscriptions
     * const userSubscriptions = await prisma.userSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSubscriptionWithIdOnly = await prisma.userSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSubscriptionFindManyArgs>(args?: SelectSubset<T, UserSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSubscription.
     * @param {UserSubscriptionCreateArgs} args - Arguments to create a UserSubscription.
     * @example
     * // Create one UserSubscription
     * const UserSubscription = await prisma.userSubscription.create({
     *   data: {
     *     // ... data to create a UserSubscription
     *   }
     * })
     * 
     */
    create<T extends UserSubscriptionCreateArgs>(args: SelectSubset<T, UserSubscriptionCreateArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSubscriptions.
     * @param {UserSubscriptionCreateManyArgs} args - Arguments to create many UserSubscriptions.
     * @example
     * // Create many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSubscriptionCreateManyArgs>(args?: SelectSubset<T, UserSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSubscriptions and returns the data saved in the database.
     * @param {UserSubscriptionCreateManyAndReturnArgs} args - Arguments to create many UserSubscriptions.
     * @example
     * // Create many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSubscriptions and only return the `id`
     * const userSubscriptionWithIdOnly = await prisma.userSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSubscription.
     * @param {UserSubscriptionDeleteArgs} args - Arguments to delete one UserSubscription.
     * @example
     * // Delete one UserSubscription
     * const UserSubscription = await prisma.userSubscription.delete({
     *   where: {
     *     // ... filter to delete one UserSubscription
     *   }
     * })
     * 
     */
    delete<T extends UserSubscriptionDeleteArgs>(args: SelectSubset<T, UserSubscriptionDeleteArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSubscription.
     * @param {UserSubscriptionUpdateArgs} args - Arguments to update one UserSubscription.
     * @example
     * // Update one UserSubscription
     * const userSubscription = await prisma.userSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSubscriptionUpdateArgs>(args: SelectSubset<T, UserSubscriptionUpdateArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSubscriptions.
     * @param {UserSubscriptionDeleteManyArgs} args - Arguments to filter UserSubscriptions to delete.
     * @example
     * // Delete a few UserSubscriptions
     * const { count } = await prisma.userSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSubscriptionDeleteManyArgs>(args?: SelectSubset<T, UserSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSubscriptionUpdateManyArgs>(args: SelectSubset<T, UserSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSubscriptions and returns the data updated in the database.
     * @param {UserSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many UserSubscriptions.
     * @example
     * // Update many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSubscriptions and only return the `id`
     * const userSubscriptionWithIdOnly = await prisma.userSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSubscription.
     * @param {UserSubscriptionUpsertArgs} args - Arguments to update or create a UserSubscription.
     * @example
     * // Update or create a UserSubscription
     * const userSubscription = await prisma.userSubscription.upsert({
     *   create: {
     *     // ... data to create a UserSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSubscription we want to update
     *   }
     * })
     */
    upsert<T extends UserSubscriptionUpsertArgs>(args: SelectSubset<T, UserSubscriptionUpsertArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionCountArgs} args - Arguments to filter UserSubscriptions to count.
     * @example
     * // Count the number of UserSubscriptions
     * const count = await prisma.userSubscription.count({
     *   where: {
     *     // ... the filter for the UserSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends UserSubscriptionCountArgs>(
      args?: Subset<T, UserSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSubscriptionAggregateArgs>(args: Subset<T, UserSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetUserSubscriptionAggregateType<T>>

    /**
     * Group by UserSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: UserSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSubscription model
   */
  readonly fields: UserSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSubscription model
   */
  interface UserSubscriptionFieldRefs {
    readonly id: FieldRef<"UserSubscription", 'String'>
    readonly userId: FieldRef<"UserSubscription", 'String'>
    readonly type: FieldRef<"UserSubscription", 'SubscriptionType'>
    readonly status: FieldRef<"UserSubscription", 'SubscriptionStatus'>
    readonly startDate: FieldRef<"UserSubscription", 'DateTime'>
    readonly endDate: FieldRef<"UserSubscription", 'DateTime'>
    readonly autoRenew: FieldRef<"UserSubscription", 'Boolean'>
    readonly paymentMethod: FieldRef<"UserSubscription", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserSubscription findUnique
   */
  export type UserSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription findUniqueOrThrow
   */
  export type UserSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription findFirst
   */
  export type UserSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSubscriptions.
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSubscriptions.
     */
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * UserSubscription findFirstOrThrow
   */
  export type UserSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSubscriptions.
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSubscriptions.
     */
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * UserSubscription findMany
   */
  export type UserSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscriptions to fetch.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSubscriptions.
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * UserSubscription create
   */
  export type UserSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSubscription.
     */
    data: XOR<UserSubscriptionCreateInput, UserSubscriptionUncheckedCreateInput>
  }

  /**
   * UserSubscription createMany
   */
  export type UserSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSubscriptions.
     */
    data: UserSubscriptionCreateManyInput | UserSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSubscription createManyAndReturn
   */
  export type UserSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many UserSubscriptions.
     */
    data: UserSubscriptionCreateManyInput | UserSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSubscription update
   */
  export type UserSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSubscription.
     */
    data: XOR<UserSubscriptionUpdateInput, UserSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which UserSubscription to update.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription updateMany
   */
  export type UserSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSubscriptions.
     */
    data: XOR<UserSubscriptionUpdateManyMutationInput, UserSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which UserSubscriptions to update
     */
    where?: UserSubscriptionWhereInput
    /**
     * Limit how many UserSubscriptions to update.
     */
    limit?: number
  }

  /**
   * UserSubscription updateManyAndReturn
   */
  export type UserSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update UserSubscriptions.
     */
    data: XOR<UserSubscriptionUpdateManyMutationInput, UserSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which UserSubscriptions to update
     */
    where?: UserSubscriptionWhereInput
    /**
     * Limit how many UserSubscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSubscription upsert
   */
  export type UserSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSubscription to update in case it exists.
     */
    where: UserSubscriptionWhereUniqueInput
    /**
     * In case the UserSubscription found by the `where` argument doesn't exist, create a new UserSubscription with this data.
     */
    create: XOR<UserSubscriptionCreateInput, UserSubscriptionUncheckedCreateInput>
    /**
     * In case the UserSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSubscriptionUpdateInput, UserSubscriptionUncheckedUpdateInput>
  }

  /**
   * UserSubscription delete
   */
  export type UserSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which UserSubscription to delete.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription deleteMany
   */
  export type UserSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSubscriptions to delete
     */
    where?: UserSubscriptionWhereInput
    /**
     * Limit how many UserSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * UserSubscription without action
   */
  export type UserSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Artist
   */

  export type AggregateArtist = {
    _count: ArtistCountAggregateOutputType | null
    _avg: ArtistAvgAggregateOutputType | null
    _sum: ArtistSumAggregateOutputType | null
    _min: ArtistMinAggregateOutputType | null
    _max: ArtistMaxAggregateOutputType | null
  }

  export type ArtistAvgAggregateOutputType = {
    monthlyListeners: number | null
  }

  export type ArtistSumAggregateOutputType = {
    monthlyListeners: number | null
  }

  export type ArtistMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    bio: string | null
    imageId: string | null
    verified: boolean | null
    monthlyListeners: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArtistMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    bio: string | null
    imageId: string | null
    verified: boolean | null
    monthlyListeners: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArtistCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    bio: number
    imageId: number
    verified: number
    monthlyListeners: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ArtistAvgAggregateInputType = {
    monthlyListeners?: true
  }

  export type ArtistSumAggregateInputType = {
    monthlyListeners?: true
  }

  export type ArtistMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    bio?: true
    imageId?: true
    verified?: true
    monthlyListeners?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArtistMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    bio?: true
    imageId?: true
    verified?: true
    monthlyListeners?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArtistCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    bio?: true
    imageId?: true
    verified?: true
    monthlyListeners?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ArtistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Artist to aggregate.
     */
    where?: ArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artists to fetch.
     */
    orderBy?: ArtistOrderByWithRelationInput | ArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Artists
    **/
    _count?: true | ArtistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArtistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArtistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArtistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArtistMaxAggregateInputType
  }

  export type GetArtistAggregateType<T extends ArtistAggregateArgs> = {
        [P in keyof T & keyof AggregateArtist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArtist[P]>
      : GetScalarType<T[P], AggregateArtist[P]>
  }




  export type ArtistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtistWhereInput
    orderBy?: ArtistOrderByWithAggregationInput | ArtistOrderByWithAggregationInput[]
    by: ArtistScalarFieldEnum[] | ArtistScalarFieldEnum
    having?: ArtistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArtistCountAggregateInputType | true
    _avg?: ArtistAvgAggregateInputType
    _sum?: ArtistSumAggregateInputType
    _min?: ArtistMinAggregateInputType
    _max?: ArtistMaxAggregateInputType
  }

  export type ArtistGroupByOutputType = {
    id: string
    name: string
    slug: string
    bio: string | null
    imageId: string
    verified: boolean
    monthlyListeners: number
    createdAt: Date
    updatedAt: Date
    _count: ArtistCountAggregateOutputType | null
    _avg: ArtistAvgAggregateOutputType | null
    _sum: ArtistSumAggregateOutputType | null
    _min: ArtistMinAggregateOutputType | null
    _max: ArtistMaxAggregateOutputType | null
  }

  type GetArtistGroupByPayload<T extends ArtistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArtistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArtistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArtistGroupByOutputType[P]>
            : GetScalarType<T[P], ArtistGroupByOutputType[P]>
        }
      >
    >


  export type ArtistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    bio?: boolean
    imageId?: boolean
    verified?: boolean
    monthlyListeners?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    albums?: boolean | Artist$albumsArgs<ExtArgs>
    songs?: boolean | Artist$songsArgs<ExtArgs>
    genres?: boolean | Artist$genresArgs<ExtArgs>
    likedBy?: boolean | Artist$likedByArgs<ExtArgs>
    credits?: boolean | Artist$creditsArgs<ExtArgs>
    _count?: boolean | ArtistCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artist"]>

  export type ArtistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    bio?: boolean
    imageId?: boolean
    verified?: boolean
    monthlyListeners?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["artist"]>

  export type ArtistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    bio?: boolean
    imageId?: boolean
    verified?: boolean
    monthlyListeners?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["artist"]>

  export type ArtistSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    bio?: boolean
    imageId?: boolean
    verified?: boolean
    monthlyListeners?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ArtistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "bio" | "imageId" | "verified" | "monthlyListeners" | "createdAt" | "updatedAt", ExtArgs["result"]["artist"]>
  export type ArtistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    albums?: boolean | Artist$albumsArgs<ExtArgs>
    songs?: boolean | Artist$songsArgs<ExtArgs>
    genres?: boolean | Artist$genresArgs<ExtArgs>
    likedBy?: boolean | Artist$likedByArgs<ExtArgs>
    credits?: boolean | Artist$creditsArgs<ExtArgs>
    _count?: boolean | ArtistCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ArtistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ArtistIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ArtistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Artist"
    objects: {
      albums: Prisma.$AlbumPayload<ExtArgs>[]
      songs: Prisma.$SongArtistPayload<ExtArgs>[]
      genres: Prisma.$ArtistGenrePayload<ExtArgs>[]
      likedBy: Prisma.$UserLikedArtistPayload<ExtArgs>[]
      credits: Prisma.$SongCreditPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      bio: string | null
      imageId: string
      verified: boolean
      monthlyListeners: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["artist"]>
    composites: {}
  }

  type ArtistGetPayload<S extends boolean | null | undefined | ArtistDefaultArgs> = $Result.GetResult<Prisma.$ArtistPayload, S>

  type ArtistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArtistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArtistCountAggregateInputType | true
    }

  export interface ArtistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Artist'], meta: { name: 'Artist' } }
    /**
     * Find zero or one Artist that matches the filter.
     * @param {ArtistFindUniqueArgs} args - Arguments to find a Artist
     * @example
     * // Get one Artist
     * const artist = await prisma.artist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArtistFindUniqueArgs>(args: SelectSubset<T, ArtistFindUniqueArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Artist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArtistFindUniqueOrThrowArgs} args - Arguments to find a Artist
     * @example
     * // Get one Artist
     * const artist = await prisma.artist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArtistFindUniqueOrThrowArgs>(args: SelectSubset<T, ArtistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Artist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistFindFirstArgs} args - Arguments to find a Artist
     * @example
     * // Get one Artist
     * const artist = await prisma.artist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArtistFindFirstArgs>(args?: SelectSubset<T, ArtistFindFirstArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Artist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistFindFirstOrThrowArgs} args - Arguments to find a Artist
     * @example
     * // Get one Artist
     * const artist = await prisma.artist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArtistFindFirstOrThrowArgs>(args?: SelectSubset<T, ArtistFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Artists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Artists
     * const artists = await prisma.artist.findMany()
     * 
     * // Get first 10 Artists
     * const artists = await prisma.artist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const artistWithIdOnly = await prisma.artist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArtistFindManyArgs>(args?: SelectSubset<T, ArtistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Artist.
     * @param {ArtistCreateArgs} args - Arguments to create a Artist.
     * @example
     * // Create one Artist
     * const Artist = await prisma.artist.create({
     *   data: {
     *     // ... data to create a Artist
     *   }
     * })
     * 
     */
    create<T extends ArtistCreateArgs>(args: SelectSubset<T, ArtistCreateArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Artists.
     * @param {ArtistCreateManyArgs} args - Arguments to create many Artists.
     * @example
     * // Create many Artists
     * const artist = await prisma.artist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArtistCreateManyArgs>(args?: SelectSubset<T, ArtistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Artists and returns the data saved in the database.
     * @param {ArtistCreateManyAndReturnArgs} args - Arguments to create many Artists.
     * @example
     * // Create many Artists
     * const artist = await prisma.artist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Artists and only return the `id`
     * const artistWithIdOnly = await prisma.artist.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArtistCreateManyAndReturnArgs>(args?: SelectSubset<T, ArtistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Artist.
     * @param {ArtistDeleteArgs} args - Arguments to delete one Artist.
     * @example
     * // Delete one Artist
     * const Artist = await prisma.artist.delete({
     *   where: {
     *     // ... filter to delete one Artist
     *   }
     * })
     * 
     */
    delete<T extends ArtistDeleteArgs>(args: SelectSubset<T, ArtistDeleteArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Artist.
     * @param {ArtistUpdateArgs} args - Arguments to update one Artist.
     * @example
     * // Update one Artist
     * const artist = await prisma.artist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArtistUpdateArgs>(args: SelectSubset<T, ArtistUpdateArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Artists.
     * @param {ArtistDeleteManyArgs} args - Arguments to filter Artists to delete.
     * @example
     * // Delete a few Artists
     * const { count } = await prisma.artist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArtistDeleteManyArgs>(args?: SelectSubset<T, ArtistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Artists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Artists
     * const artist = await prisma.artist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArtistUpdateManyArgs>(args: SelectSubset<T, ArtistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Artists and returns the data updated in the database.
     * @param {ArtistUpdateManyAndReturnArgs} args - Arguments to update many Artists.
     * @example
     * // Update many Artists
     * const artist = await prisma.artist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Artists and only return the `id`
     * const artistWithIdOnly = await prisma.artist.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ArtistUpdateManyAndReturnArgs>(args: SelectSubset<T, ArtistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Artist.
     * @param {ArtistUpsertArgs} args - Arguments to update or create a Artist.
     * @example
     * // Update or create a Artist
     * const artist = await prisma.artist.upsert({
     *   create: {
     *     // ... data to create a Artist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Artist we want to update
     *   }
     * })
     */
    upsert<T extends ArtistUpsertArgs>(args: SelectSubset<T, ArtistUpsertArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Artists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistCountArgs} args - Arguments to filter Artists to count.
     * @example
     * // Count the number of Artists
     * const count = await prisma.artist.count({
     *   where: {
     *     // ... the filter for the Artists we want to count
     *   }
     * })
    **/
    count<T extends ArtistCountArgs>(
      args?: Subset<T, ArtistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArtistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Artist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArtistAggregateArgs>(args: Subset<T, ArtistAggregateArgs>): Prisma.PrismaPromise<GetArtistAggregateType<T>>

    /**
     * Group by Artist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArtistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArtistGroupByArgs['orderBy'] }
        : { orderBy?: ArtistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArtistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArtistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Artist model
   */
  readonly fields: ArtistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Artist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArtistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    albums<T extends Artist$albumsArgs<ExtArgs> = {}>(args?: Subset<T, Artist$albumsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    songs<T extends Artist$songsArgs<ExtArgs> = {}>(args?: Subset<T, Artist$songsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongArtistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    genres<T extends Artist$genresArgs<ExtArgs> = {}>(args?: Subset<T, Artist$genresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtistGenrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likedBy<T extends Artist$likedByArgs<ExtArgs> = {}>(args?: Subset<T, Artist$likedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLikedArtistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    credits<T extends Artist$creditsArgs<ExtArgs> = {}>(args?: Subset<T, Artist$creditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongCreditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Artist model
   */
  interface ArtistFieldRefs {
    readonly id: FieldRef<"Artist", 'String'>
    readonly name: FieldRef<"Artist", 'String'>
    readonly slug: FieldRef<"Artist", 'String'>
    readonly bio: FieldRef<"Artist", 'String'>
    readonly imageId: FieldRef<"Artist", 'String'>
    readonly verified: FieldRef<"Artist", 'Boolean'>
    readonly monthlyListeners: FieldRef<"Artist", 'Int'>
    readonly createdAt: FieldRef<"Artist", 'DateTime'>
    readonly updatedAt: FieldRef<"Artist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Artist findUnique
   */
  export type ArtistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    /**
     * Filter, which Artist to fetch.
     */
    where: ArtistWhereUniqueInput
  }

  /**
   * Artist findUniqueOrThrow
   */
  export type ArtistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    /**
     * Filter, which Artist to fetch.
     */
    where: ArtistWhereUniqueInput
  }

  /**
   * Artist findFirst
   */
  export type ArtistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    /**
     * Filter, which Artist to fetch.
     */
    where?: ArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artists to fetch.
     */
    orderBy?: ArtistOrderByWithRelationInput | ArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Artists.
     */
    cursor?: ArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Artists.
     */
    distinct?: ArtistScalarFieldEnum | ArtistScalarFieldEnum[]
  }

  /**
   * Artist findFirstOrThrow
   */
  export type ArtistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    /**
     * Filter, which Artist to fetch.
     */
    where?: ArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artists to fetch.
     */
    orderBy?: ArtistOrderByWithRelationInput | ArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Artists.
     */
    cursor?: ArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Artists.
     */
    distinct?: ArtistScalarFieldEnum | ArtistScalarFieldEnum[]
  }

  /**
   * Artist findMany
   */
  export type ArtistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    /**
     * Filter, which Artists to fetch.
     */
    where?: ArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artists to fetch.
     */
    orderBy?: ArtistOrderByWithRelationInput | ArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Artists.
     */
    cursor?: ArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artists.
     */
    skip?: number
    distinct?: ArtistScalarFieldEnum | ArtistScalarFieldEnum[]
  }

  /**
   * Artist create
   */
  export type ArtistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    /**
     * The data needed to create a Artist.
     */
    data: XOR<ArtistCreateInput, ArtistUncheckedCreateInput>
  }

  /**
   * Artist createMany
   */
  export type ArtistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Artists.
     */
    data: ArtistCreateManyInput | ArtistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Artist createManyAndReturn
   */
  export type ArtistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * The data used to create many Artists.
     */
    data: ArtistCreateManyInput | ArtistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Artist update
   */
  export type ArtistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    /**
     * The data needed to update a Artist.
     */
    data: XOR<ArtistUpdateInput, ArtistUncheckedUpdateInput>
    /**
     * Choose, which Artist to update.
     */
    where: ArtistWhereUniqueInput
  }

  /**
   * Artist updateMany
   */
  export type ArtistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Artists.
     */
    data: XOR<ArtistUpdateManyMutationInput, ArtistUncheckedUpdateManyInput>
    /**
     * Filter which Artists to update
     */
    where?: ArtistWhereInput
    /**
     * Limit how many Artists to update.
     */
    limit?: number
  }

  /**
   * Artist updateManyAndReturn
   */
  export type ArtistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * The data used to update Artists.
     */
    data: XOR<ArtistUpdateManyMutationInput, ArtistUncheckedUpdateManyInput>
    /**
     * Filter which Artists to update
     */
    where?: ArtistWhereInput
    /**
     * Limit how many Artists to update.
     */
    limit?: number
  }

  /**
   * Artist upsert
   */
  export type ArtistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    /**
     * The filter to search for the Artist to update in case it exists.
     */
    where: ArtistWhereUniqueInput
    /**
     * In case the Artist found by the `where` argument doesn't exist, create a new Artist with this data.
     */
    create: XOR<ArtistCreateInput, ArtistUncheckedCreateInput>
    /**
     * In case the Artist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArtistUpdateInput, ArtistUncheckedUpdateInput>
  }

  /**
   * Artist delete
   */
  export type ArtistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    /**
     * Filter which Artist to delete.
     */
    where: ArtistWhereUniqueInput
  }

  /**
   * Artist deleteMany
   */
  export type ArtistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Artists to delete
     */
    where?: ArtistWhereInput
    /**
     * Limit how many Artists to delete.
     */
    limit?: number
  }

  /**
   * Artist.albums
   */
  export type Artist$albumsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    where?: AlbumWhereInput
    orderBy?: AlbumOrderByWithRelationInput | AlbumOrderByWithRelationInput[]
    cursor?: AlbumWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlbumScalarFieldEnum | AlbumScalarFieldEnum[]
  }

  /**
   * Artist.songs
   */
  export type Artist$songsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistInclude<ExtArgs> | null
    where?: SongArtistWhereInput
    orderBy?: SongArtistOrderByWithRelationInput | SongArtistOrderByWithRelationInput[]
    cursor?: SongArtistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SongArtistScalarFieldEnum | SongArtistScalarFieldEnum[]
  }

  /**
   * Artist.genres
   */
  export type Artist$genresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreInclude<ExtArgs> | null
    where?: ArtistGenreWhereInput
    orderBy?: ArtistGenreOrderByWithRelationInput | ArtistGenreOrderByWithRelationInput[]
    cursor?: ArtistGenreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtistGenreScalarFieldEnum | ArtistGenreScalarFieldEnum[]
  }

  /**
   * Artist.likedBy
   */
  export type Artist$likedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedArtist
     */
    select?: UserLikedArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedArtist
     */
    omit?: UserLikedArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedArtistInclude<ExtArgs> | null
    where?: UserLikedArtistWhereInput
    orderBy?: UserLikedArtistOrderByWithRelationInput | UserLikedArtistOrderByWithRelationInput[]
    cursor?: UserLikedArtistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLikedArtistScalarFieldEnum | UserLikedArtistScalarFieldEnum[]
  }

  /**
   * Artist.credits
   */
  export type Artist$creditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongCredit
     */
    select?: SongCreditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongCredit
     */
    omit?: SongCreditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongCreditInclude<ExtArgs> | null
    where?: SongCreditWhereInput
    orderBy?: SongCreditOrderByWithRelationInput | SongCreditOrderByWithRelationInput[]
    cursor?: SongCreditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SongCreditScalarFieldEnum | SongCreditScalarFieldEnum[]
  }

  /**
   * Artist without action
   */
  export type ArtistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
  }


  /**
   * Model Album
   */

  export type AggregateAlbum = {
    _count: AlbumCountAggregateOutputType | null
    _avg: AlbumAvgAggregateOutputType | null
    _sum: AlbumSumAggregateOutputType | null
    _min: AlbumMinAggregateOutputType | null
    _max: AlbumMaxAggregateOutputType | null
  }

  export type AlbumAvgAggregateOutputType = {
    totalTracks: number | null
    duration: number | null
  }

  export type AlbumSumAggregateOutputType = {
    totalTracks: number | null
    duration: number | null
  }

  export type AlbumMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    imageId: string | null
    albumType: $Enums.AlbumType | null
    releaseDate: Date | null
    totalTracks: number | null
    duration: number | null
    createdAt: Date | null
    updatedAt: Date | null
    artistId: string | null
  }

  export type AlbumMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    imageId: string | null
    albumType: $Enums.AlbumType | null
    releaseDate: Date | null
    totalTracks: number | null
    duration: number | null
    createdAt: Date | null
    updatedAt: Date | null
    artistId: string | null
  }

  export type AlbumCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    description: number
    imageId: number
    albumType: number
    releaseDate: number
    totalTracks: number
    duration: number
    createdAt: number
    updatedAt: number
    artistId: number
    _all: number
  }


  export type AlbumAvgAggregateInputType = {
    totalTracks?: true
    duration?: true
  }

  export type AlbumSumAggregateInputType = {
    totalTracks?: true
    duration?: true
  }

  export type AlbumMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    imageId?: true
    albumType?: true
    releaseDate?: true
    totalTracks?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
    artistId?: true
  }

  export type AlbumMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    imageId?: true
    albumType?: true
    releaseDate?: true
    totalTracks?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
    artistId?: true
  }

  export type AlbumCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    imageId?: true
    albumType?: true
    releaseDate?: true
    totalTracks?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
    artistId?: true
    _all?: true
  }

  export type AlbumAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Album to aggregate.
     */
    where?: AlbumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Albums to fetch.
     */
    orderBy?: AlbumOrderByWithRelationInput | AlbumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlbumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Albums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Albums
    **/
    _count?: true | AlbumCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlbumAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlbumSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlbumMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlbumMaxAggregateInputType
  }

  export type GetAlbumAggregateType<T extends AlbumAggregateArgs> = {
        [P in keyof T & keyof AggregateAlbum]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlbum[P]>
      : GetScalarType<T[P], AggregateAlbum[P]>
  }




  export type AlbumGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlbumWhereInput
    orderBy?: AlbumOrderByWithAggregationInput | AlbumOrderByWithAggregationInput[]
    by: AlbumScalarFieldEnum[] | AlbumScalarFieldEnum
    having?: AlbumScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlbumCountAggregateInputType | true
    _avg?: AlbumAvgAggregateInputType
    _sum?: AlbumSumAggregateInputType
    _min?: AlbumMinAggregateInputType
    _max?: AlbumMaxAggregateInputType
  }

  export type AlbumGroupByOutputType = {
    id: string
    title: string
    slug: string
    description: string | null
    imageId: string
    albumType: $Enums.AlbumType
    releaseDate: Date
    totalTracks: number
    duration: number
    createdAt: Date
    updatedAt: Date
    artistId: string
    _count: AlbumCountAggregateOutputType | null
    _avg: AlbumAvgAggregateOutputType | null
    _sum: AlbumSumAggregateOutputType | null
    _min: AlbumMinAggregateOutputType | null
    _max: AlbumMaxAggregateOutputType | null
  }

  type GetAlbumGroupByPayload<T extends AlbumGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlbumGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlbumGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlbumGroupByOutputType[P]>
            : GetScalarType<T[P], AlbumGroupByOutputType[P]>
        }
      >
    >


  export type AlbumSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    imageId?: boolean
    albumType?: boolean
    releaseDate?: boolean
    totalTracks?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    artistId?: boolean
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
    songs?: boolean | Album$songsArgs<ExtArgs>
    genres?: boolean | Album$genresArgs<ExtArgs>
    likedBy?: boolean | Album$likedByArgs<ExtArgs>
    _count?: boolean | AlbumCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["album"]>

  export type AlbumSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    imageId?: boolean
    albumType?: boolean
    releaseDate?: boolean
    totalTracks?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    artistId?: boolean
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["album"]>

  export type AlbumSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    imageId?: boolean
    albumType?: boolean
    releaseDate?: boolean
    totalTracks?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    artistId?: boolean
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["album"]>

  export type AlbumSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    imageId?: boolean
    albumType?: boolean
    releaseDate?: boolean
    totalTracks?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    artistId?: boolean
  }

  export type AlbumOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "description" | "imageId" | "albumType" | "releaseDate" | "totalTracks" | "duration" | "createdAt" | "updatedAt" | "artistId", ExtArgs["result"]["album"]>
  export type AlbumInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
    songs?: boolean | Album$songsArgs<ExtArgs>
    genres?: boolean | Album$genresArgs<ExtArgs>
    likedBy?: boolean | Album$likedByArgs<ExtArgs>
    _count?: boolean | AlbumCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AlbumIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
  }
  export type AlbumIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
  }

  export type $AlbumPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Album"
    objects: {
      artist: Prisma.$ArtistPayload<ExtArgs>
      songs: Prisma.$SongPayload<ExtArgs>[]
      genres: Prisma.$AlbumGenrePayload<ExtArgs>[]
      likedBy: Prisma.$UserLikedAlbumPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      description: string | null
      imageId: string
      albumType: $Enums.AlbumType
      releaseDate: Date
      totalTracks: number
      duration: number
      createdAt: Date
      updatedAt: Date
      artistId: string
    }, ExtArgs["result"]["album"]>
    composites: {}
  }

  type AlbumGetPayload<S extends boolean | null | undefined | AlbumDefaultArgs> = $Result.GetResult<Prisma.$AlbumPayload, S>

  type AlbumCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlbumFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlbumCountAggregateInputType | true
    }

  export interface AlbumDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Album'], meta: { name: 'Album' } }
    /**
     * Find zero or one Album that matches the filter.
     * @param {AlbumFindUniqueArgs} args - Arguments to find a Album
     * @example
     * // Get one Album
     * const album = await prisma.album.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlbumFindUniqueArgs>(args: SelectSubset<T, AlbumFindUniqueArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Album that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlbumFindUniqueOrThrowArgs} args - Arguments to find a Album
     * @example
     * // Get one Album
     * const album = await prisma.album.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlbumFindUniqueOrThrowArgs>(args: SelectSubset<T, AlbumFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Album that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumFindFirstArgs} args - Arguments to find a Album
     * @example
     * // Get one Album
     * const album = await prisma.album.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlbumFindFirstArgs>(args?: SelectSubset<T, AlbumFindFirstArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Album that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumFindFirstOrThrowArgs} args - Arguments to find a Album
     * @example
     * // Get one Album
     * const album = await prisma.album.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlbumFindFirstOrThrowArgs>(args?: SelectSubset<T, AlbumFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Albums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Albums
     * const albums = await prisma.album.findMany()
     * 
     * // Get first 10 Albums
     * const albums = await prisma.album.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const albumWithIdOnly = await prisma.album.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlbumFindManyArgs>(args?: SelectSubset<T, AlbumFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Album.
     * @param {AlbumCreateArgs} args - Arguments to create a Album.
     * @example
     * // Create one Album
     * const Album = await prisma.album.create({
     *   data: {
     *     // ... data to create a Album
     *   }
     * })
     * 
     */
    create<T extends AlbumCreateArgs>(args: SelectSubset<T, AlbumCreateArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Albums.
     * @param {AlbumCreateManyArgs} args - Arguments to create many Albums.
     * @example
     * // Create many Albums
     * const album = await prisma.album.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlbumCreateManyArgs>(args?: SelectSubset<T, AlbumCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Albums and returns the data saved in the database.
     * @param {AlbumCreateManyAndReturnArgs} args - Arguments to create many Albums.
     * @example
     * // Create many Albums
     * const album = await prisma.album.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Albums and only return the `id`
     * const albumWithIdOnly = await prisma.album.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlbumCreateManyAndReturnArgs>(args?: SelectSubset<T, AlbumCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Album.
     * @param {AlbumDeleteArgs} args - Arguments to delete one Album.
     * @example
     * // Delete one Album
     * const Album = await prisma.album.delete({
     *   where: {
     *     // ... filter to delete one Album
     *   }
     * })
     * 
     */
    delete<T extends AlbumDeleteArgs>(args: SelectSubset<T, AlbumDeleteArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Album.
     * @param {AlbumUpdateArgs} args - Arguments to update one Album.
     * @example
     * // Update one Album
     * const album = await prisma.album.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlbumUpdateArgs>(args: SelectSubset<T, AlbumUpdateArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Albums.
     * @param {AlbumDeleteManyArgs} args - Arguments to filter Albums to delete.
     * @example
     * // Delete a few Albums
     * const { count } = await prisma.album.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlbumDeleteManyArgs>(args?: SelectSubset<T, AlbumDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Albums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Albums
     * const album = await prisma.album.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlbumUpdateManyArgs>(args: SelectSubset<T, AlbumUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Albums and returns the data updated in the database.
     * @param {AlbumUpdateManyAndReturnArgs} args - Arguments to update many Albums.
     * @example
     * // Update many Albums
     * const album = await prisma.album.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Albums and only return the `id`
     * const albumWithIdOnly = await prisma.album.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlbumUpdateManyAndReturnArgs>(args: SelectSubset<T, AlbumUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Album.
     * @param {AlbumUpsertArgs} args - Arguments to update or create a Album.
     * @example
     * // Update or create a Album
     * const album = await prisma.album.upsert({
     *   create: {
     *     // ... data to create a Album
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Album we want to update
     *   }
     * })
     */
    upsert<T extends AlbumUpsertArgs>(args: SelectSubset<T, AlbumUpsertArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Albums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumCountArgs} args - Arguments to filter Albums to count.
     * @example
     * // Count the number of Albums
     * const count = await prisma.album.count({
     *   where: {
     *     // ... the filter for the Albums we want to count
     *   }
     * })
    **/
    count<T extends AlbumCountArgs>(
      args?: Subset<T, AlbumCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlbumCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Album.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlbumAggregateArgs>(args: Subset<T, AlbumAggregateArgs>): Prisma.PrismaPromise<GetAlbumAggregateType<T>>

    /**
     * Group by Album.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlbumGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlbumGroupByArgs['orderBy'] }
        : { orderBy?: AlbumGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlbumGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlbumGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Album model
   */
  readonly fields: AlbumFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Album.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlbumClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    artist<T extends ArtistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArtistDefaultArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    songs<T extends Album$songsArgs<ExtArgs> = {}>(args?: Subset<T, Album$songsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    genres<T extends Album$genresArgs<ExtArgs> = {}>(args?: Subset<T, Album$genresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlbumGenrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likedBy<T extends Album$likedByArgs<ExtArgs> = {}>(args?: Subset<T, Album$likedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLikedAlbumPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Album model
   */
  interface AlbumFieldRefs {
    readonly id: FieldRef<"Album", 'String'>
    readonly title: FieldRef<"Album", 'String'>
    readonly slug: FieldRef<"Album", 'String'>
    readonly description: FieldRef<"Album", 'String'>
    readonly imageId: FieldRef<"Album", 'String'>
    readonly albumType: FieldRef<"Album", 'AlbumType'>
    readonly releaseDate: FieldRef<"Album", 'DateTime'>
    readonly totalTracks: FieldRef<"Album", 'Int'>
    readonly duration: FieldRef<"Album", 'Int'>
    readonly createdAt: FieldRef<"Album", 'DateTime'>
    readonly updatedAt: FieldRef<"Album", 'DateTime'>
    readonly artistId: FieldRef<"Album", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Album findUnique
   */
  export type AlbumFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * Filter, which Album to fetch.
     */
    where: AlbumWhereUniqueInput
  }

  /**
   * Album findUniqueOrThrow
   */
  export type AlbumFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * Filter, which Album to fetch.
     */
    where: AlbumWhereUniqueInput
  }

  /**
   * Album findFirst
   */
  export type AlbumFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * Filter, which Album to fetch.
     */
    where?: AlbumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Albums to fetch.
     */
    orderBy?: AlbumOrderByWithRelationInput | AlbumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Albums.
     */
    cursor?: AlbumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Albums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Albums.
     */
    distinct?: AlbumScalarFieldEnum | AlbumScalarFieldEnum[]
  }

  /**
   * Album findFirstOrThrow
   */
  export type AlbumFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * Filter, which Album to fetch.
     */
    where?: AlbumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Albums to fetch.
     */
    orderBy?: AlbumOrderByWithRelationInput | AlbumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Albums.
     */
    cursor?: AlbumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Albums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Albums.
     */
    distinct?: AlbumScalarFieldEnum | AlbumScalarFieldEnum[]
  }

  /**
   * Album findMany
   */
  export type AlbumFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * Filter, which Albums to fetch.
     */
    where?: AlbumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Albums to fetch.
     */
    orderBy?: AlbumOrderByWithRelationInput | AlbumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Albums.
     */
    cursor?: AlbumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Albums.
     */
    skip?: number
    distinct?: AlbumScalarFieldEnum | AlbumScalarFieldEnum[]
  }

  /**
   * Album create
   */
  export type AlbumCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * The data needed to create a Album.
     */
    data: XOR<AlbumCreateInput, AlbumUncheckedCreateInput>
  }

  /**
   * Album createMany
   */
  export type AlbumCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Albums.
     */
    data: AlbumCreateManyInput | AlbumCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Album createManyAndReturn
   */
  export type AlbumCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * The data used to create many Albums.
     */
    data: AlbumCreateManyInput | AlbumCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Album update
   */
  export type AlbumUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * The data needed to update a Album.
     */
    data: XOR<AlbumUpdateInput, AlbumUncheckedUpdateInput>
    /**
     * Choose, which Album to update.
     */
    where: AlbumWhereUniqueInput
  }

  /**
   * Album updateMany
   */
  export type AlbumUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Albums.
     */
    data: XOR<AlbumUpdateManyMutationInput, AlbumUncheckedUpdateManyInput>
    /**
     * Filter which Albums to update
     */
    where?: AlbumWhereInput
    /**
     * Limit how many Albums to update.
     */
    limit?: number
  }

  /**
   * Album updateManyAndReturn
   */
  export type AlbumUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * The data used to update Albums.
     */
    data: XOR<AlbumUpdateManyMutationInput, AlbumUncheckedUpdateManyInput>
    /**
     * Filter which Albums to update
     */
    where?: AlbumWhereInput
    /**
     * Limit how many Albums to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Album upsert
   */
  export type AlbumUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * The filter to search for the Album to update in case it exists.
     */
    where: AlbumWhereUniqueInput
    /**
     * In case the Album found by the `where` argument doesn't exist, create a new Album with this data.
     */
    create: XOR<AlbumCreateInput, AlbumUncheckedCreateInput>
    /**
     * In case the Album was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlbumUpdateInput, AlbumUncheckedUpdateInput>
  }

  /**
   * Album delete
   */
  export type AlbumDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * Filter which Album to delete.
     */
    where: AlbumWhereUniqueInput
  }

  /**
   * Album deleteMany
   */
  export type AlbumDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Albums to delete
     */
    where?: AlbumWhereInput
    /**
     * Limit how many Albums to delete.
     */
    limit?: number
  }

  /**
   * Album.songs
   */
  export type Album$songsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongInclude<ExtArgs> | null
    where?: SongWhereInput
    orderBy?: SongOrderByWithRelationInput | SongOrderByWithRelationInput[]
    cursor?: SongWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SongScalarFieldEnum | SongScalarFieldEnum[]
  }

  /**
   * Album.genres
   */
  export type Album$genresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumGenre
     */
    select?: AlbumGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlbumGenre
     */
    omit?: AlbumGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumGenreInclude<ExtArgs> | null
    where?: AlbumGenreWhereInput
    orderBy?: AlbumGenreOrderByWithRelationInput | AlbumGenreOrderByWithRelationInput[]
    cursor?: AlbumGenreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlbumGenreScalarFieldEnum | AlbumGenreScalarFieldEnum[]
  }

  /**
   * Album.likedBy
   */
  export type Album$likedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedAlbum
     */
    select?: UserLikedAlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedAlbum
     */
    omit?: UserLikedAlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedAlbumInclude<ExtArgs> | null
    where?: UserLikedAlbumWhereInput
    orderBy?: UserLikedAlbumOrderByWithRelationInput | UserLikedAlbumOrderByWithRelationInput[]
    cursor?: UserLikedAlbumWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLikedAlbumScalarFieldEnum | UserLikedAlbumScalarFieldEnum[]
  }

  /**
   * Album without action
   */
  export type AlbumDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
  }


  /**
   * Model Song
   */

  export type AggregateSong = {
    _count: SongCountAggregateOutputType | null
    _avg: SongAvgAggregateOutputType | null
    _sum: SongSumAggregateOutputType | null
    _min: SongMinAggregateOutputType | null
    _max: SongMaxAggregateOutputType | null
  }

  export type SongAvgAggregateOutputType = {
    duration: number | null
    trackNumber: number | null
    playCount: number | null
  }

  export type SongSumAggregateOutputType = {
    duration: number | null
    trackNumber: number | null
    playCount: number | null
  }

  export type SongMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    audioId: string | null
    duration: number | null
    trackNumber: number | null
    lyrics: string | null
    isExplicit: boolean | null
    playCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    albumId: string | null
  }

  export type SongMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    audioId: string | null
    duration: number | null
    trackNumber: number | null
    lyrics: string | null
    isExplicit: boolean | null
    playCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    albumId: string | null
  }

  export type SongCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    audioId: number
    duration: number
    trackNumber: number
    lyrics: number
    isExplicit: number
    playCount: number
    createdAt: number
    updatedAt: number
    albumId: number
    _all: number
  }


  export type SongAvgAggregateInputType = {
    duration?: true
    trackNumber?: true
    playCount?: true
  }

  export type SongSumAggregateInputType = {
    duration?: true
    trackNumber?: true
    playCount?: true
  }

  export type SongMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    audioId?: true
    duration?: true
    trackNumber?: true
    lyrics?: true
    isExplicit?: true
    playCount?: true
    createdAt?: true
    updatedAt?: true
    albumId?: true
  }

  export type SongMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    audioId?: true
    duration?: true
    trackNumber?: true
    lyrics?: true
    isExplicit?: true
    playCount?: true
    createdAt?: true
    updatedAt?: true
    albumId?: true
  }

  export type SongCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    audioId?: true
    duration?: true
    trackNumber?: true
    lyrics?: true
    isExplicit?: true
    playCount?: true
    createdAt?: true
    updatedAt?: true
    albumId?: true
    _all?: true
  }

  export type SongAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Song to aggregate.
     */
    where?: SongWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Songs to fetch.
     */
    orderBy?: SongOrderByWithRelationInput | SongOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SongWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Songs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Songs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Songs
    **/
    _count?: true | SongCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SongAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SongSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SongMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SongMaxAggregateInputType
  }

  export type GetSongAggregateType<T extends SongAggregateArgs> = {
        [P in keyof T & keyof AggregateSong]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSong[P]>
      : GetScalarType<T[P], AggregateSong[P]>
  }




  export type SongGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SongWhereInput
    orderBy?: SongOrderByWithAggregationInput | SongOrderByWithAggregationInput[]
    by: SongScalarFieldEnum[] | SongScalarFieldEnum
    having?: SongScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SongCountAggregateInputType | true
    _avg?: SongAvgAggregateInputType
    _sum?: SongSumAggregateInputType
    _min?: SongMinAggregateInputType
    _max?: SongMaxAggregateInputType
  }

  export type SongGroupByOutputType = {
    id: string
    title: string
    slug: string
    audioId: string
    duration: number
    trackNumber: number
    lyrics: string | null
    isExplicit: boolean
    playCount: number
    createdAt: Date
    updatedAt: Date
    albumId: string
    _count: SongCountAggregateOutputType | null
    _avg: SongAvgAggregateOutputType | null
    _sum: SongSumAggregateOutputType | null
    _min: SongMinAggregateOutputType | null
    _max: SongMaxAggregateOutputType | null
  }

  type GetSongGroupByPayload<T extends SongGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SongGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SongGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SongGroupByOutputType[P]>
            : GetScalarType<T[P], SongGroupByOutputType[P]>
        }
      >
    >


  export type SongSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    audioId?: boolean
    duration?: boolean
    trackNumber?: boolean
    lyrics?: boolean
    isExplicit?: boolean
    playCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    albumId?: boolean
    album?: boolean | AlbumDefaultArgs<ExtArgs>
    artists?: boolean | Song$artistsArgs<ExtArgs>
    credits?: boolean | Song$creditsArgs<ExtArgs>
    genres?: boolean | Song$genresArgs<ExtArgs>
    likedBy?: boolean | Song$likedByArgs<ExtArgs>
    playlistItems?: boolean | Song$playlistItemsArgs<ExtArgs>
    playHistory?: boolean | Song$playHistoryArgs<ExtArgs>
    _count?: boolean | SongCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["song"]>

  export type SongSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    audioId?: boolean
    duration?: boolean
    trackNumber?: boolean
    lyrics?: boolean
    isExplicit?: boolean
    playCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    albumId?: boolean
    album?: boolean | AlbumDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["song"]>

  export type SongSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    audioId?: boolean
    duration?: boolean
    trackNumber?: boolean
    lyrics?: boolean
    isExplicit?: boolean
    playCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    albumId?: boolean
    album?: boolean | AlbumDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["song"]>

  export type SongSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    audioId?: boolean
    duration?: boolean
    trackNumber?: boolean
    lyrics?: boolean
    isExplicit?: boolean
    playCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    albumId?: boolean
  }

  export type SongOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "audioId" | "duration" | "trackNumber" | "lyrics" | "isExplicit" | "playCount" | "createdAt" | "updatedAt" | "albumId", ExtArgs["result"]["song"]>
  export type SongInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    album?: boolean | AlbumDefaultArgs<ExtArgs>
    artists?: boolean | Song$artistsArgs<ExtArgs>
    credits?: boolean | Song$creditsArgs<ExtArgs>
    genres?: boolean | Song$genresArgs<ExtArgs>
    likedBy?: boolean | Song$likedByArgs<ExtArgs>
    playlistItems?: boolean | Song$playlistItemsArgs<ExtArgs>
    playHistory?: boolean | Song$playHistoryArgs<ExtArgs>
    _count?: boolean | SongCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SongIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    album?: boolean | AlbumDefaultArgs<ExtArgs>
  }
  export type SongIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    album?: boolean | AlbumDefaultArgs<ExtArgs>
  }

  export type $SongPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Song"
    objects: {
      album: Prisma.$AlbumPayload<ExtArgs>
      artists: Prisma.$SongArtistPayload<ExtArgs>[]
      credits: Prisma.$SongCreditPayload<ExtArgs>[]
      genres: Prisma.$SongGenrePayload<ExtArgs>[]
      likedBy: Prisma.$UserLikedSongPayload<ExtArgs>[]
      playlistItems: Prisma.$PlaylistItemPayload<ExtArgs>[]
      playHistory: Prisma.$PlayHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      audioId: string
      duration: number
      trackNumber: number
      lyrics: string | null
      isExplicit: boolean
      playCount: number
      createdAt: Date
      updatedAt: Date
      albumId: string
    }, ExtArgs["result"]["song"]>
    composites: {}
  }

  type SongGetPayload<S extends boolean | null | undefined | SongDefaultArgs> = $Result.GetResult<Prisma.$SongPayload, S>

  type SongCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SongFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SongCountAggregateInputType | true
    }

  export interface SongDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Song'], meta: { name: 'Song' } }
    /**
     * Find zero or one Song that matches the filter.
     * @param {SongFindUniqueArgs} args - Arguments to find a Song
     * @example
     * // Get one Song
     * const song = await prisma.song.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SongFindUniqueArgs>(args: SelectSubset<T, SongFindUniqueArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Song that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SongFindUniqueOrThrowArgs} args - Arguments to find a Song
     * @example
     * // Get one Song
     * const song = await prisma.song.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SongFindUniqueOrThrowArgs>(args: SelectSubset<T, SongFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Song that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongFindFirstArgs} args - Arguments to find a Song
     * @example
     * // Get one Song
     * const song = await prisma.song.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SongFindFirstArgs>(args?: SelectSubset<T, SongFindFirstArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Song that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongFindFirstOrThrowArgs} args - Arguments to find a Song
     * @example
     * // Get one Song
     * const song = await prisma.song.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SongFindFirstOrThrowArgs>(args?: SelectSubset<T, SongFindFirstOrThrowArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Songs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Songs
     * const songs = await prisma.song.findMany()
     * 
     * // Get first 10 Songs
     * const songs = await prisma.song.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const songWithIdOnly = await prisma.song.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SongFindManyArgs>(args?: SelectSubset<T, SongFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Song.
     * @param {SongCreateArgs} args - Arguments to create a Song.
     * @example
     * // Create one Song
     * const Song = await prisma.song.create({
     *   data: {
     *     // ... data to create a Song
     *   }
     * })
     * 
     */
    create<T extends SongCreateArgs>(args: SelectSubset<T, SongCreateArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Songs.
     * @param {SongCreateManyArgs} args - Arguments to create many Songs.
     * @example
     * // Create many Songs
     * const song = await prisma.song.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SongCreateManyArgs>(args?: SelectSubset<T, SongCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Songs and returns the data saved in the database.
     * @param {SongCreateManyAndReturnArgs} args - Arguments to create many Songs.
     * @example
     * // Create many Songs
     * const song = await prisma.song.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Songs and only return the `id`
     * const songWithIdOnly = await prisma.song.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SongCreateManyAndReturnArgs>(args?: SelectSubset<T, SongCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Song.
     * @param {SongDeleteArgs} args - Arguments to delete one Song.
     * @example
     * // Delete one Song
     * const Song = await prisma.song.delete({
     *   where: {
     *     // ... filter to delete one Song
     *   }
     * })
     * 
     */
    delete<T extends SongDeleteArgs>(args: SelectSubset<T, SongDeleteArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Song.
     * @param {SongUpdateArgs} args - Arguments to update one Song.
     * @example
     * // Update one Song
     * const song = await prisma.song.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SongUpdateArgs>(args: SelectSubset<T, SongUpdateArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Songs.
     * @param {SongDeleteManyArgs} args - Arguments to filter Songs to delete.
     * @example
     * // Delete a few Songs
     * const { count } = await prisma.song.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SongDeleteManyArgs>(args?: SelectSubset<T, SongDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Songs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Songs
     * const song = await prisma.song.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SongUpdateManyArgs>(args: SelectSubset<T, SongUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Songs and returns the data updated in the database.
     * @param {SongUpdateManyAndReturnArgs} args - Arguments to update many Songs.
     * @example
     * // Update many Songs
     * const song = await prisma.song.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Songs and only return the `id`
     * const songWithIdOnly = await prisma.song.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SongUpdateManyAndReturnArgs>(args: SelectSubset<T, SongUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Song.
     * @param {SongUpsertArgs} args - Arguments to update or create a Song.
     * @example
     * // Update or create a Song
     * const song = await prisma.song.upsert({
     *   create: {
     *     // ... data to create a Song
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Song we want to update
     *   }
     * })
     */
    upsert<T extends SongUpsertArgs>(args: SelectSubset<T, SongUpsertArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Songs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongCountArgs} args - Arguments to filter Songs to count.
     * @example
     * // Count the number of Songs
     * const count = await prisma.song.count({
     *   where: {
     *     // ... the filter for the Songs we want to count
     *   }
     * })
    **/
    count<T extends SongCountArgs>(
      args?: Subset<T, SongCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SongCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Song.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SongAggregateArgs>(args: Subset<T, SongAggregateArgs>): Prisma.PrismaPromise<GetSongAggregateType<T>>

    /**
     * Group by Song.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SongGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SongGroupByArgs['orderBy'] }
        : { orderBy?: SongGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SongGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSongGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Song model
   */
  readonly fields: SongFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Song.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SongClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    album<T extends AlbumDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlbumDefaultArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    artists<T extends Song$artistsArgs<ExtArgs> = {}>(args?: Subset<T, Song$artistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongArtistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    credits<T extends Song$creditsArgs<ExtArgs> = {}>(args?: Subset<T, Song$creditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongCreditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    genres<T extends Song$genresArgs<ExtArgs> = {}>(args?: Subset<T, Song$genresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongGenrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likedBy<T extends Song$likedByArgs<ExtArgs> = {}>(args?: Subset<T, Song$likedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLikedSongPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    playlistItems<T extends Song$playlistItemsArgs<ExtArgs> = {}>(args?: Subset<T, Song$playlistItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    playHistory<T extends Song$playHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Song$playHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Song model
   */
  interface SongFieldRefs {
    readonly id: FieldRef<"Song", 'String'>
    readonly title: FieldRef<"Song", 'String'>
    readonly slug: FieldRef<"Song", 'String'>
    readonly audioId: FieldRef<"Song", 'String'>
    readonly duration: FieldRef<"Song", 'Int'>
    readonly trackNumber: FieldRef<"Song", 'Int'>
    readonly lyrics: FieldRef<"Song", 'String'>
    readonly isExplicit: FieldRef<"Song", 'Boolean'>
    readonly playCount: FieldRef<"Song", 'Int'>
    readonly createdAt: FieldRef<"Song", 'DateTime'>
    readonly updatedAt: FieldRef<"Song", 'DateTime'>
    readonly albumId: FieldRef<"Song", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Song findUnique
   */
  export type SongFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongInclude<ExtArgs> | null
    /**
     * Filter, which Song to fetch.
     */
    where: SongWhereUniqueInput
  }

  /**
   * Song findUniqueOrThrow
   */
  export type SongFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongInclude<ExtArgs> | null
    /**
     * Filter, which Song to fetch.
     */
    where: SongWhereUniqueInput
  }

  /**
   * Song findFirst
   */
  export type SongFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongInclude<ExtArgs> | null
    /**
     * Filter, which Song to fetch.
     */
    where?: SongWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Songs to fetch.
     */
    orderBy?: SongOrderByWithRelationInput | SongOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Songs.
     */
    cursor?: SongWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Songs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Songs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Songs.
     */
    distinct?: SongScalarFieldEnum | SongScalarFieldEnum[]
  }

  /**
   * Song findFirstOrThrow
   */
  export type SongFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongInclude<ExtArgs> | null
    /**
     * Filter, which Song to fetch.
     */
    where?: SongWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Songs to fetch.
     */
    orderBy?: SongOrderByWithRelationInput | SongOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Songs.
     */
    cursor?: SongWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Songs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Songs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Songs.
     */
    distinct?: SongScalarFieldEnum | SongScalarFieldEnum[]
  }

  /**
   * Song findMany
   */
  export type SongFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongInclude<ExtArgs> | null
    /**
     * Filter, which Songs to fetch.
     */
    where?: SongWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Songs to fetch.
     */
    orderBy?: SongOrderByWithRelationInput | SongOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Songs.
     */
    cursor?: SongWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Songs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Songs.
     */
    skip?: number
    distinct?: SongScalarFieldEnum | SongScalarFieldEnum[]
  }

  /**
   * Song create
   */
  export type SongCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongInclude<ExtArgs> | null
    /**
     * The data needed to create a Song.
     */
    data: XOR<SongCreateInput, SongUncheckedCreateInput>
  }

  /**
   * Song createMany
   */
  export type SongCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Songs.
     */
    data: SongCreateManyInput | SongCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Song createManyAndReturn
   */
  export type SongCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * The data used to create many Songs.
     */
    data: SongCreateManyInput | SongCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Song update
   */
  export type SongUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongInclude<ExtArgs> | null
    /**
     * The data needed to update a Song.
     */
    data: XOR<SongUpdateInput, SongUncheckedUpdateInput>
    /**
     * Choose, which Song to update.
     */
    where: SongWhereUniqueInput
  }

  /**
   * Song updateMany
   */
  export type SongUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Songs.
     */
    data: XOR<SongUpdateManyMutationInput, SongUncheckedUpdateManyInput>
    /**
     * Filter which Songs to update
     */
    where?: SongWhereInput
    /**
     * Limit how many Songs to update.
     */
    limit?: number
  }

  /**
   * Song updateManyAndReturn
   */
  export type SongUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * The data used to update Songs.
     */
    data: XOR<SongUpdateManyMutationInput, SongUncheckedUpdateManyInput>
    /**
     * Filter which Songs to update
     */
    where?: SongWhereInput
    /**
     * Limit how many Songs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Song upsert
   */
  export type SongUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongInclude<ExtArgs> | null
    /**
     * The filter to search for the Song to update in case it exists.
     */
    where: SongWhereUniqueInput
    /**
     * In case the Song found by the `where` argument doesn't exist, create a new Song with this data.
     */
    create: XOR<SongCreateInput, SongUncheckedCreateInput>
    /**
     * In case the Song was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SongUpdateInput, SongUncheckedUpdateInput>
  }

  /**
   * Song delete
   */
  export type SongDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongInclude<ExtArgs> | null
    /**
     * Filter which Song to delete.
     */
    where: SongWhereUniqueInput
  }

  /**
   * Song deleteMany
   */
  export type SongDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Songs to delete
     */
    where?: SongWhereInput
    /**
     * Limit how many Songs to delete.
     */
    limit?: number
  }

  /**
   * Song.artists
   */
  export type Song$artistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistInclude<ExtArgs> | null
    where?: SongArtistWhereInput
    orderBy?: SongArtistOrderByWithRelationInput | SongArtistOrderByWithRelationInput[]
    cursor?: SongArtistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SongArtistScalarFieldEnum | SongArtistScalarFieldEnum[]
  }

  /**
   * Song.credits
   */
  export type Song$creditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongCredit
     */
    select?: SongCreditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongCredit
     */
    omit?: SongCreditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongCreditInclude<ExtArgs> | null
    where?: SongCreditWhereInput
    orderBy?: SongCreditOrderByWithRelationInput | SongCreditOrderByWithRelationInput[]
    cursor?: SongCreditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SongCreditScalarFieldEnum | SongCreditScalarFieldEnum[]
  }

  /**
   * Song.genres
   */
  export type Song$genresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreInclude<ExtArgs> | null
    where?: SongGenreWhereInput
    orderBy?: SongGenreOrderByWithRelationInput | SongGenreOrderByWithRelationInput[]
    cursor?: SongGenreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SongGenreScalarFieldEnum | SongGenreScalarFieldEnum[]
  }

  /**
   * Song.likedBy
   */
  export type Song$likedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedSong
     */
    select?: UserLikedSongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedSong
     */
    omit?: UserLikedSongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedSongInclude<ExtArgs> | null
    where?: UserLikedSongWhereInput
    orderBy?: UserLikedSongOrderByWithRelationInput | UserLikedSongOrderByWithRelationInput[]
    cursor?: UserLikedSongWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLikedSongScalarFieldEnum | UserLikedSongScalarFieldEnum[]
  }

  /**
   * Song.playlistItems
   */
  export type Song$playlistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemInclude<ExtArgs> | null
    where?: PlaylistItemWhereInput
    orderBy?: PlaylistItemOrderByWithRelationInput | PlaylistItemOrderByWithRelationInput[]
    cursor?: PlaylistItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaylistItemScalarFieldEnum | PlaylistItemScalarFieldEnum[]
  }

  /**
   * Song.playHistory
   */
  export type Song$playHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayHistory
     */
    select?: PlayHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayHistory
     */
    omit?: PlayHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayHistoryInclude<ExtArgs> | null
    where?: PlayHistoryWhereInput
    orderBy?: PlayHistoryOrderByWithRelationInput | PlayHistoryOrderByWithRelationInput[]
    cursor?: PlayHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayHistoryScalarFieldEnum | PlayHistoryScalarFieldEnum[]
  }

  /**
   * Song without action
   */
  export type SongDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongInclude<ExtArgs> | null
  }


  /**
   * Model Genre
   */

  export type AggregateGenre = {
    _count: GenreCountAggregateOutputType | null
    _min: GenreMinAggregateOutputType | null
    _max: GenreMaxAggregateOutputType | null
  }

  export type GenreMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    color: string | null
  }

  export type GenreMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    color: string | null
  }

  export type GenreCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    color: number
    _all: number
  }


  export type GenreMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    color?: true
  }

  export type GenreMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    color?: true
  }

  export type GenreCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    color?: true
    _all?: true
  }

  export type GenreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genre to aggregate.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Genres
    **/
    _count?: true | GenreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenreMaxAggregateInputType
  }

  export type GetGenreAggregateType<T extends GenreAggregateArgs> = {
        [P in keyof T & keyof AggregateGenre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGenre[P]>
      : GetScalarType<T[P], AggregateGenre[P]>
  }




  export type GenreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GenreWhereInput
    orderBy?: GenreOrderByWithAggregationInput | GenreOrderByWithAggregationInput[]
    by: GenreScalarFieldEnum[] | GenreScalarFieldEnum
    having?: GenreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenreCountAggregateInputType | true
    _min?: GenreMinAggregateInputType
    _max?: GenreMaxAggregateInputType
  }

  export type GenreGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    color: string | null
    _count: GenreCountAggregateOutputType | null
    _min: GenreMinAggregateOutputType | null
    _max: GenreMaxAggregateOutputType | null
  }

  type GetGenreGroupByPayload<T extends GenreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GenreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenreGroupByOutputType[P]>
            : GetScalarType<T[P], GenreGroupByOutputType[P]>
        }
      >
    >


  export type GenreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    color?: boolean
    songs?: boolean | Genre$songsArgs<ExtArgs>
    albums?: boolean | Genre$albumsArgs<ExtArgs>
    artists?: boolean | Genre$artistsArgs<ExtArgs>
    _count?: boolean | GenreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["genre"]>

  export type GenreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    color?: boolean
  }, ExtArgs["result"]["genre"]>

  export type GenreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    color?: boolean
  }, ExtArgs["result"]["genre"]>

  export type GenreSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    color?: boolean
  }

  export type GenreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "color", ExtArgs["result"]["genre"]>
  export type GenreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    songs?: boolean | Genre$songsArgs<ExtArgs>
    albums?: boolean | Genre$albumsArgs<ExtArgs>
    artists?: boolean | Genre$artistsArgs<ExtArgs>
    _count?: boolean | GenreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GenreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GenreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GenrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Genre"
    objects: {
      songs: Prisma.$SongGenrePayload<ExtArgs>[]
      albums: Prisma.$AlbumGenrePayload<ExtArgs>[]
      artists: Prisma.$ArtistGenrePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      color: string | null
    }, ExtArgs["result"]["genre"]>
    composites: {}
  }

  type GenreGetPayload<S extends boolean | null | undefined | GenreDefaultArgs> = $Result.GetResult<Prisma.$GenrePayload, S>

  type GenreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GenreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GenreCountAggregateInputType | true
    }

  export interface GenreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Genre'], meta: { name: 'Genre' } }
    /**
     * Find zero or one Genre that matches the filter.
     * @param {GenreFindUniqueArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GenreFindUniqueArgs>(args: SelectSubset<T, GenreFindUniqueArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Genre that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GenreFindUniqueOrThrowArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GenreFindUniqueOrThrowArgs>(args: SelectSubset<T, GenreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Genre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindFirstArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GenreFindFirstArgs>(args?: SelectSubset<T, GenreFindFirstArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Genre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindFirstOrThrowArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GenreFindFirstOrThrowArgs>(args?: SelectSubset<T, GenreFindFirstOrThrowArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Genres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Genres
     * const genres = await prisma.genre.findMany()
     * 
     * // Get first 10 Genres
     * const genres = await prisma.genre.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const genreWithIdOnly = await prisma.genre.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GenreFindManyArgs>(args?: SelectSubset<T, GenreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Genre.
     * @param {GenreCreateArgs} args - Arguments to create a Genre.
     * @example
     * // Create one Genre
     * const Genre = await prisma.genre.create({
     *   data: {
     *     // ... data to create a Genre
     *   }
     * })
     * 
     */
    create<T extends GenreCreateArgs>(args: SelectSubset<T, GenreCreateArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Genres.
     * @param {GenreCreateManyArgs} args - Arguments to create many Genres.
     * @example
     * // Create many Genres
     * const genre = await prisma.genre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GenreCreateManyArgs>(args?: SelectSubset<T, GenreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Genres and returns the data saved in the database.
     * @param {GenreCreateManyAndReturnArgs} args - Arguments to create many Genres.
     * @example
     * // Create many Genres
     * const genre = await prisma.genre.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Genres and only return the `id`
     * const genreWithIdOnly = await prisma.genre.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GenreCreateManyAndReturnArgs>(args?: SelectSubset<T, GenreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Genre.
     * @param {GenreDeleteArgs} args - Arguments to delete one Genre.
     * @example
     * // Delete one Genre
     * const Genre = await prisma.genre.delete({
     *   where: {
     *     // ... filter to delete one Genre
     *   }
     * })
     * 
     */
    delete<T extends GenreDeleteArgs>(args: SelectSubset<T, GenreDeleteArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Genre.
     * @param {GenreUpdateArgs} args - Arguments to update one Genre.
     * @example
     * // Update one Genre
     * const genre = await prisma.genre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GenreUpdateArgs>(args: SelectSubset<T, GenreUpdateArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Genres.
     * @param {GenreDeleteManyArgs} args - Arguments to filter Genres to delete.
     * @example
     * // Delete a few Genres
     * const { count } = await prisma.genre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GenreDeleteManyArgs>(args?: SelectSubset<T, GenreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Genres
     * const genre = await prisma.genre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GenreUpdateManyArgs>(args: SelectSubset<T, GenreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genres and returns the data updated in the database.
     * @param {GenreUpdateManyAndReturnArgs} args - Arguments to update many Genres.
     * @example
     * // Update many Genres
     * const genre = await prisma.genre.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Genres and only return the `id`
     * const genreWithIdOnly = await prisma.genre.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GenreUpdateManyAndReturnArgs>(args: SelectSubset<T, GenreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Genre.
     * @param {GenreUpsertArgs} args - Arguments to update or create a Genre.
     * @example
     * // Update or create a Genre
     * const genre = await prisma.genre.upsert({
     *   create: {
     *     // ... data to create a Genre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Genre we want to update
     *   }
     * })
     */
    upsert<T extends GenreUpsertArgs>(args: SelectSubset<T, GenreUpsertArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreCountArgs} args - Arguments to filter Genres to count.
     * @example
     * // Count the number of Genres
     * const count = await prisma.genre.count({
     *   where: {
     *     // ... the filter for the Genres we want to count
     *   }
     * })
    **/
    count<T extends GenreCountArgs>(
      args?: Subset<T, GenreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Genre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenreAggregateArgs>(args: Subset<T, GenreAggregateArgs>): Prisma.PrismaPromise<GetGenreAggregateType<T>>

    /**
     * Group by Genre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GenreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GenreGroupByArgs['orderBy'] }
        : { orderBy?: GenreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GenreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Genre model
   */
  readonly fields: GenreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Genre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GenreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    songs<T extends Genre$songsArgs<ExtArgs> = {}>(args?: Subset<T, Genre$songsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongGenrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    albums<T extends Genre$albumsArgs<ExtArgs> = {}>(args?: Subset<T, Genre$albumsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlbumGenrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    artists<T extends Genre$artistsArgs<ExtArgs> = {}>(args?: Subset<T, Genre$artistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtistGenrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Genre model
   */
  interface GenreFieldRefs {
    readonly id: FieldRef<"Genre", 'String'>
    readonly name: FieldRef<"Genre", 'String'>
    readonly slug: FieldRef<"Genre", 'String'>
    readonly description: FieldRef<"Genre", 'String'>
    readonly color: FieldRef<"Genre", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Genre findUnique
   */
  export type GenreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre findUniqueOrThrow
   */
  export type GenreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre findFirst
   */
  export type GenreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genres.
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genres.
     */
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Genre findFirstOrThrow
   */
  export type GenreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genres.
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genres.
     */
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Genre findMany
   */
  export type GenreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genres to fetch.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Genres.
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Genre create
   */
  export type GenreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * The data needed to create a Genre.
     */
    data: XOR<GenreCreateInput, GenreUncheckedCreateInput>
  }

  /**
   * Genre createMany
   */
  export type GenreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Genres.
     */
    data: GenreCreateManyInput | GenreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Genre createManyAndReturn
   */
  export type GenreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * The data used to create many Genres.
     */
    data: GenreCreateManyInput | GenreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Genre update
   */
  export type GenreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * The data needed to update a Genre.
     */
    data: XOR<GenreUpdateInput, GenreUncheckedUpdateInput>
    /**
     * Choose, which Genre to update.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre updateMany
   */
  export type GenreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Genres.
     */
    data: XOR<GenreUpdateManyMutationInput, GenreUncheckedUpdateManyInput>
    /**
     * Filter which Genres to update
     */
    where?: GenreWhereInput
    /**
     * Limit how many Genres to update.
     */
    limit?: number
  }

  /**
   * Genre updateManyAndReturn
   */
  export type GenreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * The data used to update Genres.
     */
    data: XOR<GenreUpdateManyMutationInput, GenreUncheckedUpdateManyInput>
    /**
     * Filter which Genres to update
     */
    where?: GenreWhereInput
    /**
     * Limit how many Genres to update.
     */
    limit?: number
  }

  /**
   * Genre upsert
   */
  export type GenreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * The filter to search for the Genre to update in case it exists.
     */
    where: GenreWhereUniqueInput
    /**
     * In case the Genre found by the `where` argument doesn't exist, create a new Genre with this data.
     */
    create: XOR<GenreCreateInput, GenreUncheckedCreateInput>
    /**
     * In case the Genre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GenreUpdateInput, GenreUncheckedUpdateInput>
  }

  /**
   * Genre delete
   */
  export type GenreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter which Genre to delete.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre deleteMany
   */
  export type GenreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genres to delete
     */
    where?: GenreWhereInput
    /**
     * Limit how many Genres to delete.
     */
    limit?: number
  }

  /**
   * Genre.songs
   */
  export type Genre$songsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreInclude<ExtArgs> | null
    where?: SongGenreWhereInput
    orderBy?: SongGenreOrderByWithRelationInput | SongGenreOrderByWithRelationInput[]
    cursor?: SongGenreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SongGenreScalarFieldEnum | SongGenreScalarFieldEnum[]
  }

  /**
   * Genre.albums
   */
  export type Genre$albumsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumGenre
     */
    select?: AlbumGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlbumGenre
     */
    omit?: AlbumGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumGenreInclude<ExtArgs> | null
    where?: AlbumGenreWhereInput
    orderBy?: AlbumGenreOrderByWithRelationInput | AlbumGenreOrderByWithRelationInput[]
    cursor?: AlbumGenreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlbumGenreScalarFieldEnum | AlbumGenreScalarFieldEnum[]
  }

  /**
   * Genre.artists
   */
  export type Genre$artistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreInclude<ExtArgs> | null
    where?: ArtistGenreWhereInput
    orderBy?: ArtistGenreOrderByWithRelationInput | ArtistGenreOrderByWithRelationInput[]
    cursor?: ArtistGenreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtistGenreScalarFieldEnum | ArtistGenreScalarFieldEnum[]
  }

  /**
   * Genre without action
   */
  export type GenreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
  }


  /**
   * Model SongArtist
   */

  export type AggregateSongArtist = {
    _count: SongArtistCountAggregateOutputType | null
    _avg: SongArtistAvgAggregateOutputType | null
    _sum: SongArtistSumAggregateOutputType | null
    _min: SongArtistMinAggregateOutputType | null
    _max: SongArtistMaxAggregateOutputType | null
  }

  export type SongArtistAvgAggregateOutputType = {
    order: number | null
  }

  export type SongArtistSumAggregateOutputType = {
    order: number | null
  }

  export type SongArtistMinAggregateOutputType = {
    id: string | null
    songId: string | null
    artistId: string | null
    role: $Enums.ArtistRole | null
    order: number | null
  }

  export type SongArtistMaxAggregateOutputType = {
    id: string | null
    songId: string | null
    artistId: string | null
    role: $Enums.ArtistRole | null
    order: number | null
  }

  export type SongArtistCountAggregateOutputType = {
    id: number
    songId: number
    artistId: number
    role: number
    order: number
    _all: number
  }


  export type SongArtistAvgAggregateInputType = {
    order?: true
  }

  export type SongArtistSumAggregateInputType = {
    order?: true
  }

  export type SongArtistMinAggregateInputType = {
    id?: true
    songId?: true
    artistId?: true
    role?: true
    order?: true
  }

  export type SongArtistMaxAggregateInputType = {
    id?: true
    songId?: true
    artistId?: true
    role?: true
    order?: true
  }

  export type SongArtistCountAggregateInputType = {
    id?: true
    songId?: true
    artistId?: true
    role?: true
    order?: true
    _all?: true
  }

  export type SongArtistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SongArtist to aggregate.
     */
    where?: SongArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SongArtists to fetch.
     */
    orderBy?: SongArtistOrderByWithRelationInput | SongArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SongArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SongArtists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SongArtists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SongArtists
    **/
    _count?: true | SongArtistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SongArtistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SongArtistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SongArtistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SongArtistMaxAggregateInputType
  }

  export type GetSongArtistAggregateType<T extends SongArtistAggregateArgs> = {
        [P in keyof T & keyof AggregateSongArtist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSongArtist[P]>
      : GetScalarType<T[P], AggregateSongArtist[P]>
  }




  export type SongArtistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SongArtistWhereInput
    orderBy?: SongArtistOrderByWithAggregationInput | SongArtistOrderByWithAggregationInput[]
    by: SongArtistScalarFieldEnum[] | SongArtistScalarFieldEnum
    having?: SongArtistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SongArtistCountAggregateInputType | true
    _avg?: SongArtistAvgAggregateInputType
    _sum?: SongArtistSumAggregateInputType
    _min?: SongArtistMinAggregateInputType
    _max?: SongArtistMaxAggregateInputType
  }

  export type SongArtistGroupByOutputType = {
    id: string
    songId: string
    artistId: string
    role: $Enums.ArtistRole
    order: number
    _count: SongArtistCountAggregateOutputType | null
    _avg: SongArtistAvgAggregateOutputType | null
    _sum: SongArtistSumAggregateOutputType | null
    _min: SongArtistMinAggregateOutputType | null
    _max: SongArtistMaxAggregateOutputType | null
  }

  type GetSongArtistGroupByPayload<T extends SongArtistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SongArtistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SongArtistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SongArtistGroupByOutputType[P]>
            : GetScalarType<T[P], SongArtistGroupByOutputType[P]>
        }
      >
    >


  export type SongArtistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    songId?: boolean
    artistId?: boolean
    role?: boolean
    order?: boolean
    song?: boolean | SongDefaultArgs<ExtArgs>
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["songArtist"]>

  export type SongArtistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    songId?: boolean
    artistId?: boolean
    role?: boolean
    order?: boolean
    song?: boolean | SongDefaultArgs<ExtArgs>
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["songArtist"]>

  export type SongArtistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    songId?: boolean
    artistId?: boolean
    role?: boolean
    order?: boolean
    song?: boolean | SongDefaultArgs<ExtArgs>
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["songArtist"]>

  export type SongArtistSelectScalar = {
    id?: boolean
    songId?: boolean
    artistId?: boolean
    role?: boolean
    order?: boolean
  }

  export type SongArtistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "songId" | "artistId" | "role" | "order", ExtArgs["result"]["songArtist"]>
  export type SongArtistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    song?: boolean | SongDefaultArgs<ExtArgs>
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
  }
  export type SongArtistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    song?: boolean | SongDefaultArgs<ExtArgs>
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
  }
  export type SongArtistIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    song?: boolean | SongDefaultArgs<ExtArgs>
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
  }

  export type $SongArtistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SongArtist"
    objects: {
      song: Prisma.$SongPayload<ExtArgs>
      artist: Prisma.$ArtistPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      songId: string
      artistId: string
      role: $Enums.ArtistRole
      order: number
    }, ExtArgs["result"]["songArtist"]>
    composites: {}
  }

  type SongArtistGetPayload<S extends boolean | null | undefined | SongArtistDefaultArgs> = $Result.GetResult<Prisma.$SongArtistPayload, S>

  type SongArtistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SongArtistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SongArtistCountAggregateInputType | true
    }

  export interface SongArtistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SongArtist'], meta: { name: 'SongArtist' } }
    /**
     * Find zero or one SongArtist that matches the filter.
     * @param {SongArtistFindUniqueArgs} args - Arguments to find a SongArtist
     * @example
     * // Get one SongArtist
     * const songArtist = await prisma.songArtist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SongArtistFindUniqueArgs>(args: SelectSubset<T, SongArtistFindUniqueArgs<ExtArgs>>): Prisma__SongArtistClient<$Result.GetResult<Prisma.$SongArtistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SongArtist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SongArtistFindUniqueOrThrowArgs} args - Arguments to find a SongArtist
     * @example
     * // Get one SongArtist
     * const songArtist = await prisma.songArtist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SongArtistFindUniqueOrThrowArgs>(args: SelectSubset<T, SongArtistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SongArtistClient<$Result.GetResult<Prisma.$SongArtistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SongArtist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongArtistFindFirstArgs} args - Arguments to find a SongArtist
     * @example
     * // Get one SongArtist
     * const songArtist = await prisma.songArtist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SongArtistFindFirstArgs>(args?: SelectSubset<T, SongArtistFindFirstArgs<ExtArgs>>): Prisma__SongArtistClient<$Result.GetResult<Prisma.$SongArtistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SongArtist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongArtistFindFirstOrThrowArgs} args - Arguments to find a SongArtist
     * @example
     * // Get one SongArtist
     * const songArtist = await prisma.songArtist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SongArtistFindFirstOrThrowArgs>(args?: SelectSubset<T, SongArtistFindFirstOrThrowArgs<ExtArgs>>): Prisma__SongArtistClient<$Result.GetResult<Prisma.$SongArtistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SongArtists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongArtistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SongArtists
     * const songArtists = await prisma.songArtist.findMany()
     * 
     * // Get first 10 SongArtists
     * const songArtists = await prisma.songArtist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const songArtistWithIdOnly = await prisma.songArtist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SongArtistFindManyArgs>(args?: SelectSubset<T, SongArtistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongArtistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SongArtist.
     * @param {SongArtistCreateArgs} args - Arguments to create a SongArtist.
     * @example
     * // Create one SongArtist
     * const SongArtist = await prisma.songArtist.create({
     *   data: {
     *     // ... data to create a SongArtist
     *   }
     * })
     * 
     */
    create<T extends SongArtistCreateArgs>(args: SelectSubset<T, SongArtistCreateArgs<ExtArgs>>): Prisma__SongArtistClient<$Result.GetResult<Prisma.$SongArtistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SongArtists.
     * @param {SongArtistCreateManyArgs} args - Arguments to create many SongArtists.
     * @example
     * // Create many SongArtists
     * const songArtist = await prisma.songArtist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SongArtistCreateManyArgs>(args?: SelectSubset<T, SongArtistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SongArtists and returns the data saved in the database.
     * @param {SongArtistCreateManyAndReturnArgs} args - Arguments to create many SongArtists.
     * @example
     * // Create many SongArtists
     * const songArtist = await prisma.songArtist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SongArtists and only return the `id`
     * const songArtistWithIdOnly = await prisma.songArtist.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SongArtistCreateManyAndReturnArgs>(args?: SelectSubset<T, SongArtistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongArtistPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SongArtist.
     * @param {SongArtistDeleteArgs} args - Arguments to delete one SongArtist.
     * @example
     * // Delete one SongArtist
     * const SongArtist = await prisma.songArtist.delete({
     *   where: {
     *     // ... filter to delete one SongArtist
     *   }
     * })
     * 
     */
    delete<T extends SongArtistDeleteArgs>(args: SelectSubset<T, SongArtistDeleteArgs<ExtArgs>>): Prisma__SongArtistClient<$Result.GetResult<Prisma.$SongArtistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SongArtist.
     * @param {SongArtistUpdateArgs} args - Arguments to update one SongArtist.
     * @example
     * // Update one SongArtist
     * const songArtist = await prisma.songArtist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SongArtistUpdateArgs>(args: SelectSubset<T, SongArtistUpdateArgs<ExtArgs>>): Prisma__SongArtistClient<$Result.GetResult<Prisma.$SongArtistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SongArtists.
     * @param {SongArtistDeleteManyArgs} args - Arguments to filter SongArtists to delete.
     * @example
     * // Delete a few SongArtists
     * const { count } = await prisma.songArtist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SongArtistDeleteManyArgs>(args?: SelectSubset<T, SongArtistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SongArtists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongArtistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SongArtists
     * const songArtist = await prisma.songArtist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SongArtistUpdateManyArgs>(args: SelectSubset<T, SongArtistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SongArtists and returns the data updated in the database.
     * @param {SongArtistUpdateManyAndReturnArgs} args - Arguments to update many SongArtists.
     * @example
     * // Update many SongArtists
     * const songArtist = await prisma.songArtist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SongArtists and only return the `id`
     * const songArtistWithIdOnly = await prisma.songArtist.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SongArtistUpdateManyAndReturnArgs>(args: SelectSubset<T, SongArtistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongArtistPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SongArtist.
     * @param {SongArtistUpsertArgs} args - Arguments to update or create a SongArtist.
     * @example
     * // Update or create a SongArtist
     * const songArtist = await prisma.songArtist.upsert({
     *   create: {
     *     // ... data to create a SongArtist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SongArtist we want to update
     *   }
     * })
     */
    upsert<T extends SongArtistUpsertArgs>(args: SelectSubset<T, SongArtistUpsertArgs<ExtArgs>>): Prisma__SongArtistClient<$Result.GetResult<Prisma.$SongArtistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SongArtists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongArtistCountArgs} args - Arguments to filter SongArtists to count.
     * @example
     * // Count the number of SongArtists
     * const count = await prisma.songArtist.count({
     *   where: {
     *     // ... the filter for the SongArtists we want to count
     *   }
     * })
    **/
    count<T extends SongArtistCountArgs>(
      args?: Subset<T, SongArtistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SongArtistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SongArtist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongArtistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SongArtistAggregateArgs>(args: Subset<T, SongArtistAggregateArgs>): Prisma.PrismaPromise<GetSongArtistAggregateType<T>>

    /**
     * Group by SongArtist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongArtistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SongArtistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SongArtistGroupByArgs['orderBy'] }
        : { orderBy?: SongArtistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SongArtistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSongArtistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SongArtist model
   */
  readonly fields: SongArtistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SongArtist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SongArtistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    song<T extends SongDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SongDefaultArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    artist<T extends ArtistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArtistDefaultArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SongArtist model
   */
  interface SongArtistFieldRefs {
    readonly id: FieldRef<"SongArtist", 'String'>
    readonly songId: FieldRef<"SongArtist", 'String'>
    readonly artistId: FieldRef<"SongArtist", 'String'>
    readonly role: FieldRef<"SongArtist", 'ArtistRole'>
    readonly order: FieldRef<"SongArtist", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SongArtist findUnique
   */
  export type SongArtistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistInclude<ExtArgs> | null
    /**
     * Filter, which SongArtist to fetch.
     */
    where: SongArtistWhereUniqueInput
  }

  /**
   * SongArtist findUniqueOrThrow
   */
  export type SongArtistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistInclude<ExtArgs> | null
    /**
     * Filter, which SongArtist to fetch.
     */
    where: SongArtistWhereUniqueInput
  }

  /**
   * SongArtist findFirst
   */
  export type SongArtistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistInclude<ExtArgs> | null
    /**
     * Filter, which SongArtist to fetch.
     */
    where?: SongArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SongArtists to fetch.
     */
    orderBy?: SongArtistOrderByWithRelationInput | SongArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SongArtists.
     */
    cursor?: SongArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SongArtists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SongArtists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SongArtists.
     */
    distinct?: SongArtistScalarFieldEnum | SongArtistScalarFieldEnum[]
  }

  /**
   * SongArtist findFirstOrThrow
   */
  export type SongArtistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistInclude<ExtArgs> | null
    /**
     * Filter, which SongArtist to fetch.
     */
    where?: SongArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SongArtists to fetch.
     */
    orderBy?: SongArtistOrderByWithRelationInput | SongArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SongArtists.
     */
    cursor?: SongArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SongArtists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SongArtists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SongArtists.
     */
    distinct?: SongArtistScalarFieldEnum | SongArtistScalarFieldEnum[]
  }

  /**
   * SongArtist findMany
   */
  export type SongArtistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistInclude<ExtArgs> | null
    /**
     * Filter, which SongArtists to fetch.
     */
    where?: SongArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SongArtists to fetch.
     */
    orderBy?: SongArtistOrderByWithRelationInput | SongArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SongArtists.
     */
    cursor?: SongArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SongArtists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SongArtists.
     */
    skip?: number
    distinct?: SongArtistScalarFieldEnum | SongArtistScalarFieldEnum[]
  }

  /**
   * SongArtist create
   */
  export type SongArtistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistInclude<ExtArgs> | null
    /**
     * The data needed to create a SongArtist.
     */
    data: XOR<SongArtistCreateInput, SongArtistUncheckedCreateInput>
  }

  /**
   * SongArtist createMany
   */
  export type SongArtistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SongArtists.
     */
    data: SongArtistCreateManyInput | SongArtistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SongArtist createManyAndReturn
   */
  export type SongArtistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * The data used to create many SongArtists.
     */
    data: SongArtistCreateManyInput | SongArtistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SongArtist update
   */
  export type SongArtistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistInclude<ExtArgs> | null
    /**
     * The data needed to update a SongArtist.
     */
    data: XOR<SongArtistUpdateInput, SongArtistUncheckedUpdateInput>
    /**
     * Choose, which SongArtist to update.
     */
    where: SongArtistWhereUniqueInput
  }

  /**
   * SongArtist updateMany
   */
  export type SongArtistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SongArtists.
     */
    data: XOR<SongArtistUpdateManyMutationInput, SongArtistUncheckedUpdateManyInput>
    /**
     * Filter which SongArtists to update
     */
    where?: SongArtistWhereInput
    /**
     * Limit how many SongArtists to update.
     */
    limit?: number
  }

  /**
   * SongArtist updateManyAndReturn
   */
  export type SongArtistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * The data used to update SongArtists.
     */
    data: XOR<SongArtistUpdateManyMutationInput, SongArtistUncheckedUpdateManyInput>
    /**
     * Filter which SongArtists to update
     */
    where?: SongArtistWhereInput
    /**
     * Limit how many SongArtists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SongArtist upsert
   */
  export type SongArtistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistInclude<ExtArgs> | null
    /**
     * The filter to search for the SongArtist to update in case it exists.
     */
    where: SongArtistWhereUniqueInput
    /**
     * In case the SongArtist found by the `where` argument doesn't exist, create a new SongArtist with this data.
     */
    create: XOR<SongArtistCreateInput, SongArtistUncheckedCreateInput>
    /**
     * In case the SongArtist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SongArtistUpdateInput, SongArtistUncheckedUpdateInput>
  }

  /**
   * SongArtist delete
   */
  export type SongArtistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistInclude<ExtArgs> | null
    /**
     * Filter which SongArtist to delete.
     */
    where: SongArtistWhereUniqueInput
  }

  /**
   * SongArtist deleteMany
   */
  export type SongArtistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SongArtists to delete
     */
    where?: SongArtistWhereInput
    /**
     * Limit how many SongArtists to delete.
     */
    limit?: number
  }

  /**
   * SongArtist without action
   */
  export type SongArtistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistInclude<ExtArgs> | null
  }


  /**
   * Model SongCredit
   */

  export type AggregateSongCredit = {
    _count: SongCreditCountAggregateOutputType | null
    _avg: SongCreditAvgAggregateOutputType | null
    _sum: SongCreditSumAggregateOutputType | null
    _min: SongCreditMinAggregateOutputType | null
    _max: SongCreditMaxAggregateOutputType | null
  }

  export type SongCreditAvgAggregateOutputType = {
    order: number | null
  }

  export type SongCreditSumAggregateOutputType = {
    order: number | null
  }

  export type SongCreditMinAggregateOutputType = {
    id: string | null
    songId: string | null
    artistId: string | null
    name: string | null
    role: $Enums.CreditRole | null
    details: string | null
    order: number | null
  }

  export type SongCreditMaxAggregateOutputType = {
    id: string | null
    songId: string | null
    artistId: string | null
    name: string | null
    role: $Enums.CreditRole | null
    details: string | null
    order: number | null
  }

  export type SongCreditCountAggregateOutputType = {
    id: number
    songId: number
    artistId: number
    name: number
    role: number
    details: number
    order: number
    _all: number
  }


  export type SongCreditAvgAggregateInputType = {
    order?: true
  }

  export type SongCreditSumAggregateInputType = {
    order?: true
  }

  export type SongCreditMinAggregateInputType = {
    id?: true
    songId?: true
    artistId?: true
    name?: true
    role?: true
    details?: true
    order?: true
  }

  export type SongCreditMaxAggregateInputType = {
    id?: true
    songId?: true
    artistId?: true
    name?: true
    role?: true
    details?: true
    order?: true
  }

  export type SongCreditCountAggregateInputType = {
    id?: true
    songId?: true
    artistId?: true
    name?: true
    role?: true
    details?: true
    order?: true
    _all?: true
  }

  export type SongCreditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SongCredit to aggregate.
     */
    where?: SongCreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SongCredits to fetch.
     */
    orderBy?: SongCreditOrderByWithRelationInput | SongCreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SongCreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SongCredits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SongCredits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SongCredits
    **/
    _count?: true | SongCreditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SongCreditAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SongCreditSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SongCreditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SongCreditMaxAggregateInputType
  }

  export type GetSongCreditAggregateType<T extends SongCreditAggregateArgs> = {
        [P in keyof T & keyof AggregateSongCredit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSongCredit[P]>
      : GetScalarType<T[P], AggregateSongCredit[P]>
  }




  export type SongCreditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SongCreditWhereInput
    orderBy?: SongCreditOrderByWithAggregationInput | SongCreditOrderByWithAggregationInput[]
    by: SongCreditScalarFieldEnum[] | SongCreditScalarFieldEnum
    having?: SongCreditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SongCreditCountAggregateInputType | true
    _avg?: SongCreditAvgAggregateInputType
    _sum?: SongCreditSumAggregateInputType
    _min?: SongCreditMinAggregateInputType
    _max?: SongCreditMaxAggregateInputType
  }

  export type SongCreditGroupByOutputType = {
    id: string
    songId: string
    artistId: string | null
    name: string
    role: $Enums.CreditRole
    details: string | null
    order: number
    _count: SongCreditCountAggregateOutputType | null
    _avg: SongCreditAvgAggregateOutputType | null
    _sum: SongCreditSumAggregateOutputType | null
    _min: SongCreditMinAggregateOutputType | null
    _max: SongCreditMaxAggregateOutputType | null
  }

  type GetSongCreditGroupByPayload<T extends SongCreditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SongCreditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SongCreditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SongCreditGroupByOutputType[P]>
            : GetScalarType<T[P], SongCreditGroupByOutputType[P]>
        }
      >
    >


  export type SongCreditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    songId?: boolean
    artistId?: boolean
    name?: boolean
    role?: boolean
    details?: boolean
    order?: boolean
    song?: boolean | SongDefaultArgs<ExtArgs>
    artist?: boolean | SongCredit$artistArgs<ExtArgs>
  }, ExtArgs["result"]["songCredit"]>

  export type SongCreditSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    songId?: boolean
    artistId?: boolean
    name?: boolean
    role?: boolean
    details?: boolean
    order?: boolean
    song?: boolean | SongDefaultArgs<ExtArgs>
    artist?: boolean | SongCredit$artistArgs<ExtArgs>
  }, ExtArgs["result"]["songCredit"]>

  export type SongCreditSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    songId?: boolean
    artistId?: boolean
    name?: boolean
    role?: boolean
    details?: boolean
    order?: boolean
    song?: boolean | SongDefaultArgs<ExtArgs>
    artist?: boolean | SongCredit$artistArgs<ExtArgs>
  }, ExtArgs["result"]["songCredit"]>

  export type SongCreditSelectScalar = {
    id?: boolean
    songId?: boolean
    artistId?: boolean
    name?: boolean
    role?: boolean
    details?: boolean
    order?: boolean
  }

  export type SongCreditOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "songId" | "artistId" | "name" | "role" | "details" | "order", ExtArgs["result"]["songCredit"]>
  export type SongCreditInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    song?: boolean | SongDefaultArgs<ExtArgs>
    artist?: boolean | SongCredit$artistArgs<ExtArgs>
  }
  export type SongCreditIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    song?: boolean | SongDefaultArgs<ExtArgs>
    artist?: boolean | SongCredit$artistArgs<ExtArgs>
  }
  export type SongCreditIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    song?: boolean | SongDefaultArgs<ExtArgs>
    artist?: boolean | SongCredit$artistArgs<ExtArgs>
  }

  export type $SongCreditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SongCredit"
    objects: {
      song: Prisma.$SongPayload<ExtArgs>
      artist: Prisma.$ArtistPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      songId: string
      artistId: string | null
      name: string
      role: $Enums.CreditRole
      details: string | null
      order: number
    }, ExtArgs["result"]["songCredit"]>
    composites: {}
  }

  type SongCreditGetPayload<S extends boolean | null | undefined | SongCreditDefaultArgs> = $Result.GetResult<Prisma.$SongCreditPayload, S>

  type SongCreditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SongCreditFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SongCreditCountAggregateInputType | true
    }

  export interface SongCreditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SongCredit'], meta: { name: 'SongCredit' } }
    /**
     * Find zero or one SongCredit that matches the filter.
     * @param {SongCreditFindUniqueArgs} args - Arguments to find a SongCredit
     * @example
     * // Get one SongCredit
     * const songCredit = await prisma.songCredit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SongCreditFindUniqueArgs>(args: SelectSubset<T, SongCreditFindUniqueArgs<ExtArgs>>): Prisma__SongCreditClient<$Result.GetResult<Prisma.$SongCreditPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SongCredit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SongCreditFindUniqueOrThrowArgs} args - Arguments to find a SongCredit
     * @example
     * // Get one SongCredit
     * const songCredit = await prisma.songCredit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SongCreditFindUniqueOrThrowArgs>(args: SelectSubset<T, SongCreditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SongCreditClient<$Result.GetResult<Prisma.$SongCreditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SongCredit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongCreditFindFirstArgs} args - Arguments to find a SongCredit
     * @example
     * // Get one SongCredit
     * const songCredit = await prisma.songCredit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SongCreditFindFirstArgs>(args?: SelectSubset<T, SongCreditFindFirstArgs<ExtArgs>>): Prisma__SongCreditClient<$Result.GetResult<Prisma.$SongCreditPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SongCredit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongCreditFindFirstOrThrowArgs} args - Arguments to find a SongCredit
     * @example
     * // Get one SongCredit
     * const songCredit = await prisma.songCredit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SongCreditFindFirstOrThrowArgs>(args?: SelectSubset<T, SongCreditFindFirstOrThrowArgs<ExtArgs>>): Prisma__SongCreditClient<$Result.GetResult<Prisma.$SongCreditPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SongCredits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongCreditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SongCredits
     * const songCredits = await prisma.songCredit.findMany()
     * 
     * // Get first 10 SongCredits
     * const songCredits = await prisma.songCredit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const songCreditWithIdOnly = await prisma.songCredit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SongCreditFindManyArgs>(args?: SelectSubset<T, SongCreditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongCreditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SongCredit.
     * @param {SongCreditCreateArgs} args - Arguments to create a SongCredit.
     * @example
     * // Create one SongCredit
     * const SongCredit = await prisma.songCredit.create({
     *   data: {
     *     // ... data to create a SongCredit
     *   }
     * })
     * 
     */
    create<T extends SongCreditCreateArgs>(args: SelectSubset<T, SongCreditCreateArgs<ExtArgs>>): Prisma__SongCreditClient<$Result.GetResult<Prisma.$SongCreditPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SongCredits.
     * @param {SongCreditCreateManyArgs} args - Arguments to create many SongCredits.
     * @example
     * // Create many SongCredits
     * const songCredit = await prisma.songCredit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SongCreditCreateManyArgs>(args?: SelectSubset<T, SongCreditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SongCredits and returns the data saved in the database.
     * @param {SongCreditCreateManyAndReturnArgs} args - Arguments to create many SongCredits.
     * @example
     * // Create many SongCredits
     * const songCredit = await prisma.songCredit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SongCredits and only return the `id`
     * const songCreditWithIdOnly = await prisma.songCredit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SongCreditCreateManyAndReturnArgs>(args?: SelectSubset<T, SongCreditCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongCreditPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SongCredit.
     * @param {SongCreditDeleteArgs} args - Arguments to delete one SongCredit.
     * @example
     * // Delete one SongCredit
     * const SongCredit = await prisma.songCredit.delete({
     *   where: {
     *     // ... filter to delete one SongCredit
     *   }
     * })
     * 
     */
    delete<T extends SongCreditDeleteArgs>(args: SelectSubset<T, SongCreditDeleteArgs<ExtArgs>>): Prisma__SongCreditClient<$Result.GetResult<Prisma.$SongCreditPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SongCredit.
     * @param {SongCreditUpdateArgs} args - Arguments to update one SongCredit.
     * @example
     * // Update one SongCredit
     * const songCredit = await prisma.songCredit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SongCreditUpdateArgs>(args: SelectSubset<T, SongCreditUpdateArgs<ExtArgs>>): Prisma__SongCreditClient<$Result.GetResult<Prisma.$SongCreditPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SongCredits.
     * @param {SongCreditDeleteManyArgs} args - Arguments to filter SongCredits to delete.
     * @example
     * // Delete a few SongCredits
     * const { count } = await prisma.songCredit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SongCreditDeleteManyArgs>(args?: SelectSubset<T, SongCreditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SongCredits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongCreditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SongCredits
     * const songCredit = await prisma.songCredit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SongCreditUpdateManyArgs>(args: SelectSubset<T, SongCreditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SongCredits and returns the data updated in the database.
     * @param {SongCreditUpdateManyAndReturnArgs} args - Arguments to update many SongCredits.
     * @example
     * // Update many SongCredits
     * const songCredit = await prisma.songCredit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SongCredits and only return the `id`
     * const songCreditWithIdOnly = await prisma.songCredit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SongCreditUpdateManyAndReturnArgs>(args: SelectSubset<T, SongCreditUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongCreditPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SongCredit.
     * @param {SongCreditUpsertArgs} args - Arguments to update or create a SongCredit.
     * @example
     * // Update or create a SongCredit
     * const songCredit = await prisma.songCredit.upsert({
     *   create: {
     *     // ... data to create a SongCredit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SongCredit we want to update
     *   }
     * })
     */
    upsert<T extends SongCreditUpsertArgs>(args: SelectSubset<T, SongCreditUpsertArgs<ExtArgs>>): Prisma__SongCreditClient<$Result.GetResult<Prisma.$SongCreditPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SongCredits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongCreditCountArgs} args - Arguments to filter SongCredits to count.
     * @example
     * // Count the number of SongCredits
     * const count = await prisma.songCredit.count({
     *   where: {
     *     // ... the filter for the SongCredits we want to count
     *   }
     * })
    **/
    count<T extends SongCreditCountArgs>(
      args?: Subset<T, SongCreditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SongCreditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SongCredit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongCreditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SongCreditAggregateArgs>(args: Subset<T, SongCreditAggregateArgs>): Prisma.PrismaPromise<GetSongCreditAggregateType<T>>

    /**
     * Group by SongCredit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongCreditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SongCreditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SongCreditGroupByArgs['orderBy'] }
        : { orderBy?: SongCreditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SongCreditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSongCreditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SongCredit model
   */
  readonly fields: SongCreditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SongCredit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SongCreditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    song<T extends SongDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SongDefaultArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    artist<T extends SongCredit$artistArgs<ExtArgs> = {}>(args?: Subset<T, SongCredit$artistArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SongCredit model
   */
  interface SongCreditFieldRefs {
    readonly id: FieldRef<"SongCredit", 'String'>
    readonly songId: FieldRef<"SongCredit", 'String'>
    readonly artistId: FieldRef<"SongCredit", 'String'>
    readonly name: FieldRef<"SongCredit", 'String'>
    readonly role: FieldRef<"SongCredit", 'CreditRole'>
    readonly details: FieldRef<"SongCredit", 'String'>
    readonly order: FieldRef<"SongCredit", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SongCredit findUnique
   */
  export type SongCreditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongCredit
     */
    select?: SongCreditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongCredit
     */
    omit?: SongCreditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongCreditInclude<ExtArgs> | null
    /**
     * Filter, which SongCredit to fetch.
     */
    where: SongCreditWhereUniqueInput
  }

  /**
   * SongCredit findUniqueOrThrow
   */
  export type SongCreditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongCredit
     */
    select?: SongCreditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongCredit
     */
    omit?: SongCreditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongCreditInclude<ExtArgs> | null
    /**
     * Filter, which SongCredit to fetch.
     */
    where: SongCreditWhereUniqueInput
  }

  /**
   * SongCredit findFirst
   */
  export type SongCreditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongCredit
     */
    select?: SongCreditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongCredit
     */
    omit?: SongCreditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongCreditInclude<ExtArgs> | null
    /**
     * Filter, which SongCredit to fetch.
     */
    where?: SongCreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SongCredits to fetch.
     */
    orderBy?: SongCreditOrderByWithRelationInput | SongCreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SongCredits.
     */
    cursor?: SongCreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SongCredits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SongCredits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SongCredits.
     */
    distinct?: SongCreditScalarFieldEnum | SongCreditScalarFieldEnum[]
  }

  /**
   * SongCredit findFirstOrThrow
   */
  export type SongCreditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongCredit
     */
    select?: SongCreditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongCredit
     */
    omit?: SongCreditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongCreditInclude<ExtArgs> | null
    /**
     * Filter, which SongCredit to fetch.
     */
    where?: SongCreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SongCredits to fetch.
     */
    orderBy?: SongCreditOrderByWithRelationInput | SongCreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SongCredits.
     */
    cursor?: SongCreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SongCredits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SongCredits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SongCredits.
     */
    distinct?: SongCreditScalarFieldEnum | SongCreditScalarFieldEnum[]
  }

  /**
   * SongCredit findMany
   */
  export type SongCreditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongCredit
     */
    select?: SongCreditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongCredit
     */
    omit?: SongCreditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongCreditInclude<ExtArgs> | null
    /**
     * Filter, which SongCredits to fetch.
     */
    where?: SongCreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SongCredits to fetch.
     */
    orderBy?: SongCreditOrderByWithRelationInput | SongCreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SongCredits.
     */
    cursor?: SongCreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SongCredits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SongCredits.
     */
    skip?: number
    distinct?: SongCreditScalarFieldEnum | SongCreditScalarFieldEnum[]
  }

  /**
   * SongCredit create
   */
  export type SongCreditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongCredit
     */
    select?: SongCreditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongCredit
     */
    omit?: SongCreditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongCreditInclude<ExtArgs> | null
    /**
     * The data needed to create a SongCredit.
     */
    data: XOR<SongCreditCreateInput, SongCreditUncheckedCreateInput>
  }

  /**
   * SongCredit createMany
   */
  export type SongCreditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SongCredits.
     */
    data: SongCreditCreateManyInput | SongCreditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SongCredit createManyAndReturn
   */
  export type SongCreditCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongCredit
     */
    select?: SongCreditSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SongCredit
     */
    omit?: SongCreditOmit<ExtArgs> | null
    /**
     * The data used to create many SongCredits.
     */
    data: SongCreditCreateManyInput | SongCreditCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongCreditIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SongCredit update
   */
  export type SongCreditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongCredit
     */
    select?: SongCreditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongCredit
     */
    omit?: SongCreditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongCreditInclude<ExtArgs> | null
    /**
     * The data needed to update a SongCredit.
     */
    data: XOR<SongCreditUpdateInput, SongCreditUncheckedUpdateInput>
    /**
     * Choose, which SongCredit to update.
     */
    where: SongCreditWhereUniqueInput
  }

  /**
   * SongCredit updateMany
   */
  export type SongCreditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SongCredits.
     */
    data: XOR<SongCreditUpdateManyMutationInput, SongCreditUncheckedUpdateManyInput>
    /**
     * Filter which SongCredits to update
     */
    where?: SongCreditWhereInput
    /**
     * Limit how many SongCredits to update.
     */
    limit?: number
  }

  /**
   * SongCredit updateManyAndReturn
   */
  export type SongCreditUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongCredit
     */
    select?: SongCreditSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SongCredit
     */
    omit?: SongCreditOmit<ExtArgs> | null
    /**
     * The data used to update SongCredits.
     */
    data: XOR<SongCreditUpdateManyMutationInput, SongCreditUncheckedUpdateManyInput>
    /**
     * Filter which SongCredits to update
     */
    where?: SongCreditWhereInput
    /**
     * Limit how many SongCredits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongCreditIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SongCredit upsert
   */
  export type SongCreditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongCredit
     */
    select?: SongCreditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongCredit
     */
    omit?: SongCreditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongCreditInclude<ExtArgs> | null
    /**
     * The filter to search for the SongCredit to update in case it exists.
     */
    where: SongCreditWhereUniqueInput
    /**
     * In case the SongCredit found by the `where` argument doesn't exist, create a new SongCredit with this data.
     */
    create: XOR<SongCreditCreateInput, SongCreditUncheckedCreateInput>
    /**
     * In case the SongCredit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SongCreditUpdateInput, SongCreditUncheckedUpdateInput>
  }

  /**
   * SongCredit delete
   */
  export type SongCreditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongCredit
     */
    select?: SongCreditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongCredit
     */
    omit?: SongCreditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongCreditInclude<ExtArgs> | null
    /**
     * Filter which SongCredit to delete.
     */
    where: SongCreditWhereUniqueInput
  }

  /**
   * SongCredit deleteMany
   */
  export type SongCreditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SongCredits to delete
     */
    where?: SongCreditWhereInput
    /**
     * Limit how many SongCredits to delete.
     */
    limit?: number
  }

  /**
   * SongCredit.artist
   */
  export type SongCredit$artistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    where?: ArtistWhereInput
  }

  /**
   * SongCredit without action
   */
  export type SongCreditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongCredit
     */
    select?: SongCreditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongCredit
     */
    omit?: SongCreditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongCreditInclude<ExtArgs> | null
  }


  /**
   * Model SongGenre
   */

  export type AggregateSongGenre = {
    _count: SongGenreCountAggregateOutputType | null
    _min: SongGenreMinAggregateOutputType | null
    _max: SongGenreMaxAggregateOutputType | null
  }

  export type SongGenreMinAggregateOutputType = {
    songId: string | null
    genreId: string | null
  }

  export type SongGenreMaxAggregateOutputType = {
    songId: string | null
    genreId: string | null
  }

  export type SongGenreCountAggregateOutputType = {
    songId: number
    genreId: number
    _all: number
  }


  export type SongGenreMinAggregateInputType = {
    songId?: true
    genreId?: true
  }

  export type SongGenreMaxAggregateInputType = {
    songId?: true
    genreId?: true
  }

  export type SongGenreCountAggregateInputType = {
    songId?: true
    genreId?: true
    _all?: true
  }

  export type SongGenreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SongGenre to aggregate.
     */
    where?: SongGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SongGenres to fetch.
     */
    orderBy?: SongGenreOrderByWithRelationInput | SongGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SongGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SongGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SongGenres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SongGenres
    **/
    _count?: true | SongGenreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SongGenreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SongGenreMaxAggregateInputType
  }

  export type GetSongGenreAggregateType<T extends SongGenreAggregateArgs> = {
        [P in keyof T & keyof AggregateSongGenre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSongGenre[P]>
      : GetScalarType<T[P], AggregateSongGenre[P]>
  }




  export type SongGenreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SongGenreWhereInput
    orderBy?: SongGenreOrderByWithAggregationInput | SongGenreOrderByWithAggregationInput[]
    by: SongGenreScalarFieldEnum[] | SongGenreScalarFieldEnum
    having?: SongGenreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SongGenreCountAggregateInputType | true
    _min?: SongGenreMinAggregateInputType
    _max?: SongGenreMaxAggregateInputType
  }

  export type SongGenreGroupByOutputType = {
    songId: string
    genreId: string
    _count: SongGenreCountAggregateOutputType | null
    _min: SongGenreMinAggregateOutputType | null
    _max: SongGenreMaxAggregateOutputType | null
  }

  type GetSongGenreGroupByPayload<T extends SongGenreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SongGenreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SongGenreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SongGenreGroupByOutputType[P]>
            : GetScalarType<T[P], SongGenreGroupByOutputType[P]>
        }
      >
    >


  export type SongGenreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    songId?: boolean
    genreId?: boolean
    song?: boolean | SongDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["songGenre"]>

  export type SongGenreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    songId?: boolean
    genreId?: boolean
    song?: boolean | SongDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["songGenre"]>

  export type SongGenreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    songId?: boolean
    genreId?: boolean
    song?: boolean | SongDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["songGenre"]>

  export type SongGenreSelectScalar = {
    songId?: boolean
    genreId?: boolean
  }

  export type SongGenreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"songId" | "genreId", ExtArgs["result"]["songGenre"]>
  export type SongGenreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    song?: boolean | SongDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }
  export type SongGenreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    song?: boolean | SongDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }
  export type SongGenreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    song?: boolean | SongDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }

  export type $SongGenrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SongGenre"
    objects: {
      song: Prisma.$SongPayload<ExtArgs>
      genre: Prisma.$GenrePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      songId: string
      genreId: string
    }, ExtArgs["result"]["songGenre"]>
    composites: {}
  }

  type SongGenreGetPayload<S extends boolean | null | undefined | SongGenreDefaultArgs> = $Result.GetResult<Prisma.$SongGenrePayload, S>

  type SongGenreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SongGenreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SongGenreCountAggregateInputType | true
    }

  export interface SongGenreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SongGenre'], meta: { name: 'SongGenre' } }
    /**
     * Find zero or one SongGenre that matches the filter.
     * @param {SongGenreFindUniqueArgs} args - Arguments to find a SongGenre
     * @example
     * // Get one SongGenre
     * const songGenre = await prisma.songGenre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SongGenreFindUniqueArgs>(args: SelectSubset<T, SongGenreFindUniqueArgs<ExtArgs>>): Prisma__SongGenreClient<$Result.GetResult<Prisma.$SongGenrePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SongGenre that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SongGenreFindUniqueOrThrowArgs} args - Arguments to find a SongGenre
     * @example
     * // Get one SongGenre
     * const songGenre = await prisma.songGenre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SongGenreFindUniqueOrThrowArgs>(args: SelectSubset<T, SongGenreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SongGenreClient<$Result.GetResult<Prisma.$SongGenrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SongGenre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongGenreFindFirstArgs} args - Arguments to find a SongGenre
     * @example
     * // Get one SongGenre
     * const songGenre = await prisma.songGenre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SongGenreFindFirstArgs>(args?: SelectSubset<T, SongGenreFindFirstArgs<ExtArgs>>): Prisma__SongGenreClient<$Result.GetResult<Prisma.$SongGenrePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SongGenre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongGenreFindFirstOrThrowArgs} args - Arguments to find a SongGenre
     * @example
     * // Get one SongGenre
     * const songGenre = await prisma.songGenre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SongGenreFindFirstOrThrowArgs>(args?: SelectSubset<T, SongGenreFindFirstOrThrowArgs<ExtArgs>>): Prisma__SongGenreClient<$Result.GetResult<Prisma.$SongGenrePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SongGenres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongGenreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SongGenres
     * const songGenres = await prisma.songGenre.findMany()
     * 
     * // Get first 10 SongGenres
     * const songGenres = await prisma.songGenre.findMany({ take: 10 })
     * 
     * // Only select the `songId`
     * const songGenreWithSongIdOnly = await prisma.songGenre.findMany({ select: { songId: true } })
     * 
     */
    findMany<T extends SongGenreFindManyArgs>(args?: SelectSubset<T, SongGenreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongGenrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SongGenre.
     * @param {SongGenreCreateArgs} args - Arguments to create a SongGenre.
     * @example
     * // Create one SongGenre
     * const SongGenre = await prisma.songGenre.create({
     *   data: {
     *     // ... data to create a SongGenre
     *   }
     * })
     * 
     */
    create<T extends SongGenreCreateArgs>(args: SelectSubset<T, SongGenreCreateArgs<ExtArgs>>): Prisma__SongGenreClient<$Result.GetResult<Prisma.$SongGenrePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SongGenres.
     * @param {SongGenreCreateManyArgs} args - Arguments to create many SongGenres.
     * @example
     * // Create many SongGenres
     * const songGenre = await prisma.songGenre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SongGenreCreateManyArgs>(args?: SelectSubset<T, SongGenreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SongGenres and returns the data saved in the database.
     * @param {SongGenreCreateManyAndReturnArgs} args - Arguments to create many SongGenres.
     * @example
     * // Create many SongGenres
     * const songGenre = await prisma.songGenre.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SongGenres and only return the `songId`
     * const songGenreWithSongIdOnly = await prisma.songGenre.createManyAndReturn({
     *   select: { songId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SongGenreCreateManyAndReturnArgs>(args?: SelectSubset<T, SongGenreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongGenrePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SongGenre.
     * @param {SongGenreDeleteArgs} args - Arguments to delete one SongGenre.
     * @example
     * // Delete one SongGenre
     * const SongGenre = await prisma.songGenre.delete({
     *   where: {
     *     // ... filter to delete one SongGenre
     *   }
     * })
     * 
     */
    delete<T extends SongGenreDeleteArgs>(args: SelectSubset<T, SongGenreDeleteArgs<ExtArgs>>): Prisma__SongGenreClient<$Result.GetResult<Prisma.$SongGenrePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SongGenre.
     * @param {SongGenreUpdateArgs} args - Arguments to update one SongGenre.
     * @example
     * // Update one SongGenre
     * const songGenre = await prisma.songGenre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SongGenreUpdateArgs>(args: SelectSubset<T, SongGenreUpdateArgs<ExtArgs>>): Prisma__SongGenreClient<$Result.GetResult<Prisma.$SongGenrePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SongGenres.
     * @param {SongGenreDeleteManyArgs} args - Arguments to filter SongGenres to delete.
     * @example
     * // Delete a few SongGenres
     * const { count } = await prisma.songGenre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SongGenreDeleteManyArgs>(args?: SelectSubset<T, SongGenreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SongGenres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongGenreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SongGenres
     * const songGenre = await prisma.songGenre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SongGenreUpdateManyArgs>(args: SelectSubset<T, SongGenreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SongGenres and returns the data updated in the database.
     * @param {SongGenreUpdateManyAndReturnArgs} args - Arguments to update many SongGenres.
     * @example
     * // Update many SongGenres
     * const songGenre = await prisma.songGenre.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SongGenres and only return the `songId`
     * const songGenreWithSongIdOnly = await prisma.songGenre.updateManyAndReturn({
     *   select: { songId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SongGenreUpdateManyAndReturnArgs>(args: SelectSubset<T, SongGenreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongGenrePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SongGenre.
     * @param {SongGenreUpsertArgs} args - Arguments to update or create a SongGenre.
     * @example
     * // Update or create a SongGenre
     * const songGenre = await prisma.songGenre.upsert({
     *   create: {
     *     // ... data to create a SongGenre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SongGenre we want to update
     *   }
     * })
     */
    upsert<T extends SongGenreUpsertArgs>(args: SelectSubset<T, SongGenreUpsertArgs<ExtArgs>>): Prisma__SongGenreClient<$Result.GetResult<Prisma.$SongGenrePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SongGenres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongGenreCountArgs} args - Arguments to filter SongGenres to count.
     * @example
     * // Count the number of SongGenres
     * const count = await prisma.songGenre.count({
     *   where: {
     *     // ... the filter for the SongGenres we want to count
     *   }
     * })
    **/
    count<T extends SongGenreCountArgs>(
      args?: Subset<T, SongGenreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SongGenreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SongGenre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongGenreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SongGenreAggregateArgs>(args: Subset<T, SongGenreAggregateArgs>): Prisma.PrismaPromise<GetSongGenreAggregateType<T>>

    /**
     * Group by SongGenre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongGenreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SongGenreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SongGenreGroupByArgs['orderBy'] }
        : { orderBy?: SongGenreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SongGenreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSongGenreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SongGenre model
   */
  readonly fields: SongGenreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SongGenre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SongGenreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    song<T extends SongDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SongDefaultArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    genre<T extends GenreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GenreDefaultArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SongGenre model
   */
  interface SongGenreFieldRefs {
    readonly songId: FieldRef<"SongGenre", 'String'>
    readonly genreId: FieldRef<"SongGenre", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SongGenre findUnique
   */
  export type SongGenreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreInclude<ExtArgs> | null
    /**
     * Filter, which SongGenre to fetch.
     */
    where: SongGenreWhereUniqueInput
  }

  /**
   * SongGenre findUniqueOrThrow
   */
  export type SongGenreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreInclude<ExtArgs> | null
    /**
     * Filter, which SongGenre to fetch.
     */
    where: SongGenreWhereUniqueInput
  }

  /**
   * SongGenre findFirst
   */
  export type SongGenreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreInclude<ExtArgs> | null
    /**
     * Filter, which SongGenre to fetch.
     */
    where?: SongGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SongGenres to fetch.
     */
    orderBy?: SongGenreOrderByWithRelationInput | SongGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SongGenres.
     */
    cursor?: SongGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SongGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SongGenres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SongGenres.
     */
    distinct?: SongGenreScalarFieldEnum | SongGenreScalarFieldEnum[]
  }

  /**
   * SongGenre findFirstOrThrow
   */
  export type SongGenreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreInclude<ExtArgs> | null
    /**
     * Filter, which SongGenre to fetch.
     */
    where?: SongGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SongGenres to fetch.
     */
    orderBy?: SongGenreOrderByWithRelationInput | SongGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SongGenres.
     */
    cursor?: SongGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SongGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SongGenres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SongGenres.
     */
    distinct?: SongGenreScalarFieldEnum | SongGenreScalarFieldEnum[]
  }

  /**
   * SongGenre findMany
   */
  export type SongGenreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreInclude<ExtArgs> | null
    /**
     * Filter, which SongGenres to fetch.
     */
    where?: SongGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SongGenres to fetch.
     */
    orderBy?: SongGenreOrderByWithRelationInput | SongGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SongGenres.
     */
    cursor?: SongGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SongGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SongGenres.
     */
    skip?: number
    distinct?: SongGenreScalarFieldEnum | SongGenreScalarFieldEnum[]
  }

  /**
   * SongGenre create
   */
  export type SongGenreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreInclude<ExtArgs> | null
    /**
     * The data needed to create a SongGenre.
     */
    data: XOR<SongGenreCreateInput, SongGenreUncheckedCreateInput>
  }

  /**
   * SongGenre createMany
   */
  export type SongGenreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SongGenres.
     */
    data: SongGenreCreateManyInput | SongGenreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SongGenre createManyAndReturn
   */
  export type SongGenreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * The data used to create many SongGenres.
     */
    data: SongGenreCreateManyInput | SongGenreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SongGenre update
   */
  export type SongGenreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreInclude<ExtArgs> | null
    /**
     * The data needed to update a SongGenre.
     */
    data: XOR<SongGenreUpdateInput, SongGenreUncheckedUpdateInput>
    /**
     * Choose, which SongGenre to update.
     */
    where: SongGenreWhereUniqueInput
  }

  /**
   * SongGenre updateMany
   */
  export type SongGenreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SongGenres.
     */
    data: XOR<SongGenreUpdateManyMutationInput, SongGenreUncheckedUpdateManyInput>
    /**
     * Filter which SongGenres to update
     */
    where?: SongGenreWhereInput
    /**
     * Limit how many SongGenres to update.
     */
    limit?: number
  }

  /**
   * SongGenre updateManyAndReturn
   */
  export type SongGenreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * The data used to update SongGenres.
     */
    data: XOR<SongGenreUpdateManyMutationInput, SongGenreUncheckedUpdateManyInput>
    /**
     * Filter which SongGenres to update
     */
    where?: SongGenreWhereInput
    /**
     * Limit how many SongGenres to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SongGenre upsert
   */
  export type SongGenreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreInclude<ExtArgs> | null
    /**
     * The filter to search for the SongGenre to update in case it exists.
     */
    where: SongGenreWhereUniqueInput
    /**
     * In case the SongGenre found by the `where` argument doesn't exist, create a new SongGenre with this data.
     */
    create: XOR<SongGenreCreateInput, SongGenreUncheckedCreateInput>
    /**
     * In case the SongGenre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SongGenreUpdateInput, SongGenreUncheckedUpdateInput>
  }

  /**
   * SongGenre delete
   */
  export type SongGenreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreInclude<ExtArgs> | null
    /**
     * Filter which SongGenre to delete.
     */
    where: SongGenreWhereUniqueInput
  }

  /**
   * SongGenre deleteMany
   */
  export type SongGenreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SongGenres to delete
     */
    where?: SongGenreWhereInput
    /**
     * Limit how many SongGenres to delete.
     */
    limit?: number
  }

  /**
   * SongGenre without action
   */
  export type SongGenreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreInclude<ExtArgs> | null
  }


  /**
   * Model AlbumGenre
   */

  export type AggregateAlbumGenre = {
    _count: AlbumGenreCountAggregateOutputType | null
    _min: AlbumGenreMinAggregateOutputType | null
    _max: AlbumGenreMaxAggregateOutputType | null
  }

  export type AlbumGenreMinAggregateOutputType = {
    albumId: string | null
    genreId: string | null
  }

  export type AlbumGenreMaxAggregateOutputType = {
    albumId: string | null
    genreId: string | null
  }

  export type AlbumGenreCountAggregateOutputType = {
    albumId: number
    genreId: number
    _all: number
  }


  export type AlbumGenreMinAggregateInputType = {
    albumId?: true
    genreId?: true
  }

  export type AlbumGenreMaxAggregateInputType = {
    albumId?: true
    genreId?: true
  }

  export type AlbumGenreCountAggregateInputType = {
    albumId?: true
    genreId?: true
    _all?: true
  }

  export type AlbumGenreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlbumGenre to aggregate.
     */
    where?: AlbumGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlbumGenres to fetch.
     */
    orderBy?: AlbumGenreOrderByWithRelationInput | AlbumGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlbumGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlbumGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlbumGenres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AlbumGenres
    **/
    _count?: true | AlbumGenreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlbumGenreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlbumGenreMaxAggregateInputType
  }

  export type GetAlbumGenreAggregateType<T extends AlbumGenreAggregateArgs> = {
        [P in keyof T & keyof AggregateAlbumGenre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlbumGenre[P]>
      : GetScalarType<T[P], AggregateAlbumGenre[P]>
  }




  export type AlbumGenreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlbumGenreWhereInput
    orderBy?: AlbumGenreOrderByWithAggregationInput | AlbumGenreOrderByWithAggregationInput[]
    by: AlbumGenreScalarFieldEnum[] | AlbumGenreScalarFieldEnum
    having?: AlbumGenreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlbumGenreCountAggregateInputType | true
    _min?: AlbumGenreMinAggregateInputType
    _max?: AlbumGenreMaxAggregateInputType
  }

  export type AlbumGenreGroupByOutputType = {
    albumId: string
    genreId: string
    _count: AlbumGenreCountAggregateOutputType | null
    _min: AlbumGenreMinAggregateOutputType | null
    _max: AlbumGenreMaxAggregateOutputType | null
  }

  type GetAlbumGenreGroupByPayload<T extends AlbumGenreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlbumGenreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlbumGenreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlbumGenreGroupByOutputType[P]>
            : GetScalarType<T[P], AlbumGenreGroupByOutputType[P]>
        }
      >
    >


  export type AlbumGenreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    albumId?: boolean
    genreId?: boolean
    album?: boolean | AlbumDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["albumGenre"]>

  export type AlbumGenreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    albumId?: boolean
    genreId?: boolean
    album?: boolean | AlbumDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["albumGenre"]>

  export type AlbumGenreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    albumId?: boolean
    genreId?: boolean
    album?: boolean | AlbumDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["albumGenre"]>

  export type AlbumGenreSelectScalar = {
    albumId?: boolean
    genreId?: boolean
  }

  export type AlbumGenreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"albumId" | "genreId", ExtArgs["result"]["albumGenre"]>
  export type AlbumGenreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    album?: boolean | AlbumDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }
  export type AlbumGenreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    album?: boolean | AlbumDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }
  export type AlbumGenreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    album?: boolean | AlbumDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }

  export type $AlbumGenrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AlbumGenre"
    objects: {
      album: Prisma.$AlbumPayload<ExtArgs>
      genre: Prisma.$GenrePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      albumId: string
      genreId: string
    }, ExtArgs["result"]["albumGenre"]>
    composites: {}
  }

  type AlbumGenreGetPayload<S extends boolean | null | undefined | AlbumGenreDefaultArgs> = $Result.GetResult<Prisma.$AlbumGenrePayload, S>

  type AlbumGenreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlbumGenreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlbumGenreCountAggregateInputType | true
    }

  export interface AlbumGenreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AlbumGenre'], meta: { name: 'AlbumGenre' } }
    /**
     * Find zero or one AlbumGenre that matches the filter.
     * @param {AlbumGenreFindUniqueArgs} args - Arguments to find a AlbumGenre
     * @example
     * // Get one AlbumGenre
     * const albumGenre = await prisma.albumGenre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlbumGenreFindUniqueArgs>(args: SelectSubset<T, AlbumGenreFindUniqueArgs<ExtArgs>>): Prisma__AlbumGenreClient<$Result.GetResult<Prisma.$AlbumGenrePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AlbumGenre that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlbumGenreFindUniqueOrThrowArgs} args - Arguments to find a AlbumGenre
     * @example
     * // Get one AlbumGenre
     * const albumGenre = await prisma.albumGenre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlbumGenreFindUniqueOrThrowArgs>(args: SelectSubset<T, AlbumGenreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlbumGenreClient<$Result.GetResult<Prisma.$AlbumGenrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AlbumGenre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumGenreFindFirstArgs} args - Arguments to find a AlbumGenre
     * @example
     * // Get one AlbumGenre
     * const albumGenre = await prisma.albumGenre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlbumGenreFindFirstArgs>(args?: SelectSubset<T, AlbumGenreFindFirstArgs<ExtArgs>>): Prisma__AlbumGenreClient<$Result.GetResult<Prisma.$AlbumGenrePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AlbumGenre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumGenreFindFirstOrThrowArgs} args - Arguments to find a AlbumGenre
     * @example
     * // Get one AlbumGenre
     * const albumGenre = await prisma.albumGenre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlbumGenreFindFirstOrThrowArgs>(args?: SelectSubset<T, AlbumGenreFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlbumGenreClient<$Result.GetResult<Prisma.$AlbumGenrePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AlbumGenres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumGenreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AlbumGenres
     * const albumGenres = await prisma.albumGenre.findMany()
     * 
     * // Get first 10 AlbumGenres
     * const albumGenres = await prisma.albumGenre.findMany({ take: 10 })
     * 
     * // Only select the `albumId`
     * const albumGenreWithAlbumIdOnly = await prisma.albumGenre.findMany({ select: { albumId: true } })
     * 
     */
    findMany<T extends AlbumGenreFindManyArgs>(args?: SelectSubset<T, AlbumGenreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlbumGenrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AlbumGenre.
     * @param {AlbumGenreCreateArgs} args - Arguments to create a AlbumGenre.
     * @example
     * // Create one AlbumGenre
     * const AlbumGenre = await prisma.albumGenre.create({
     *   data: {
     *     // ... data to create a AlbumGenre
     *   }
     * })
     * 
     */
    create<T extends AlbumGenreCreateArgs>(args: SelectSubset<T, AlbumGenreCreateArgs<ExtArgs>>): Prisma__AlbumGenreClient<$Result.GetResult<Prisma.$AlbumGenrePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AlbumGenres.
     * @param {AlbumGenreCreateManyArgs} args - Arguments to create many AlbumGenres.
     * @example
     * // Create many AlbumGenres
     * const albumGenre = await prisma.albumGenre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlbumGenreCreateManyArgs>(args?: SelectSubset<T, AlbumGenreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AlbumGenres and returns the data saved in the database.
     * @param {AlbumGenreCreateManyAndReturnArgs} args - Arguments to create many AlbumGenres.
     * @example
     * // Create many AlbumGenres
     * const albumGenre = await prisma.albumGenre.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AlbumGenres and only return the `albumId`
     * const albumGenreWithAlbumIdOnly = await prisma.albumGenre.createManyAndReturn({
     *   select: { albumId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlbumGenreCreateManyAndReturnArgs>(args?: SelectSubset<T, AlbumGenreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlbumGenrePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AlbumGenre.
     * @param {AlbumGenreDeleteArgs} args - Arguments to delete one AlbumGenre.
     * @example
     * // Delete one AlbumGenre
     * const AlbumGenre = await prisma.albumGenre.delete({
     *   where: {
     *     // ... filter to delete one AlbumGenre
     *   }
     * })
     * 
     */
    delete<T extends AlbumGenreDeleteArgs>(args: SelectSubset<T, AlbumGenreDeleteArgs<ExtArgs>>): Prisma__AlbumGenreClient<$Result.GetResult<Prisma.$AlbumGenrePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AlbumGenre.
     * @param {AlbumGenreUpdateArgs} args - Arguments to update one AlbumGenre.
     * @example
     * // Update one AlbumGenre
     * const albumGenre = await prisma.albumGenre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlbumGenreUpdateArgs>(args: SelectSubset<T, AlbumGenreUpdateArgs<ExtArgs>>): Prisma__AlbumGenreClient<$Result.GetResult<Prisma.$AlbumGenrePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AlbumGenres.
     * @param {AlbumGenreDeleteManyArgs} args - Arguments to filter AlbumGenres to delete.
     * @example
     * // Delete a few AlbumGenres
     * const { count } = await prisma.albumGenre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlbumGenreDeleteManyArgs>(args?: SelectSubset<T, AlbumGenreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlbumGenres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumGenreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AlbumGenres
     * const albumGenre = await prisma.albumGenre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlbumGenreUpdateManyArgs>(args: SelectSubset<T, AlbumGenreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlbumGenres and returns the data updated in the database.
     * @param {AlbumGenreUpdateManyAndReturnArgs} args - Arguments to update many AlbumGenres.
     * @example
     * // Update many AlbumGenres
     * const albumGenre = await prisma.albumGenre.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AlbumGenres and only return the `albumId`
     * const albumGenreWithAlbumIdOnly = await prisma.albumGenre.updateManyAndReturn({
     *   select: { albumId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlbumGenreUpdateManyAndReturnArgs>(args: SelectSubset<T, AlbumGenreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlbumGenrePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AlbumGenre.
     * @param {AlbumGenreUpsertArgs} args - Arguments to update or create a AlbumGenre.
     * @example
     * // Update or create a AlbumGenre
     * const albumGenre = await prisma.albumGenre.upsert({
     *   create: {
     *     // ... data to create a AlbumGenre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AlbumGenre we want to update
     *   }
     * })
     */
    upsert<T extends AlbumGenreUpsertArgs>(args: SelectSubset<T, AlbumGenreUpsertArgs<ExtArgs>>): Prisma__AlbumGenreClient<$Result.GetResult<Prisma.$AlbumGenrePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AlbumGenres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumGenreCountArgs} args - Arguments to filter AlbumGenres to count.
     * @example
     * // Count the number of AlbumGenres
     * const count = await prisma.albumGenre.count({
     *   where: {
     *     // ... the filter for the AlbumGenres we want to count
     *   }
     * })
    **/
    count<T extends AlbumGenreCountArgs>(
      args?: Subset<T, AlbumGenreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlbumGenreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AlbumGenre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumGenreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlbumGenreAggregateArgs>(args: Subset<T, AlbumGenreAggregateArgs>): Prisma.PrismaPromise<GetAlbumGenreAggregateType<T>>

    /**
     * Group by AlbumGenre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumGenreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlbumGenreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlbumGenreGroupByArgs['orderBy'] }
        : { orderBy?: AlbumGenreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlbumGenreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlbumGenreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AlbumGenre model
   */
  readonly fields: AlbumGenreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AlbumGenre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlbumGenreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    album<T extends AlbumDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlbumDefaultArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    genre<T extends GenreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GenreDefaultArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AlbumGenre model
   */
  interface AlbumGenreFieldRefs {
    readonly albumId: FieldRef<"AlbumGenre", 'String'>
    readonly genreId: FieldRef<"AlbumGenre", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AlbumGenre findUnique
   */
  export type AlbumGenreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumGenre
     */
    select?: AlbumGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlbumGenre
     */
    omit?: AlbumGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumGenreInclude<ExtArgs> | null
    /**
     * Filter, which AlbumGenre to fetch.
     */
    where: AlbumGenreWhereUniqueInput
  }

  /**
   * AlbumGenre findUniqueOrThrow
   */
  export type AlbumGenreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumGenre
     */
    select?: AlbumGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlbumGenre
     */
    omit?: AlbumGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumGenreInclude<ExtArgs> | null
    /**
     * Filter, which AlbumGenre to fetch.
     */
    where: AlbumGenreWhereUniqueInput
  }

  /**
   * AlbumGenre findFirst
   */
  export type AlbumGenreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumGenre
     */
    select?: AlbumGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlbumGenre
     */
    omit?: AlbumGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumGenreInclude<ExtArgs> | null
    /**
     * Filter, which AlbumGenre to fetch.
     */
    where?: AlbumGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlbumGenres to fetch.
     */
    orderBy?: AlbumGenreOrderByWithRelationInput | AlbumGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlbumGenres.
     */
    cursor?: AlbumGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlbumGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlbumGenres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlbumGenres.
     */
    distinct?: AlbumGenreScalarFieldEnum | AlbumGenreScalarFieldEnum[]
  }

  /**
   * AlbumGenre findFirstOrThrow
   */
  export type AlbumGenreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumGenre
     */
    select?: AlbumGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlbumGenre
     */
    omit?: AlbumGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumGenreInclude<ExtArgs> | null
    /**
     * Filter, which AlbumGenre to fetch.
     */
    where?: AlbumGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlbumGenres to fetch.
     */
    orderBy?: AlbumGenreOrderByWithRelationInput | AlbumGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlbumGenres.
     */
    cursor?: AlbumGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlbumGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlbumGenres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlbumGenres.
     */
    distinct?: AlbumGenreScalarFieldEnum | AlbumGenreScalarFieldEnum[]
  }

  /**
   * AlbumGenre findMany
   */
  export type AlbumGenreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumGenre
     */
    select?: AlbumGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlbumGenre
     */
    omit?: AlbumGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumGenreInclude<ExtArgs> | null
    /**
     * Filter, which AlbumGenres to fetch.
     */
    where?: AlbumGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlbumGenres to fetch.
     */
    orderBy?: AlbumGenreOrderByWithRelationInput | AlbumGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AlbumGenres.
     */
    cursor?: AlbumGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlbumGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlbumGenres.
     */
    skip?: number
    distinct?: AlbumGenreScalarFieldEnum | AlbumGenreScalarFieldEnum[]
  }

  /**
   * AlbumGenre create
   */
  export type AlbumGenreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumGenre
     */
    select?: AlbumGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlbumGenre
     */
    omit?: AlbumGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumGenreInclude<ExtArgs> | null
    /**
     * The data needed to create a AlbumGenre.
     */
    data: XOR<AlbumGenreCreateInput, AlbumGenreUncheckedCreateInput>
  }

  /**
   * AlbumGenre createMany
   */
  export type AlbumGenreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AlbumGenres.
     */
    data: AlbumGenreCreateManyInput | AlbumGenreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AlbumGenre createManyAndReturn
   */
  export type AlbumGenreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumGenre
     */
    select?: AlbumGenreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AlbumGenre
     */
    omit?: AlbumGenreOmit<ExtArgs> | null
    /**
     * The data used to create many AlbumGenres.
     */
    data: AlbumGenreCreateManyInput | AlbumGenreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumGenreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AlbumGenre update
   */
  export type AlbumGenreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumGenre
     */
    select?: AlbumGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlbumGenre
     */
    omit?: AlbumGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumGenreInclude<ExtArgs> | null
    /**
     * The data needed to update a AlbumGenre.
     */
    data: XOR<AlbumGenreUpdateInput, AlbumGenreUncheckedUpdateInput>
    /**
     * Choose, which AlbumGenre to update.
     */
    where: AlbumGenreWhereUniqueInput
  }

  /**
   * AlbumGenre updateMany
   */
  export type AlbumGenreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AlbumGenres.
     */
    data: XOR<AlbumGenreUpdateManyMutationInput, AlbumGenreUncheckedUpdateManyInput>
    /**
     * Filter which AlbumGenres to update
     */
    where?: AlbumGenreWhereInput
    /**
     * Limit how many AlbumGenres to update.
     */
    limit?: number
  }

  /**
   * AlbumGenre updateManyAndReturn
   */
  export type AlbumGenreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumGenre
     */
    select?: AlbumGenreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AlbumGenre
     */
    omit?: AlbumGenreOmit<ExtArgs> | null
    /**
     * The data used to update AlbumGenres.
     */
    data: XOR<AlbumGenreUpdateManyMutationInput, AlbumGenreUncheckedUpdateManyInput>
    /**
     * Filter which AlbumGenres to update
     */
    where?: AlbumGenreWhereInput
    /**
     * Limit how many AlbumGenres to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumGenreIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AlbumGenre upsert
   */
  export type AlbumGenreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumGenre
     */
    select?: AlbumGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlbumGenre
     */
    omit?: AlbumGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumGenreInclude<ExtArgs> | null
    /**
     * The filter to search for the AlbumGenre to update in case it exists.
     */
    where: AlbumGenreWhereUniqueInput
    /**
     * In case the AlbumGenre found by the `where` argument doesn't exist, create a new AlbumGenre with this data.
     */
    create: XOR<AlbumGenreCreateInput, AlbumGenreUncheckedCreateInput>
    /**
     * In case the AlbumGenre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlbumGenreUpdateInput, AlbumGenreUncheckedUpdateInput>
  }

  /**
   * AlbumGenre delete
   */
  export type AlbumGenreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumGenre
     */
    select?: AlbumGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlbumGenre
     */
    omit?: AlbumGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumGenreInclude<ExtArgs> | null
    /**
     * Filter which AlbumGenre to delete.
     */
    where: AlbumGenreWhereUniqueInput
  }

  /**
   * AlbumGenre deleteMany
   */
  export type AlbumGenreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlbumGenres to delete
     */
    where?: AlbumGenreWhereInput
    /**
     * Limit how many AlbumGenres to delete.
     */
    limit?: number
  }

  /**
   * AlbumGenre without action
   */
  export type AlbumGenreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumGenre
     */
    select?: AlbumGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlbumGenre
     */
    omit?: AlbumGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumGenreInclude<ExtArgs> | null
  }


  /**
   * Model ArtistGenre
   */

  export type AggregateArtistGenre = {
    _count: ArtistGenreCountAggregateOutputType | null
    _min: ArtistGenreMinAggregateOutputType | null
    _max: ArtistGenreMaxAggregateOutputType | null
  }

  export type ArtistGenreMinAggregateOutputType = {
    artistId: string | null
    genreId: string | null
  }

  export type ArtistGenreMaxAggregateOutputType = {
    artistId: string | null
    genreId: string | null
  }

  export type ArtistGenreCountAggregateOutputType = {
    artistId: number
    genreId: number
    _all: number
  }


  export type ArtistGenreMinAggregateInputType = {
    artistId?: true
    genreId?: true
  }

  export type ArtistGenreMaxAggregateInputType = {
    artistId?: true
    genreId?: true
  }

  export type ArtistGenreCountAggregateInputType = {
    artistId?: true
    genreId?: true
    _all?: true
  }

  export type ArtistGenreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArtistGenre to aggregate.
     */
    where?: ArtistGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtistGenres to fetch.
     */
    orderBy?: ArtistGenreOrderByWithRelationInput | ArtistGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArtistGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtistGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtistGenres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArtistGenres
    **/
    _count?: true | ArtistGenreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArtistGenreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArtistGenreMaxAggregateInputType
  }

  export type GetArtistGenreAggregateType<T extends ArtistGenreAggregateArgs> = {
        [P in keyof T & keyof AggregateArtistGenre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArtistGenre[P]>
      : GetScalarType<T[P], AggregateArtistGenre[P]>
  }




  export type ArtistGenreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtistGenreWhereInput
    orderBy?: ArtistGenreOrderByWithAggregationInput | ArtistGenreOrderByWithAggregationInput[]
    by: ArtistGenreScalarFieldEnum[] | ArtistGenreScalarFieldEnum
    having?: ArtistGenreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArtistGenreCountAggregateInputType | true
    _min?: ArtistGenreMinAggregateInputType
    _max?: ArtistGenreMaxAggregateInputType
  }

  export type ArtistGenreGroupByOutputType = {
    artistId: string
    genreId: string
    _count: ArtistGenreCountAggregateOutputType | null
    _min: ArtistGenreMinAggregateOutputType | null
    _max: ArtistGenreMaxAggregateOutputType | null
  }

  type GetArtistGenreGroupByPayload<T extends ArtistGenreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArtistGenreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArtistGenreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArtistGenreGroupByOutputType[P]>
            : GetScalarType<T[P], ArtistGenreGroupByOutputType[P]>
        }
      >
    >


  export type ArtistGenreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    artistId?: boolean
    genreId?: boolean
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artistGenre"]>

  export type ArtistGenreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    artistId?: boolean
    genreId?: boolean
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artistGenre"]>

  export type ArtistGenreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    artistId?: boolean
    genreId?: boolean
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artistGenre"]>

  export type ArtistGenreSelectScalar = {
    artistId?: boolean
    genreId?: boolean
  }

  export type ArtistGenreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"artistId" | "genreId", ExtArgs["result"]["artistGenre"]>
  export type ArtistGenreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }
  export type ArtistGenreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }
  export type ArtistGenreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }

  export type $ArtistGenrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ArtistGenre"
    objects: {
      artist: Prisma.$ArtistPayload<ExtArgs>
      genre: Prisma.$GenrePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      artistId: string
      genreId: string
    }, ExtArgs["result"]["artistGenre"]>
    composites: {}
  }

  type ArtistGenreGetPayload<S extends boolean | null | undefined | ArtistGenreDefaultArgs> = $Result.GetResult<Prisma.$ArtistGenrePayload, S>

  type ArtistGenreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArtistGenreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArtistGenreCountAggregateInputType | true
    }

  export interface ArtistGenreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArtistGenre'], meta: { name: 'ArtistGenre' } }
    /**
     * Find zero or one ArtistGenre that matches the filter.
     * @param {ArtistGenreFindUniqueArgs} args - Arguments to find a ArtistGenre
     * @example
     * // Get one ArtistGenre
     * const artistGenre = await prisma.artistGenre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArtistGenreFindUniqueArgs>(args: SelectSubset<T, ArtistGenreFindUniqueArgs<ExtArgs>>): Prisma__ArtistGenreClient<$Result.GetResult<Prisma.$ArtistGenrePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ArtistGenre that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArtistGenreFindUniqueOrThrowArgs} args - Arguments to find a ArtistGenre
     * @example
     * // Get one ArtistGenre
     * const artistGenre = await prisma.artistGenre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArtistGenreFindUniqueOrThrowArgs>(args: SelectSubset<T, ArtistGenreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArtistGenreClient<$Result.GetResult<Prisma.$ArtistGenrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArtistGenre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistGenreFindFirstArgs} args - Arguments to find a ArtistGenre
     * @example
     * // Get one ArtistGenre
     * const artistGenre = await prisma.artistGenre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArtistGenreFindFirstArgs>(args?: SelectSubset<T, ArtistGenreFindFirstArgs<ExtArgs>>): Prisma__ArtistGenreClient<$Result.GetResult<Prisma.$ArtistGenrePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArtistGenre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistGenreFindFirstOrThrowArgs} args - Arguments to find a ArtistGenre
     * @example
     * // Get one ArtistGenre
     * const artistGenre = await prisma.artistGenre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArtistGenreFindFirstOrThrowArgs>(args?: SelectSubset<T, ArtistGenreFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArtistGenreClient<$Result.GetResult<Prisma.$ArtistGenrePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ArtistGenres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistGenreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArtistGenres
     * const artistGenres = await prisma.artistGenre.findMany()
     * 
     * // Get first 10 ArtistGenres
     * const artistGenres = await prisma.artistGenre.findMany({ take: 10 })
     * 
     * // Only select the `artistId`
     * const artistGenreWithArtistIdOnly = await prisma.artistGenre.findMany({ select: { artistId: true } })
     * 
     */
    findMany<T extends ArtistGenreFindManyArgs>(args?: SelectSubset<T, ArtistGenreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtistGenrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ArtistGenre.
     * @param {ArtistGenreCreateArgs} args - Arguments to create a ArtistGenre.
     * @example
     * // Create one ArtistGenre
     * const ArtistGenre = await prisma.artistGenre.create({
     *   data: {
     *     // ... data to create a ArtistGenre
     *   }
     * })
     * 
     */
    create<T extends ArtistGenreCreateArgs>(args: SelectSubset<T, ArtistGenreCreateArgs<ExtArgs>>): Prisma__ArtistGenreClient<$Result.GetResult<Prisma.$ArtistGenrePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ArtistGenres.
     * @param {ArtistGenreCreateManyArgs} args - Arguments to create many ArtistGenres.
     * @example
     * // Create many ArtistGenres
     * const artistGenre = await prisma.artistGenre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArtistGenreCreateManyArgs>(args?: SelectSubset<T, ArtistGenreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ArtistGenres and returns the data saved in the database.
     * @param {ArtistGenreCreateManyAndReturnArgs} args - Arguments to create many ArtistGenres.
     * @example
     * // Create many ArtistGenres
     * const artistGenre = await prisma.artistGenre.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ArtistGenres and only return the `artistId`
     * const artistGenreWithArtistIdOnly = await prisma.artistGenre.createManyAndReturn({
     *   select: { artistId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArtistGenreCreateManyAndReturnArgs>(args?: SelectSubset<T, ArtistGenreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtistGenrePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ArtistGenre.
     * @param {ArtistGenreDeleteArgs} args - Arguments to delete one ArtistGenre.
     * @example
     * // Delete one ArtistGenre
     * const ArtistGenre = await prisma.artistGenre.delete({
     *   where: {
     *     // ... filter to delete one ArtistGenre
     *   }
     * })
     * 
     */
    delete<T extends ArtistGenreDeleteArgs>(args: SelectSubset<T, ArtistGenreDeleteArgs<ExtArgs>>): Prisma__ArtistGenreClient<$Result.GetResult<Prisma.$ArtistGenrePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ArtistGenre.
     * @param {ArtistGenreUpdateArgs} args - Arguments to update one ArtistGenre.
     * @example
     * // Update one ArtistGenre
     * const artistGenre = await prisma.artistGenre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArtistGenreUpdateArgs>(args: SelectSubset<T, ArtistGenreUpdateArgs<ExtArgs>>): Prisma__ArtistGenreClient<$Result.GetResult<Prisma.$ArtistGenrePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ArtistGenres.
     * @param {ArtistGenreDeleteManyArgs} args - Arguments to filter ArtistGenres to delete.
     * @example
     * // Delete a few ArtistGenres
     * const { count } = await prisma.artistGenre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArtistGenreDeleteManyArgs>(args?: SelectSubset<T, ArtistGenreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArtistGenres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistGenreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArtistGenres
     * const artistGenre = await prisma.artistGenre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArtistGenreUpdateManyArgs>(args: SelectSubset<T, ArtistGenreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArtistGenres and returns the data updated in the database.
     * @param {ArtistGenreUpdateManyAndReturnArgs} args - Arguments to update many ArtistGenres.
     * @example
     * // Update many ArtistGenres
     * const artistGenre = await prisma.artistGenre.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ArtistGenres and only return the `artistId`
     * const artistGenreWithArtistIdOnly = await prisma.artistGenre.updateManyAndReturn({
     *   select: { artistId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ArtistGenreUpdateManyAndReturnArgs>(args: SelectSubset<T, ArtistGenreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtistGenrePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ArtistGenre.
     * @param {ArtistGenreUpsertArgs} args - Arguments to update or create a ArtistGenre.
     * @example
     * // Update or create a ArtistGenre
     * const artistGenre = await prisma.artistGenre.upsert({
     *   create: {
     *     // ... data to create a ArtistGenre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArtistGenre we want to update
     *   }
     * })
     */
    upsert<T extends ArtistGenreUpsertArgs>(args: SelectSubset<T, ArtistGenreUpsertArgs<ExtArgs>>): Prisma__ArtistGenreClient<$Result.GetResult<Prisma.$ArtistGenrePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ArtistGenres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistGenreCountArgs} args - Arguments to filter ArtistGenres to count.
     * @example
     * // Count the number of ArtistGenres
     * const count = await prisma.artistGenre.count({
     *   where: {
     *     // ... the filter for the ArtistGenres we want to count
     *   }
     * })
    **/
    count<T extends ArtistGenreCountArgs>(
      args?: Subset<T, ArtistGenreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArtistGenreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArtistGenre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistGenreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArtistGenreAggregateArgs>(args: Subset<T, ArtistGenreAggregateArgs>): Prisma.PrismaPromise<GetArtistGenreAggregateType<T>>

    /**
     * Group by ArtistGenre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistGenreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArtistGenreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArtistGenreGroupByArgs['orderBy'] }
        : { orderBy?: ArtistGenreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArtistGenreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArtistGenreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ArtistGenre model
   */
  readonly fields: ArtistGenreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArtistGenre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArtistGenreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    artist<T extends ArtistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArtistDefaultArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    genre<T extends GenreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GenreDefaultArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ArtistGenre model
   */
  interface ArtistGenreFieldRefs {
    readonly artistId: FieldRef<"ArtistGenre", 'String'>
    readonly genreId: FieldRef<"ArtistGenre", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ArtistGenre findUnique
   */
  export type ArtistGenreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreInclude<ExtArgs> | null
    /**
     * Filter, which ArtistGenre to fetch.
     */
    where: ArtistGenreWhereUniqueInput
  }

  /**
   * ArtistGenre findUniqueOrThrow
   */
  export type ArtistGenreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreInclude<ExtArgs> | null
    /**
     * Filter, which ArtistGenre to fetch.
     */
    where: ArtistGenreWhereUniqueInput
  }

  /**
   * ArtistGenre findFirst
   */
  export type ArtistGenreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreInclude<ExtArgs> | null
    /**
     * Filter, which ArtistGenre to fetch.
     */
    where?: ArtistGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtistGenres to fetch.
     */
    orderBy?: ArtistGenreOrderByWithRelationInput | ArtistGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArtistGenres.
     */
    cursor?: ArtistGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtistGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtistGenres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArtistGenres.
     */
    distinct?: ArtistGenreScalarFieldEnum | ArtistGenreScalarFieldEnum[]
  }

  /**
   * ArtistGenre findFirstOrThrow
   */
  export type ArtistGenreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreInclude<ExtArgs> | null
    /**
     * Filter, which ArtistGenre to fetch.
     */
    where?: ArtistGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtistGenres to fetch.
     */
    orderBy?: ArtistGenreOrderByWithRelationInput | ArtistGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArtistGenres.
     */
    cursor?: ArtistGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtistGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtistGenres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArtistGenres.
     */
    distinct?: ArtistGenreScalarFieldEnum | ArtistGenreScalarFieldEnum[]
  }

  /**
   * ArtistGenre findMany
   */
  export type ArtistGenreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreInclude<ExtArgs> | null
    /**
     * Filter, which ArtistGenres to fetch.
     */
    where?: ArtistGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtistGenres to fetch.
     */
    orderBy?: ArtistGenreOrderByWithRelationInput | ArtistGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArtistGenres.
     */
    cursor?: ArtistGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtistGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtistGenres.
     */
    skip?: number
    distinct?: ArtistGenreScalarFieldEnum | ArtistGenreScalarFieldEnum[]
  }

  /**
   * ArtistGenre create
   */
  export type ArtistGenreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreInclude<ExtArgs> | null
    /**
     * The data needed to create a ArtistGenre.
     */
    data: XOR<ArtistGenreCreateInput, ArtistGenreUncheckedCreateInput>
  }

  /**
   * ArtistGenre createMany
   */
  export type ArtistGenreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ArtistGenres.
     */
    data: ArtistGenreCreateManyInput | ArtistGenreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ArtistGenre createManyAndReturn
   */
  export type ArtistGenreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * The data used to create many ArtistGenres.
     */
    data: ArtistGenreCreateManyInput | ArtistGenreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArtistGenre update
   */
  export type ArtistGenreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreInclude<ExtArgs> | null
    /**
     * The data needed to update a ArtistGenre.
     */
    data: XOR<ArtistGenreUpdateInput, ArtistGenreUncheckedUpdateInput>
    /**
     * Choose, which ArtistGenre to update.
     */
    where: ArtistGenreWhereUniqueInput
  }

  /**
   * ArtistGenre updateMany
   */
  export type ArtistGenreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ArtistGenres.
     */
    data: XOR<ArtistGenreUpdateManyMutationInput, ArtistGenreUncheckedUpdateManyInput>
    /**
     * Filter which ArtistGenres to update
     */
    where?: ArtistGenreWhereInput
    /**
     * Limit how many ArtistGenres to update.
     */
    limit?: number
  }

  /**
   * ArtistGenre updateManyAndReturn
   */
  export type ArtistGenreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * The data used to update ArtistGenres.
     */
    data: XOR<ArtistGenreUpdateManyMutationInput, ArtistGenreUncheckedUpdateManyInput>
    /**
     * Filter which ArtistGenres to update
     */
    where?: ArtistGenreWhereInput
    /**
     * Limit how many ArtistGenres to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArtistGenre upsert
   */
  export type ArtistGenreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreInclude<ExtArgs> | null
    /**
     * The filter to search for the ArtistGenre to update in case it exists.
     */
    where: ArtistGenreWhereUniqueInput
    /**
     * In case the ArtistGenre found by the `where` argument doesn't exist, create a new ArtistGenre with this data.
     */
    create: XOR<ArtistGenreCreateInput, ArtistGenreUncheckedCreateInput>
    /**
     * In case the ArtistGenre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArtistGenreUpdateInput, ArtistGenreUncheckedUpdateInput>
  }

  /**
   * ArtistGenre delete
   */
  export type ArtistGenreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreInclude<ExtArgs> | null
    /**
     * Filter which ArtistGenre to delete.
     */
    where: ArtistGenreWhereUniqueInput
  }

  /**
   * ArtistGenre deleteMany
   */
  export type ArtistGenreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArtistGenres to delete
     */
    where?: ArtistGenreWhereInput
    /**
     * Limit how many ArtistGenres to delete.
     */
    limit?: number
  }

  /**
   * ArtistGenre without action
   */
  export type ArtistGenreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreInclude<ExtArgs> | null
  }


  /**
   * Model Playlist
   */

  export type AggregatePlaylist = {
    _count: PlaylistCountAggregateOutputType | null
    _avg: PlaylistAvgAggregateOutputType | null
    _sum: PlaylistSumAggregateOutputType | null
    _min: PlaylistMinAggregateOutputType | null
    _max: PlaylistMaxAggregateOutputType | null
  }

  export type PlaylistAvgAggregateOutputType = {
    totalTracks: number | null
    duration: number | null
  }

  export type PlaylistSumAggregateOutputType = {
    totalTracks: number | null
    duration: number | null
  }

  export type PlaylistMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    imageId: string | null
    isPublic: boolean | null
    isOfficial: boolean | null
    totalTracks: number | null
    duration: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type PlaylistMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    imageId: string | null
    isPublic: boolean | null
    isOfficial: boolean | null
    totalTracks: number | null
    duration: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type PlaylistCountAggregateOutputType = {
    id: number
    title: number
    description: number
    imageId: number
    isPublic: number
    isOfficial: number
    totalTracks: number
    duration: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type PlaylistAvgAggregateInputType = {
    totalTracks?: true
    duration?: true
  }

  export type PlaylistSumAggregateInputType = {
    totalTracks?: true
    duration?: true
  }

  export type PlaylistMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageId?: true
    isPublic?: true
    isOfficial?: true
    totalTracks?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type PlaylistMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageId?: true
    isPublic?: true
    isOfficial?: true
    totalTracks?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type PlaylistCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageId?: true
    isPublic?: true
    isOfficial?: true
    totalTracks?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type PlaylistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Playlist to aggregate.
     */
    where?: PlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Playlists to fetch.
     */
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Playlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Playlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Playlists
    **/
    _count?: true | PlaylistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlaylistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlaylistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaylistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaylistMaxAggregateInputType
  }

  export type GetPlaylistAggregateType<T extends PlaylistAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaylist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaylist[P]>
      : GetScalarType<T[P], AggregatePlaylist[P]>
  }




  export type PlaylistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistWhereInput
    orderBy?: PlaylistOrderByWithAggregationInput | PlaylistOrderByWithAggregationInput[]
    by: PlaylistScalarFieldEnum[] | PlaylistScalarFieldEnum
    having?: PlaylistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlaylistCountAggregateInputType | true
    _avg?: PlaylistAvgAggregateInputType
    _sum?: PlaylistSumAggregateInputType
    _min?: PlaylistMinAggregateInputType
    _max?: PlaylistMaxAggregateInputType
  }

  export type PlaylistGroupByOutputType = {
    id: string
    title: string
    description: string | null
    imageId: string | null
    isPublic: boolean
    isOfficial: boolean
    totalTracks: number
    duration: number
    createdAt: Date
    updatedAt: Date
    userId: string | null
    _count: PlaylistCountAggregateOutputType | null
    _avg: PlaylistAvgAggregateOutputType | null
    _sum: PlaylistSumAggregateOutputType | null
    _min: PlaylistMinAggregateOutputType | null
    _max: PlaylistMaxAggregateOutputType | null
  }

  type GetPlaylistGroupByPayload<T extends PlaylistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaylistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaylistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaylistGroupByOutputType[P]>
            : GetScalarType<T[P], PlaylistGroupByOutputType[P]>
        }
      >
    >


  export type PlaylistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    imageId?: boolean
    isPublic?: boolean
    isOfficial?: boolean
    totalTracks?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | Playlist$userArgs<ExtArgs>
    items?: boolean | Playlist$itemsArgs<ExtArgs>
    likedBy?: boolean | Playlist$likedByArgs<ExtArgs>
    _count?: boolean | PlaylistCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playlist"]>

  export type PlaylistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    imageId?: boolean
    isPublic?: boolean
    isOfficial?: boolean
    totalTracks?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | Playlist$userArgs<ExtArgs>
  }, ExtArgs["result"]["playlist"]>

  export type PlaylistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    imageId?: boolean
    isPublic?: boolean
    isOfficial?: boolean
    totalTracks?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | Playlist$userArgs<ExtArgs>
  }, ExtArgs["result"]["playlist"]>

  export type PlaylistSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    imageId?: boolean
    isPublic?: boolean
    isOfficial?: boolean
    totalTracks?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type PlaylistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "imageId" | "isPublic" | "isOfficial" | "totalTracks" | "duration" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["playlist"]>
  export type PlaylistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Playlist$userArgs<ExtArgs>
    items?: boolean | Playlist$itemsArgs<ExtArgs>
    likedBy?: boolean | Playlist$likedByArgs<ExtArgs>
    _count?: boolean | PlaylistCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlaylistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Playlist$userArgs<ExtArgs>
  }
  export type PlaylistIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Playlist$userArgs<ExtArgs>
  }

  export type $PlaylistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Playlist"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      items: Prisma.$PlaylistItemPayload<ExtArgs>[]
      likedBy: Prisma.$UserLikedPlaylistPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      imageId: string | null
      isPublic: boolean
      isOfficial: boolean
      totalTracks: number
      duration: number
      createdAt: Date
      updatedAt: Date
      userId: string | null
    }, ExtArgs["result"]["playlist"]>
    composites: {}
  }

  type PlaylistGetPayload<S extends boolean | null | undefined | PlaylistDefaultArgs> = $Result.GetResult<Prisma.$PlaylistPayload, S>

  type PlaylistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlaylistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaylistCountAggregateInputType | true
    }

  export interface PlaylistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Playlist'], meta: { name: 'Playlist' } }
    /**
     * Find zero or one Playlist that matches the filter.
     * @param {PlaylistFindUniqueArgs} args - Arguments to find a Playlist
     * @example
     * // Get one Playlist
     * const playlist = await prisma.playlist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaylistFindUniqueArgs>(args: SelectSubset<T, PlaylistFindUniqueArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Playlist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlaylistFindUniqueOrThrowArgs} args - Arguments to find a Playlist
     * @example
     * // Get one Playlist
     * const playlist = await prisma.playlist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaylistFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaylistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Playlist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistFindFirstArgs} args - Arguments to find a Playlist
     * @example
     * // Get one Playlist
     * const playlist = await prisma.playlist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaylistFindFirstArgs>(args?: SelectSubset<T, PlaylistFindFirstArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Playlist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistFindFirstOrThrowArgs} args - Arguments to find a Playlist
     * @example
     * // Get one Playlist
     * const playlist = await prisma.playlist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaylistFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaylistFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Playlists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Playlists
     * const playlists = await prisma.playlist.findMany()
     * 
     * // Get first 10 Playlists
     * const playlists = await prisma.playlist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playlistWithIdOnly = await prisma.playlist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlaylistFindManyArgs>(args?: SelectSubset<T, PlaylistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Playlist.
     * @param {PlaylistCreateArgs} args - Arguments to create a Playlist.
     * @example
     * // Create one Playlist
     * const Playlist = await prisma.playlist.create({
     *   data: {
     *     // ... data to create a Playlist
     *   }
     * })
     * 
     */
    create<T extends PlaylistCreateArgs>(args: SelectSubset<T, PlaylistCreateArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Playlists.
     * @param {PlaylistCreateManyArgs} args - Arguments to create many Playlists.
     * @example
     * // Create many Playlists
     * const playlist = await prisma.playlist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaylistCreateManyArgs>(args?: SelectSubset<T, PlaylistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Playlists and returns the data saved in the database.
     * @param {PlaylistCreateManyAndReturnArgs} args - Arguments to create many Playlists.
     * @example
     * // Create many Playlists
     * const playlist = await prisma.playlist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Playlists and only return the `id`
     * const playlistWithIdOnly = await prisma.playlist.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlaylistCreateManyAndReturnArgs>(args?: SelectSubset<T, PlaylistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Playlist.
     * @param {PlaylistDeleteArgs} args - Arguments to delete one Playlist.
     * @example
     * // Delete one Playlist
     * const Playlist = await prisma.playlist.delete({
     *   where: {
     *     // ... filter to delete one Playlist
     *   }
     * })
     * 
     */
    delete<T extends PlaylistDeleteArgs>(args: SelectSubset<T, PlaylistDeleteArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Playlist.
     * @param {PlaylistUpdateArgs} args - Arguments to update one Playlist.
     * @example
     * // Update one Playlist
     * const playlist = await prisma.playlist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaylistUpdateArgs>(args: SelectSubset<T, PlaylistUpdateArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Playlists.
     * @param {PlaylistDeleteManyArgs} args - Arguments to filter Playlists to delete.
     * @example
     * // Delete a few Playlists
     * const { count } = await prisma.playlist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaylistDeleteManyArgs>(args?: SelectSubset<T, PlaylistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Playlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Playlists
     * const playlist = await prisma.playlist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaylistUpdateManyArgs>(args: SelectSubset<T, PlaylistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Playlists and returns the data updated in the database.
     * @param {PlaylistUpdateManyAndReturnArgs} args - Arguments to update many Playlists.
     * @example
     * // Update many Playlists
     * const playlist = await prisma.playlist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Playlists and only return the `id`
     * const playlistWithIdOnly = await prisma.playlist.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlaylistUpdateManyAndReturnArgs>(args: SelectSubset<T, PlaylistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Playlist.
     * @param {PlaylistUpsertArgs} args - Arguments to update or create a Playlist.
     * @example
     * // Update or create a Playlist
     * const playlist = await prisma.playlist.upsert({
     *   create: {
     *     // ... data to create a Playlist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Playlist we want to update
     *   }
     * })
     */
    upsert<T extends PlaylistUpsertArgs>(args: SelectSubset<T, PlaylistUpsertArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Playlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistCountArgs} args - Arguments to filter Playlists to count.
     * @example
     * // Count the number of Playlists
     * const count = await prisma.playlist.count({
     *   where: {
     *     // ... the filter for the Playlists we want to count
     *   }
     * })
    **/
    count<T extends PlaylistCountArgs>(
      args?: Subset<T, PlaylistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaylistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Playlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaylistAggregateArgs>(args: Subset<T, PlaylistAggregateArgs>): Prisma.PrismaPromise<GetPlaylistAggregateType<T>>

    /**
     * Group by Playlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaylistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaylistGroupByArgs['orderBy'] }
        : { orderBy?: PlaylistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaylistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaylistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Playlist model
   */
  readonly fields: PlaylistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Playlist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaylistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Playlist$userArgs<ExtArgs> = {}>(args?: Subset<T, Playlist$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Playlist$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Playlist$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likedBy<T extends Playlist$likedByArgs<ExtArgs> = {}>(args?: Subset<T, Playlist$likedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLikedPlaylistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Playlist model
   */
  interface PlaylistFieldRefs {
    readonly id: FieldRef<"Playlist", 'String'>
    readonly title: FieldRef<"Playlist", 'String'>
    readonly description: FieldRef<"Playlist", 'String'>
    readonly imageId: FieldRef<"Playlist", 'String'>
    readonly isPublic: FieldRef<"Playlist", 'Boolean'>
    readonly isOfficial: FieldRef<"Playlist", 'Boolean'>
    readonly totalTracks: FieldRef<"Playlist", 'Int'>
    readonly duration: FieldRef<"Playlist", 'Int'>
    readonly createdAt: FieldRef<"Playlist", 'DateTime'>
    readonly updatedAt: FieldRef<"Playlist", 'DateTime'>
    readonly userId: FieldRef<"Playlist", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Playlist findUnique
   */
  export type PlaylistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlist to fetch.
     */
    where: PlaylistWhereUniqueInput
  }

  /**
   * Playlist findUniqueOrThrow
   */
  export type PlaylistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlist to fetch.
     */
    where: PlaylistWhereUniqueInput
  }

  /**
   * Playlist findFirst
   */
  export type PlaylistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlist to fetch.
     */
    where?: PlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Playlists to fetch.
     */
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Playlists.
     */
    cursor?: PlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Playlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Playlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Playlists.
     */
    distinct?: PlaylistScalarFieldEnum | PlaylistScalarFieldEnum[]
  }

  /**
   * Playlist findFirstOrThrow
   */
  export type PlaylistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlist to fetch.
     */
    where?: PlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Playlists to fetch.
     */
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Playlists.
     */
    cursor?: PlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Playlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Playlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Playlists.
     */
    distinct?: PlaylistScalarFieldEnum | PlaylistScalarFieldEnum[]
  }

  /**
   * Playlist findMany
   */
  export type PlaylistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlists to fetch.
     */
    where?: PlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Playlists to fetch.
     */
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Playlists.
     */
    cursor?: PlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Playlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Playlists.
     */
    skip?: number
    distinct?: PlaylistScalarFieldEnum | PlaylistScalarFieldEnum[]
  }

  /**
   * Playlist create
   */
  export type PlaylistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * The data needed to create a Playlist.
     */
    data: XOR<PlaylistCreateInput, PlaylistUncheckedCreateInput>
  }

  /**
   * Playlist createMany
   */
  export type PlaylistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Playlists.
     */
    data: PlaylistCreateManyInput | PlaylistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Playlist createManyAndReturn
   */
  export type PlaylistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * The data used to create many Playlists.
     */
    data: PlaylistCreateManyInput | PlaylistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Playlist update
   */
  export type PlaylistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * The data needed to update a Playlist.
     */
    data: XOR<PlaylistUpdateInput, PlaylistUncheckedUpdateInput>
    /**
     * Choose, which Playlist to update.
     */
    where: PlaylistWhereUniqueInput
  }

  /**
   * Playlist updateMany
   */
  export type PlaylistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Playlists.
     */
    data: XOR<PlaylistUpdateManyMutationInput, PlaylistUncheckedUpdateManyInput>
    /**
     * Filter which Playlists to update
     */
    where?: PlaylistWhereInput
    /**
     * Limit how many Playlists to update.
     */
    limit?: number
  }

  /**
   * Playlist updateManyAndReturn
   */
  export type PlaylistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * The data used to update Playlists.
     */
    data: XOR<PlaylistUpdateManyMutationInput, PlaylistUncheckedUpdateManyInput>
    /**
     * Filter which Playlists to update
     */
    where?: PlaylistWhereInput
    /**
     * Limit how many Playlists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Playlist upsert
   */
  export type PlaylistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * The filter to search for the Playlist to update in case it exists.
     */
    where: PlaylistWhereUniqueInput
    /**
     * In case the Playlist found by the `where` argument doesn't exist, create a new Playlist with this data.
     */
    create: XOR<PlaylistCreateInput, PlaylistUncheckedCreateInput>
    /**
     * In case the Playlist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaylistUpdateInput, PlaylistUncheckedUpdateInput>
  }

  /**
   * Playlist delete
   */
  export type PlaylistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter which Playlist to delete.
     */
    where: PlaylistWhereUniqueInput
  }

  /**
   * Playlist deleteMany
   */
  export type PlaylistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Playlists to delete
     */
    where?: PlaylistWhereInput
    /**
     * Limit how many Playlists to delete.
     */
    limit?: number
  }

  /**
   * Playlist.user
   */
  export type Playlist$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Playlist.items
   */
  export type Playlist$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemInclude<ExtArgs> | null
    where?: PlaylistItemWhereInput
    orderBy?: PlaylistItemOrderByWithRelationInput | PlaylistItemOrderByWithRelationInput[]
    cursor?: PlaylistItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaylistItemScalarFieldEnum | PlaylistItemScalarFieldEnum[]
  }

  /**
   * Playlist.likedBy
   */
  export type Playlist$likedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedPlaylist
     */
    select?: UserLikedPlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedPlaylist
     */
    omit?: UserLikedPlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedPlaylistInclude<ExtArgs> | null
    where?: UserLikedPlaylistWhereInput
    orderBy?: UserLikedPlaylistOrderByWithRelationInput | UserLikedPlaylistOrderByWithRelationInput[]
    cursor?: UserLikedPlaylistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLikedPlaylistScalarFieldEnum | UserLikedPlaylistScalarFieldEnum[]
  }

  /**
   * Playlist without action
   */
  export type PlaylistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
  }


  /**
   * Model PlaylistItem
   */

  export type AggregatePlaylistItem = {
    _count: PlaylistItemCountAggregateOutputType | null
    _avg: PlaylistItemAvgAggregateOutputType | null
    _sum: PlaylistItemSumAggregateOutputType | null
    _min: PlaylistItemMinAggregateOutputType | null
    _max: PlaylistItemMaxAggregateOutputType | null
  }

  export type PlaylistItemAvgAggregateOutputType = {
    position: number | null
  }

  export type PlaylistItemSumAggregateOutputType = {
    position: number | null
  }

  export type PlaylistItemMinAggregateOutputType = {
    id: string | null
    position: number | null
    addedAt: Date | null
    playlistId: string | null
    songId: string | null
  }

  export type PlaylistItemMaxAggregateOutputType = {
    id: string | null
    position: number | null
    addedAt: Date | null
    playlistId: string | null
    songId: string | null
  }

  export type PlaylistItemCountAggregateOutputType = {
    id: number
    position: number
    addedAt: number
    playlistId: number
    songId: number
    _all: number
  }


  export type PlaylistItemAvgAggregateInputType = {
    position?: true
  }

  export type PlaylistItemSumAggregateInputType = {
    position?: true
  }

  export type PlaylistItemMinAggregateInputType = {
    id?: true
    position?: true
    addedAt?: true
    playlistId?: true
    songId?: true
  }

  export type PlaylistItemMaxAggregateInputType = {
    id?: true
    position?: true
    addedAt?: true
    playlistId?: true
    songId?: true
  }

  export type PlaylistItemCountAggregateInputType = {
    id?: true
    position?: true
    addedAt?: true
    playlistId?: true
    songId?: true
    _all?: true
  }

  export type PlaylistItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaylistItem to aggregate.
     */
    where?: PlaylistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistItems to fetch.
     */
    orderBy?: PlaylistItemOrderByWithRelationInput | PlaylistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaylistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlaylistItems
    **/
    _count?: true | PlaylistItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlaylistItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlaylistItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaylistItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaylistItemMaxAggregateInputType
  }

  export type GetPlaylistItemAggregateType<T extends PlaylistItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaylistItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaylistItem[P]>
      : GetScalarType<T[P], AggregatePlaylistItem[P]>
  }




  export type PlaylistItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistItemWhereInput
    orderBy?: PlaylistItemOrderByWithAggregationInput | PlaylistItemOrderByWithAggregationInput[]
    by: PlaylistItemScalarFieldEnum[] | PlaylistItemScalarFieldEnum
    having?: PlaylistItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlaylistItemCountAggregateInputType | true
    _avg?: PlaylistItemAvgAggregateInputType
    _sum?: PlaylistItemSumAggregateInputType
    _min?: PlaylistItemMinAggregateInputType
    _max?: PlaylistItemMaxAggregateInputType
  }

  export type PlaylistItemGroupByOutputType = {
    id: string
    position: number
    addedAt: Date
    playlistId: string
    songId: string
    _count: PlaylistItemCountAggregateOutputType | null
    _avg: PlaylistItemAvgAggregateOutputType | null
    _sum: PlaylistItemSumAggregateOutputType | null
    _min: PlaylistItemMinAggregateOutputType | null
    _max: PlaylistItemMaxAggregateOutputType | null
  }

  type GetPlaylistItemGroupByPayload<T extends PlaylistItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaylistItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaylistItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaylistItemGroupByOutputType[P]>
            : GetScalarType<T[P], PlaylistItemGroupByOutputType[P]>
        }
      >
    >


  export type PlaylistItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    position?: boolean
    addedAt?: boolean
    playlistId?: boolean
    songId?: boolean
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playlistItem"]>

  export type PlaylistItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    position?: boolean
    addedAt?: boolean
    playlistId?: boolean
    songId?: boolean
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playlistItem"]>

  export type PlaylistItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    position?: boolean
    addedAt?: boolean
    playlistId?: boolean
    songId?: boolean
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playlistItem"]>

  export type PlaylistItemSelectScalar = {
    id?: boolean
    position?: boolean
    addedAt?: boolean
    playlistId?: boolean
    songId?: boolean
  }

  export type PlaylistItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "position" | "addedAt" | "playlistId" | "songId", ExtArgs["result"]["playlistItem"]>
  export type PlaylistItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }
  export type PlaylistItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }
  export type PlaylistItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }

  export type $PlaylistItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlaylistItem"
    objects: {
      playlist: Prisma.$PlaylistPayload<ExtArgs>
      song: Prisma.$SongPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      position: number
      addedAt: Date
      playlistId: string
      songId: string
    }, ExtArgs["result"]["playlistItem"]>
    composites: {}
  }

  type PlaylistItemGetPayload<S extends boolean | null | undefined | PlaylistItemDefaultArgs> = $Result.GetResult<Prisma.$PlaylistItemPayload, S>

  type PlaylistItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlaylistItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaylistItemCountAggregateInputType | true
    }

  export interface PlaylistItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlaylistItem'], meta: { name: 'PlaylistItem' } }
    /**
     * Find zero or one PlaylistItem that matches the filter.
     * @param {PlaylistItemFindUniqueArgs} args - Arguments to find a PlaylistItem
     * @example
     * // Get one PlaylistItem
     * const playlistItem = await prisma.playlistItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaylistItemFindUniqueArgs>(args: SelectSubset<T, PlaylistItemFindUniqueArgs<ExtArgs>>): Prisma__PlaylistItemClient<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlaylistItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlaylistItemFindUniqueOrThrowArgs} args - Arguments to find a PlaylistItem
     * @example
     * // Get one PlaylistItem
     * const playlistItem = await prisma.playlistItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaylistItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaylistItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaylistItemClient<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaylistItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistItemFindFirstArgs} args - Arguments to find a PlaylistItem
     * @example
     * // Get one PlaylistItem
     * const playlistItem = await prisma.playlistItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaylistItemFindFirstArgs>(args?: SelectSubset<T, PlaylistItemFindFirstArgs<ExtArgs>>): Prisma__PlaylistItemClient<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaylistItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistItemFindFirstOrThrowArgs} args - Arguments to find a PlaylistItem
     * @example
     * // Get one PlaylistItem
     * const playlistItem = await prisma.playlistItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaylistItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaylistItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaylistItemClient<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlaylistItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlaylistItems
     * const playlistItems = await prisma.playlistItem.findMany()
     * 
     * // Get first 10 PlaylistItems
     * const playlistItems = await prisma.playlistItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playlistItemWithIdOnly = await prisma.playlistItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlaylistItemFindManyArgs>(args?: SelectSubset<T, PlaylistItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlaylistItem.
     * @param {PlaylistItemCreateArgs} args - Arguments to create a PlaylistItem.
     * @example
     * // Create one PlaylistItem
     * const PlaylistItem = await prisma.playlistItem.create({
     *   data: {
     *     // ... data to create a PlaylistItem
     *   }
     * })
     * 
     */
    create<T extends PlaylistItemCreateArgs>(args: SelectSubset<T, PlaylistItemCreateArgs<ExtArgs>>): Prisma__PlaylistItemClient<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlaylistItems.
     * @param {PlaylistItemCreateManyArgs} args - Arguments to create many PlaylistItems.
     * @example
     * // Create many PlaylistItems
     * const playlistItem = await prisma.playlistItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaylistItemCreateManyArgs>(args?: SelectSubset<T, PlaylistItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlaylistItems and returns the data saved in the database.
     * @param {PlaylistItemCreateManyAndReturnArgs} args - Arguments to create many PlaylistItems.
     * @example
     * // Create many PlaylistItems
     * const playlistItem = await prisma.playlistItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlaylistItems and only return the `id`
     * const playlistItemWithIdOnly = await prisma.playlistItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlaylistItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PlaylistItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlaylistItem.
     * @param {PlaylistItemDeleteArgs} args - Arguments to delete one PlaylistItem.
     * @example
     * // Delete one PlaylistItem
     * const PlaylistItem = await prisma.playlistItem.delete({
     *   where: {
     *     // ... filter to delete one PlaylistItem
     *   }
     * })
     * 
     */
    delete<T extends PlaylistItemDeleteArgs>(args: SelectSubset<T, PlaylistItemDeleteArgs<ExtArgs>>): Prisma__PlaylistItemClient<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlaylistItem.
     * @param {PlaylistItemUpdateArgs} args - Arguments to update one PlaylistItem.
     * @example
     * // Update one PlaylistItem
     * const playlistItem = await prisma.playlistItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaylistItemUpdateArgs>(args: SelectSubset<T, PlaylistItemUpdateArgs<ExtArgs>>): Prisma__PlaylistItemClient<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlaylistItems.
     * @param {PlaylistItemDeleteManyArgs} args - Arguments to filter PlaylistItems to delete.
     * @example
     * // Delete a few PlaylistItems
     * const { count } = await prisma.playlistItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaylistItemDeleteManyArgs>(args?: SelectSubset<T, PlaylistItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaylistItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlaylistItems
     * const playlistItem = await prisma.playlistItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaylistItemUpdateManyArgs>(args: SelectSubset<T, PlaylistItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaylistItems and returns the data updated in the database.
     * @param {PlaylistItemUpdateManyAndReturnArgs} args - Arguments to update many PlaylistItems.
     * @example
     * // Update many PlaylistItems
     * const playlistItem = await prisma.playlistItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlaylistItems and only return the `id`
     * const playlistItemWithIdOnly = await prisma.playlistItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlaylistItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PlaylistItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlaylistItem.
     * @param {PlaylistItemUpsertArgs} args - Arguments to update or create a PlaylistItem.
     * @example
     * // Update or create a PlaylistItem
     * const playlistItem = await prisma.playlistItem.upsert({
     *   create: {
     *     // ... data to create a PlaylistItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlaylistItem we want to update
     *   }
     * })
     */
    upsert<T extends PlaylistItemUpsertArgs>(args: SelectSubset<T, PlaylistItemUpsertArgs<ExtArgs>>): Prisma__PlaylistItemClient<$Result.GetResult<Prisma.$PlaylistItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlaylistItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistItemCountArgs} args - Arguments to filter PlaylistItems to count.
     * @example
     * // Count the number of PlaylistItems
     * const count = await prisma.playlistItem.count({
     *   where: {
     *     // ... the filter for the PlaylistItems we want to count
     *   }
     * })
    **/
    count<T extends PlaylistItemCountArgs>(
      args?: Subset<T, PlaylistItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaylistItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlaylistItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaylistItemAggregateArgs>(args: Subset<T, PlaylistItemAggregateArgs>): Prisma.PrismaPromise<GetPlaylistItemAggregateType<T>>

    /**
     * Group by PlaylistItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaylistItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaylistItemGroupByArgs['orderBy'] }
        : { orderBy?: PlaylistItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaylistItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaylistItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlaylistItem model
   */
  readonly fields: PlaylistItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlaylistItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaylistItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    playlist<T extends PlaylistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaylistDefaultArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    song<T extends SongDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SongDefaultArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlaylistItem model
   */
  interface PlaylistItemFieldRefs {
    readonly id: FieldRef<"PlaylistItem", 'String'>
    readonly position: FieldRef<"PlaylistItem", 'Int'>
    readonly addedAt: FieldRef<"PlaylistItem", 'DateTime'>
    readonly playlistId: FieldRef<"PlaylistItem", 'String'>
    readonly songId: FieldRef<"PlaylistItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PlaylistItem findUnique
   */
  export type PlaylistItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistItem to fetch.
     */
    where: PlaylistItemWhereUniqueInput
  }

  /**
   * PlaylistItem findUniqueOrThrow
   */
  export type PlaylistItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistItem to fetch.
     */
    where: PlaylistItemWhereUniqueInput
  }

  /**
   * PlaylistItem findFirst
   */
  export type PlaylistItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistItem to fetch.
     */
    where?: PlaylistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistItems to fetch.
     */
    orderBy?: PlaylistItemOrderByWithRelationInput | PlaylistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaylistItems.
     */
    cursor?: PlaylistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaylistItems.
     */
    distinct?: PlaylistItemScalarFieldEnum | PlaylistItemScalarFieldEnum[]
  }

  /**
   * PlaylistItem findFirstOrThrow
   */
  export type PlaylistItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistItem to fetch.
     */
    where?: PlaylistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistItems to fetch.
     */
    orderBy?: PlaylistItemOrderByWithRelationInput | PlaylistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaylistItems.
     */
    cursor?: PlaylistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaylistItems.
     */
    distinct?: PlaylistItemScalarFieldEnum | PlaylistItemScalarFieldEnum[]
  }

  /**
   * PlaylistItem findMany
   */
  export type PlaylistItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistItems to fetch.
     */
    where?: PlaylistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistItems to fetch.
     */
    orderBy?: PlaylistItemOrderByWithRelationInput | PlaylistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlaylistItems.
     */
    cursor?: PlaylistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistItems.
     */
    skip?: number
    distinct?: PlaylistItemScalarFieldEnum | PlaylistItemScalarFieldEnum[]
  }

  /**
   * PlaylistItem create
   */
  export type PlaylistItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PlaylistItem.
     */
    data: XOR<PlaylistItemCreateInput, PlaylistItemUncheckedCreateInput>
  }

  /**
   * PlaylistItem createMany
   */
  export type PlaylistItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlaylistItems.
     */
    data: PlaylistItemCreateManyInput | PlaylistItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlaylistItem createManyAndReturn
   */
  export type PlaylistItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * The data used to create many PlaylistItems.
     */
    data: PlaylistItemCreateManyInput | PlaylistItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaylistItem update
   */
  export type PlaylistItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PlaylistItem.
     */
    data: XOR<PlaylistItemUpdateInput, PlaylistItemUncheckedUpdateInput>
    /**
     * Choose, which PlaylistItem to update.
     */
    where: PlaylistItemWhereUniqueInput
  }

  /**
   * PlaylistItem updateMany
   */
  export type PlaylistItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlaylistItems.
     */
    data: XOR<PlaylistItemUpdateManyMutationInput, PlaylistItemUncheckedUpdateManyInput>
    /**
     * Filter which PlaylistItems to update
     */
    where?: PlaylistItemWhereInput
    /**
     * Limit how many PlaylistItems to update.
     */
    limit?: number
  }

  /**
   * PlaylistItem updateManyAndReturn
   */
  export type PlaylistItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * The data used to update PlaylistItems.
     */
    data: XOR<PlaylistItemUpdateManyMutationInput, PlaylistItemUncheckedUpdateManyInput>
    /**
     * Filter which PlaylistItems to update
     */
    where?: PlaylistItemWhereInput
    /**
     * Limit how many PlaylistItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaylistItem upsert
   */
  export type PlaylistItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PlaylistItem to update in case it exists.
     */
    where: PlaylistItemWhereUniqueInput
    /**
     * In case the PlaylistItem found by the `where` argument doesn't exist, create a new PlaylistItem with this data.
     */
    create: XOR<PlaylistItemCreateInput, PlaylistItemUncheckedCreateInput>
    /**
     * In case the PlaylistItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaylistItemUpdateInput, PlaylistItemUncheckedUpdateInput>
  }

  /**
   * PlaylistItem delete
   */
  export type PlaylistItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemInclude<ExtArgs> | null
    /**
     * Filter which PlaylistItem to delete.
     */
    where: PlaylistItemWhereUniqueInput
  }

  /**
   * PlaylistItem deleteMany
   */
  export type PlaylistItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaylistItems to delete
     */
    where?: PlaylistItemWhereInput
    /**
     * Limit how many PlaylistItems to delete.
     */
    limit?: number
  }

  /**
   * PlaylistItem without action
   */
  export type PlaylistItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistItem
     */
    select?: PlaylistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistItem
     */
    omit?: PlaylistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistItemInclude<ExtArgs> | null
  }


  /**
   * Model UserLikedSong
   */

  export type AggregateUserLikedSong = {
    _count: UserLikedSongCountAggregateOutputType | null
    _min: UserLikedSongMinAggregateOutputType | null
    _max: UserLikedSongMaxAggregateOutputType | null
  }

  export type UserLikedSongMinAggregateOutputType = {
    userId: string | null
    songId: string | null
    likedAt: Date | null
  }

  export type UserLikedSongMaxAggregateOutputType = {
    userId: string | null
    songId: string | null
    likedAt: Date | null
  }

  export type UserLikedSongCountAggregateOutputType = {
    userId: number
    songId: number
    likedAt: number
    _all: number
  }


  export type UserLikedSongMinAggregateInputType = {
    userId?: true
    songId?: true
    likedAt?: true
  }

  export type UserLikedSongMaxAggregateInputType = {
    userId?: true
    songId?: true
    likedAt?: true
  }

  export type UserLikedSongCountAggregateInputType = {
    userId?: true
    songId?: true
    likedAt?: true
    _all?: true
  }

  export type UserLikedSongAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLikedSong to aggregate.
     */
    where?: UserLikedSongWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLikedSongs to fetch.
     */
    orderBy?: UserLikedSongOrderByWithRelationInput | UserLikedSongOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLikedSongWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLikedSongs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLikedSongs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLikedSongs
    **/
    _count?: true | UserLikedSongCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLikedSongMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLikedSongMaxAggregateInputType
  }

  export type GetUserLikedSongAggregateType<T extends UserLikedSongAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLikedSong]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLikedSong[P]>
      : GetScalarType<T[P], AggregateUserLikedSong[P]>
  }




  export type UserLikedSongGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLikedSongWhereInput
    orderBy?: UserLikedSongOrderByWithAggregationInput | UserLikedSongOrderByWithAggregationInput[]
    by: UserLikedSongScalarFieldEnum[] | UserLikedSongScalarFieldEnum
    having?: UserLikedSongScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLikedSongCountAggregateInputType | true
    _min?: UserLikedSongMinAggregateInputType
    _max?: UserLikedSongMaxAggregateInputType
  }

  export type UserLikedSongGroupByOutputType = {
    userId: string
    songId: string
    likedAt: Date
    _count: UserLikedSongCountAggregateOutputType | null
    _min: UserLikedSongMinAggregateOutputType | null
    _max: UserLikedSongMaxAggregateOutputType | null
  }

  type GetUserLikedSongGroupByPayload<T extends UserLikedSongGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserLikedSongGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLikedSongGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLikedSongGroupByOutputType[P]>
            : GetScalarType<T[P], UserLikedSongGroupByOutputType[P]>
        }
      >
    >


  export type UserLikedSongSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    songId?: boolean
    likedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLikedSong"]>

  export type UserLikedSongSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    songId?: boolean
    likedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLikedSong"]>

  export type UserLikedSongSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    songId?: boolean
    likedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLikedSong"]>

  export type UserLikedSongSelectScalar = {
    userId?: boolean
    songId?: boolean
    likedAt?: boolean
  }

  export type UserLikedSongOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "songId" | "likedAt", ExtArgs["result"]["userLikedSong"]>
  export type UserLikedSongInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }
  export type UserLikedSongIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }
  export type UserLikedSongIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }

  export type $UserLikedSongPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserLikedSong"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      song: Prisma.$SongPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      songId: string
      likedAt: Date
    }, ExtArgs["result"]["userLikedSong"]>
    composites: {}
  }

  type UserLikedSongGetPayload<S extends boolean | null | undefined | UserLikedSongDefaultArgs> = $Result.GetResult<Prisma.$UserLikedSongPayload, S>

  type UserLikedSongCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserLikedSongFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserLikedSongCountAggregateInputType | true
    }

  export interface UserLikedSongDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLikedSong'], meta: { name: 'UserLikedSong' } }
    /**
     * Find zero or one UserLikedSong that matches the filter.
     * @param {UserLikedSongFindUniqueArgs} args - Arguments to find a UserLikedSong
     * @example
     * // Get one UserLikedSong
     * const userLikedSong = await prisma.userLikedSong.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLikedSongFindUniqueArgs>(args: SelectSubset<T, UserLikedSongFindUniqueArgs<ExtArgs>>): Prisma__UserLikedSongClient<$Result.GetResult<Prisma.$UserLikedSongPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserLikedSong that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserLikedSongFindUniqueOrThrowArgs} args - Arguments to find a UserLikedSong
     * @example
     * // Get one UserLikedSong
     * const userLikedSong = await prisma.userLikedSong.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLikedSongFindUniqueOrThrowArgs>(args: SelectSubset<T, UserLikedSongFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserLikedSongClient<$Result.GetResult<Prisma.$UserLikedSongPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLikedSong that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedSongFindFirstArgs} args - Arguments to find a UserLikedSong
     * @example
     * // Get one UserLikedSong
     * const userLikedSong = await prisma.userLikedSong.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLikedSongFindFirstArgs>(args?: SelectSubset<T, UserLikedSongFindFirstArgs<ExtArgs>>): Prisma__UserLikedSongClient<$Result.GetResult<Prisma.$UserLikedSongPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLikedSong that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedSongFindFirstOrThrowArgs} args - Arguments to find a UserLikedSong
     * @example
     * // Get one UserLikedSong
     * const userLikedSong = await prisma.userLikedSong.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLikedSongFindFirstOrThrowArgs>(args?: SelectSubset<T, UserLikedSongFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserLikedSongClient<$Result.GetResult<Prisma.$UserLikedSongPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserLikedSongs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedSongFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLikedSongs
     * const userLikedSongs = await prisma.userLikedSong.findMany()
     * 
     * // Get first 10 UserLikedSongs
     * const userLikedSongs = await prisma.userLikedSong.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userLikedSongWithUserIdOnly = await prisma.userLikedSong.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserLikedSongFindManyArgs>(args?: SelectSubset<T, UserLikedSongFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLikedSongPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserLikedSong.
     * @param {UserLikedSongCreateArgs} args - Arguments to create a UserLikedSong.
     * @example
     * // Create one UserLikedSong
     * const UserLikedSong = await prisma.userLikedSong.create({
     *   data: {
     *     // ... data to create a UserLikedSong
     *   }
     * })
     * 
     */
    create<T extends UserLikedSongCreateArgs>(args: SelectSubset<T, UserLikedSongCreateArgs<ExtArgs>>): Prisma__UserLikedSongClient<$Result.GetResult<Prisma.$UserLikedSongPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserLikedSongs.
     * @param {UserLikedSongCreateManyArgs} args - Arguments to create many UserLikedSongs.
     * @example
     * // Create many UserLikedSongs
     * const userLikedSong = await prisma.userLikedSong.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserLikedSongCreateManyArgs>(args?: SelectSubset<T, UserLikedSongCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserLikedSongs and returns the data saved in the database.
     * @param {UserLikedSongCreateManyAndReturnArgs} args - Arguments to create many UserLikedSongs.
     * @example
     * // Create many UserLikedSongs
     * const userLikedSong = await prisma.userLikedSong.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserLikedSongs and only return the `userId`
     * const userLikedSongWithUserIdOnly = await prisma.userLikedSong.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserLikedSongCreateManyAndReturnArgs>(args?: SelectSubset<T, UserLikedSongCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLikedSongPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserLikedSong.
     * @param {UserLikedSongDeleteArgs} args - Arguments to delete one UserLikedSong.
     * @example
     * // Delete one UserLikedSong
     * const UserLikedSong = await prisma.userLikedSong.delete({
     *   where: {
     *     // ... filter to delete one UserLikedSong
     *   }
     * })
     * 
     */
    delete<T extends UserLikedSongDeleteArgs>(args: SelectSubset<T, UserLikedSongDeleteArgs<ExtArgs>>): Prisma__UserLikedSongClient<$Result.GetResult<Prisma.$UserLikedSongPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserLikedSong.
     * @param {UserLikedSongUpdateArgs} args - Arguments to update one UserLikedSong.
     * @example
     * // Update one UserLikedSong
     * const userLikedSong = await prisma.userLikedSong.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserLikedSongUpdateArgs>(args: SelectSubset<T, UserLikedSongUpdateArgs<ExtArgs>>): Prisma__UserLikedSongClient<$Result.GetResult<Prisma.$UserLikedSongPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserLikedSongs.
     * @param {UserLikedSongDeleteManyArgs} args - Arguments to filter UserLikedSongs to delete.
     * @example
     * // Delete a few UserLikedSongs
     * const { count } = await prisma.userLikedSong.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserLikedSongDeleteManyArgs>(args?: SelectSubset<T, UserLikedSongDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLikedSongs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedSongUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLikedSongs
     * const userLikedSong = await prisma.userLikedSong.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserLikedSongUpdateManyArgs>(args: SelectSubset<T, UserLikedSongUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLikedSongs and returns the data updated in the database.
     * @param {UserLikedSongUpdateManyAndReturnArgs} args - Arguments to update many UserLikedSongs.
     * @example
     * // Update many UserLikedSongs
     * const userLikedSong = await prisma.userLikedSong.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserLikedSongs and only return the `userId`
     * const userLikedSongWithUserIdOnly = await prisma.userLikedSong.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserLikedSongUpdateManyAndReturnArgs>(args: SelectSubset<T, UserLikedSongUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLikedSongPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserLikedSong.
     * @param {UserLikedSongUpsertArgs} args - Arguments to update or create a UserLikedSong.
     * @example
     * // Update or create a UserLikedSong
     * const userLikedSong = await prisma.userLikedSong.upsert({
     *   create: {
     *     // ... data to create a UserLikedSong
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLikedSong we want to update
     *   }
     * })
     */
    upsert<T extends UserLikedSongUpsertArgs>(args: SelectSubset<T, UserLikedSongUpsertArgs<ExtArgs>>): Prisma__UserLikedSongClient<$Result.GetResult<Prisma.$UserLikedSongPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserLikedSongs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedSongCountArgs} args - Arguments to filter UserLikedSongs to count.
     * @example
     * // Count the number of UserLikedSongs
     * const count = await prisma.userLikedSong.count({
     *   where: {
     *     // ... the filter for the UserLikedSongs we want to count
     *   }
     * })
    **/
    count<T extends UserLikedSongCountArgs>(
      args?: Subset<T, UserLikedSongCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLikedSongCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLikedSong.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedSongAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLikedSongAggregateArgs>(args: Subset<T, UserLikedSongAggregateArgs>): Prisma.PrismaPromise<GetUserLikedSongAggregateType<T>>

    /**
     * Group by UserLikedSong.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedSongGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLikedSongGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLikedSongGroupByArgs['orderBy'] }
        : { orderBy?: UserLikedSongGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLikedSongGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLikedSongGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserLikedSong model
   */
  readonly fields: UserLikedSongFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLikedSong.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLikedSongClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    song<T extends SongDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SongDefaultArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserLikedSong model
   */
  interface UserLikedSongFieldRefs {
    readonly userId: FieldRef<"UserLikedSong", 'String'>
    readonly songId: FieldRef<"UserLikedSong", 'String'>
    readonly likedAt: FieldRef<"UserLikedSong", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserLikedSong findUnique
   */
  export type UserLikedSongFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedSong
     */
    select?: UserLikedSongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedSong
     */
    omit?: UserLikedSongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedSongInclude<ExtArgs> | null
    /**
     * Filter, which UserLikedSong to fetch.
     */
    where: UserLikedSongWhereUniqueInput
  }

  /**
   * UserLikedSong findUniqueOrThrow
   */
  export type UserLikedSongFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedSong
     */
    select?: UserLikedSongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedSong
     */
    omit?: UserLikedSongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedSongInclude<ExtArgs> | null
    /**
     * Filter, which UserLikedSong to fetch.
     */
    where: UserLikedSongWhereUniqueInput
  }

  /**
   * UserLikedSong findFirst
   */
  export type UserLikedSongFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedSong
     */
    select?: UserLikedSongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedSong
     */
    omit?: UserLikedSongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedSongInclude<ExtArgs> | null
    /**
     * Filter, which UserLikedSong to fetch.
     */
    where?: UserLikedSongWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLikedSongs to fetch.
     */
    orderBy?: UserLikedSongOrderByWithRelationInput | UserLikedSongOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLikedSongs.
     */
    cursor?: UserLikedSongWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLikedSongs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLikedSongs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLikedSongs.
     */
    distinct?: UserLikedSongScalarFieldEnum | UserLikedSongScalarFieldEnum[]
  }

  /**
   * UserLikedSong findFirstOrThrow
   */
  export type UserLikedSongFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedSong
     */
    select?: UserLikedSongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedSong
     */
    omit?: UserLikedSongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedSongInclude<ExtArgs> | null
    /**
     * Filter, which UserLikedSong to fetch.
     */
    where?: UserLikedSongWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLikedSongs to fetch.
     */
    orderBy?: UserLikedSongOrderByWithRelationInput | UserLikedSongOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLikedSongs.
     */
    cursor?: UserLikedSongWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLikedSongs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLikedSongs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLikedSongs.
     */
    distinct?: UserLikedSongScalarFieldEnum | UserLikedSongScalarFieldEnum[]
  }

  /**
   * UserLikedSong findMany
   */
  export type UserLikedSongFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedSong
     */
    select?: UserLikedSongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedSong
     */
    omit?: UserLikedSongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedSongInclude<ExtArgs> | null
    /**
     * Filter, which UserLikedSongs to fetch.
     */
    where?: UserLikedSongWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLikedSongs to fetch.
     */
    orderBy?: UserLikedSongOrderByWithRelationInput | UserLikedSongOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLikedSongs.
     */
    cursor?: UserLikedSongWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLikedSongs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLikedSongs.
     */
    skip?: number
    distinct?: UserLikedSongScalarFieldEnum | UserLikedSongScalarFieldEnum[]
  }

  /**
   * UserLikedSong create
   */
  export type UserLikedSongCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedSong
     */
    select?: UserLikedSongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedSong
     */
    omit?: UserLikedSongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedSongInclude<ExtArgs> | null
    /**
     * The data needed to create a UserLikedSong.
     */
    data: XOR<UserLikedSongCreateInput, UserLikedSongUncheckedCreateInput>
  }

  /**
   * UserLikedSong createMany
   */
  export type UserLikedSongCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserLikedSongs.
     */
    data: UserLikedSongCreateManyInput | UserLikedSongCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserLikedSong createManyAndReturn
   */
  export type UserLikedSongCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedSong
     */
    select?: UserLikedSongSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedSong
     */
    omit?: UserLikedSongOmit<ExtArgs> | null
    /**
     * The data used to create many UserLikedSongs.
     */
    data: UserLikedSongCreateManyInput | UserLikedSongCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedSongIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLikedSong update
   */
  export type UserLikedSongUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedSong
     */
    select?: UserLikedSongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedSong
     */
    omit?: UserLikedSongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedSongInclude<ExtArgs> | null
    /**
     * The data needed to update a UserLikedSong.
     */
    data: XOR<UserLikedSongUpdateInput, UserLikedSongUncheckedUpdateInput>
    /**
     * Choose, which UserLikedSong to update.
     */
    where: UserLikedSongWhereUniqueInput
  }

  /**
   * UserLikedSong updateMany
   */
  export type UserLikedSongUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserLikedSongs.
     */
    data: XOR<UserLikedSongUpdateManyMutationInput, UserLikedSongUncheckedUpdateManyInput>
    /**
     * Filter which UserLikedSongs to update
     */
    where?: UserLikedSongWhereInput
    /**
     * Limit how many UserLikedSongs to update.
     */
    limit?: number
  }

  /**
   * UserLikedSong updateManyAndReturn
   */
  export type UserLikedSongUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedSong
     */
    select?: UserLikedSongSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedSong
     */
    omit?: UserLikedSongOmit<ExtArgs> | null
    /**
     * The data used to update UserLikedSongs.
     */
    data: XOR<UserLikedSongUpdateManyMutationInput, UserLikedSongUncheckedUpdateManyInput>
    /**
     * Filter which UserLikedSongs to update
     */
    where?: UserLikedSongWhereInput
    /**
     * Limit how many UserLikedSongs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedSongIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLikedSong upsert
   */
  export type UserLikedSongUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedSong
     */
    select?: UserLikedSongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedSong
     */
    omit?: UserLikedSongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedSongInclude<ExtArgs> | null
    /**
     * The filter to search for the UserLikedSong to update in case it exists.
     */
    where: UserLikedSongWhereUniqueInput
    /**
     * In case the UserLikedSong found by the `where` argument doesn't exist, create a new UserLikedSong with this data.
     */
    create: XOR<UserLikedSongCreateInput, UserLikedSongUncheckedCreateInput>
    /**
     * In case the UserLikedSong was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLikedSongUpdateInput, UserLikedSongUncheckedUpdateInput>
  }

  /**
   * UserLikedSong delete
   */
  export type UserLikedSongDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedSong
     */
    select?: UserLikedSongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedSong
     */
    omit?: UserLikedSongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedSongInclude<ExtArgs> | null
    /**
     * Filter which UserLikedSong to delete.
     */
    where: UserLikedSongWhereUniqueInput
  }

  /**
   * UserLikedSong deleteMany
   */
  export type UserLikedSongDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLikedSongs to delete
     */
    where?: UserLikedSongWhereInput
    /**
     * Limit how many UserLikedSongs to delete.
     */
    limit?: number
  }

  /**
   * UserLikedSong without action
   */
  export type UserLikedSongDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedSong
     */
    select?: UserLikedSongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedSong
     */
    omit?: UserLikedSongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedSongInclude<ExtArgs> | null
  }


  /**
   * Model UserLikedAlbum
   */

  export type AggregateUserLikedAlbum = {
    _count: UserLikedAlbumCountAggregateOutputType | null
    _min: UserLikedAlbumMinAggregateOutputType | null
    _max: UserLikedAlbumMaxAggregateOutputType | null
  }

  export type UserLikedAlbumMinAggregateOutputType = {
    userId: string | null
    albumId: string | null
    likedAt: Date | null
  }

  export type UserLikedAlbumMaxAggregateOutputType = {
    userId: string | null
    albumId: string | null
    likedAt: Date | null
  }

  export type UserLikedAlbumCountAggregateOutputType = {
    userId: number
    albumId: number
    likedAt: number
    _all: number
  }


  export type UserLikedAlbumMinAggregateInputType = {
    userId?: true
    albumId?: true
    likedAt?: true
  }

  export type UserLikedAlbumMaxAggregateInputType = {
    userId?: true
    albumId?: true
    likedAt?: true
  }

  export type UserLikedAlbumCountAggregateInputType = {
    userId?: true
    albumId?: true
    likedAt?: true
    _all?: true
  }

  export type UserLikedAlbumAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLikedAlbum to aggregate.
     */
    where?: UserLikedAlbumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLikedAlbums to fetch.
     */
    orderBy?: UserLikedAlbumOrderByWithRelationInput | UserLikedAlbumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLikedAlbumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLikedAlbums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLikedAlbums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLikedAlbums
    **/
    _count?: true | UserLikedAlbumCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLikedAlbumMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLikedAlbumMaxAggregateInputType
  }

  export type GetUserLikedAlbumAggregateType<T extends UserLikedAlbumAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLikedAlbum]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLikedAlbum[P]>
      : GetScalarType<T[P], AggregateUserLikedAlbum[P]>
  }




  export type UserLikedAlbumGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLikedAlbumWhereInput
    orderBy?: UserLikedAlbumOrderByWithAggregationInput | UserLikedAlbumOrderByWithAggregationInput[]
    by: UserLikedAlbumScalarFieldEnum[] | UserLikedAlbumScalarFieldEnum
    having?: UserLikedAlbumScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLikedAlbumCountAggregateInputType | true
    _min?: UserLikedAlbumMinAggregateInputType
    _max?: UserLikedAlbumMaxAggregateInputType
  }

  export type UserLikedAlbumGroupByOutputType = {
    userId: string
    albumId: string
    likedAt: Date
    _count: UserLikedAlbumCountAggregateOutputType | null
    _min: UserLikedAlbumMinAggregateOutputType | null
    _max: UserLikedAlbumMaxAggregateOutputType | null
  }

  type GetUserLikedAlbumGroupByPayload<T extends UserLikedAlbumGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserLikedAlbumGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLikedAlbumGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLikedAlbumGroupByOutputType[P]>
            : GetScalarType<T[P], UserLikedAlbumGroupByOutputType[P]>
        }
      >
    >


  export type UserLikedAlbumSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    albumId?: boolean
    likedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    album?: boolean | AlbumDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLikedAlbum"]>

  export type UserLikedAlbumSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    albumId?: boolean
    likedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    album?: boolean | AlbumDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLikedAlbum"]>

  export type UserLikedAlbumSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    albumId?: boolean
    likedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    album?: boolean | AlbumDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLikedAlbum"]>

  export type UserLikedAlbumSelectScalar = {
    userId?: boolean
    albumId?: boolean
    likedAt?: boolean
  }

  export type UserLikedAlbumOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "albumId" | "likedAt", ExtArgs["result"]["userLikedAlbum"]>
  export type UserLikedAlbumInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    album?: boolean | AlbumDefaultArgs<ExtArgs>
  }
  export type UserLikedAlbumIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    album?: boolean | AlbumDefaultArgs<ExtArgs>
  }
  export type UserLikedAlbumIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    album?: boolean | AlbumDefaultArgs<ExtArgs>
  }

  export type $UserLikedAlbumPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserLikedAlbum"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      album: Prisma.$AlbumPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      albumId: string
      likedAt: Date
    }, ExtArgs["result"]["userLikedAlbum"]>
    composites: {}
  }

  type UserLikedAlbumGetPayload<S extends boolean | null | undefined | UserLikedAlbumDefaultArgs> = $Result.GetResult<Prisma.$UserLikedAlbumPayload, S>

  type UserLikedAlbumCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserLikedAlbumFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserLikedAlbumCountAggregateInputType | true
    }

  export interface UserLikedAlbumDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLikedAlbum'], meta: { name: 'UserLikedAlbum' } }
    /**
     * Find zero or one UserLikedAlbum that matches the filter.
     * @param {UserLikedAlbumFindUniqueArgs} args - Arguments to find a UserLikedAlbum
     * @example
     * // Get one UserLikedAlbum
     * const userLikedAlbum = await prisma.userLikedAlbum.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLikedAlbumFindUniqueArgs>(args: SelectSubset<T, UserLikedAlbumFindUniqueArgs<ExtArgs>>): Prisma__UserLikedAlbumClient<$Result.GetResult<Prisma.$UserLikedAlbumPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserLikedAlbum that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserLikedAlbumFindUniqueOrThrowArgs} args - Arguments to find a UserLikedAlbum
     * @example
     * // Get one UserLikedAlbum
     * const userLikedAlbum = await prisma.userLikedAlbum.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLikedAlbumFindUniqueOrThrowArgs>(args: SelectSubset<T, UserLikedAlbumFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserLikedAlbumClient<$Result.GetResult<Prisma.$UserLikedAlbumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLikedAlbum that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedAlbumFindFirstArgs} args - Arguments to find a UserLikedAlbum
     * @example
     * // Get one UserLikedAlbum
     * const userLikedAlbum = await prisma.userLikedAlbum.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLikedAlbumFindFirstArgs>(args?: SelectSubset<T, UserLikedAlbumFindFirstArgs<ExtArgs>>): Prisma__UserLikedAlbumClient<$Result.GetResult<Prisma.$UserLikedAlbumPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLikedAlbum that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedAlbumFindFirstOrThrowArgs} args - Arguments to find a UserLikedAlbum
     * @example
     * // Get one UserLikedAlbum
     * const userLikedAlbum = await prisma.userLikedAlbum.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLikedAlbumFindFirstOrThrowArgs>(args?: SelectSubset<T, UserLikedAlbumFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserLikedAlbumClient<$Result.GetResult<Prisma.$UserLikedAlbumPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserLikedAlbums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedAlbumFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLikedAlbums
     * const userLikedAlbums = await prisma.userLikedAlbum.findMany()
     * 
     * // Get first 10 UserLikedAlbums
     * const userLikedAlbums = await prisma.userLikedAlbum.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userLikedAlbumWithUserIdOnly = await prisma.userLikedAlbum.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserLikedAlbumFindManyArgs>(args?: SelectSubset<T, UserLikedAlbumFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLikedAlbumPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserLikedAlbum.
     * @param {UserLikedAlbumCreateArgs} args - Arguments to create a UserLikedAlbum.
     * @example
     * // Create one UserLikedAlbum
     * const UserLikedAlbum = await prisma.userLikedAlbum.create({
     *   data: {
     *     // ... data to create a UserLikedAlbum
     *   }
     * })
     * 
     */
    create<T extends UserLikedAlbumCreateArgs>(args: SelectSubset<T, UserLikedAlbumCreateArgs<ExtArgs>>): Prisma__UserLikedAlbumClient<$Result.GetResult<Prisma.$UserLikedAlbumPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserLikedAlbums.
     * @param {UserLikedAlbumCreateManyArgs} args - Arguments to create many UserLikedAlbums.
     * @example
     * // Create many UserLikedAlbums
     * const userLikedAlbum = await prisma.userLikedAlbum.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserLikedAlbumCreateManyArgs>(args?: SelectSubset<T, UserLikedAlbumCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserLikedAlbums and returns the data saved in the database.
     * @param {UserLikedAlbumCreateManyAndReturnArgs} args - Arguments to create many UserLikedAlbums.
     * @example
     * // Create many UserLikedAlbums
     * const userLikedAlbum = await prisma.userLikedAlbum.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserLikedAlbums and only return the `userId`
     * const userLikedAlbumWithUserIdOnly = await prisma.userLikedAlbum.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserLikedAlbumCreateManyAndReturnArgs>(args?: SelectSubset<T, UserLikedAlbumCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLikedAlbumPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserLikedAlbum.
     * @param {UserLikedAlbumDeleteArgs} args - Arguments to delete one UserLikedAlbum.
     * @example
     * // Delete one UserLikedAlbum
     * const UserLikedAlbum = await prisma.userLikedAlbum.delete({
     *   where: {
     *     // ... filter to delete one UserLikedAlbum
     *   }
     * })
     * 
     */
    delete<T extends UserLikedAlbumDeleteArgs>(args: SelectSubset<T, UserLikedAlbumDeleteArgs<ExtArgs>>): Prisma__UserLikedAlbumClient<$Result.GetResult<Prisma.$UserLikedAlbumPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserLikedAlbum.
     * @param {UserLikedAlbumUpdateArgs} args - Arguments to update one UserLikedAlbum.
     * @example
     * // Update one UserLikedAlbum
     * const userLikedAlbum = await prisma.userLikedAlbum.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserLikedAlbumUpdateArgs>(args: SelectSubset<T, UserLikedAlbumUpdateArgs<ExtArgs>>): Prisma__UserLikedAlbumClient<$Result.GetResult<Prisma.$UserLikedAlbumPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserLikedAlbums.
     * @param {UserLikedAlbumDeleteManyArgs} args - Arguments to filter UserLikedAlbums to delete.
     * @example
     * // Delete a few UserLikedAlbums
     * const { count } = await prisma.userLikedAlbum.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserLikedAlbumDeleteManyArgs>(args?: SelectSubset<T, UserLikedAlbumDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLikedAlbums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedAlbumUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLikedAlbums
     * const userLikedAlbum = await prisma.userLikedAlbum.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserLikedAlbumUpdateManyArgs>(args: SelectSubset<T, UserLikedAlbumUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLikedAlbums and returns the data updated in the database.
     * @param {UserLikedAlbumUpdateManyAndReturnArgs} args - Arguments to update many UserLikedAlbums.
     * @example
     * // Update many UserLikedAlbums
     * const userLikedAlbum = await prisma.userLikedAlbum.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserLikedAlbums and only return the `userId`
     * const userLikedAlbumWithUserIdOnly = await prisma.userLikedAlbum.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserLikedAlbumUpdateManyAndReturnArgs>(args: SelectSubset<T, UserLikedAlbumUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLikedAlbumPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserLikedAlbum.
     * @param {UserLikedAlbumUpsertArgs} args - Arguments to update or create a UserLikedAlbum.
     * @example
     * // Update or create a UserLikedAlbum
     * const userLikedAlbum = await prisma.userLikedAlbum.upsert({
     *   create: {
     *     // ... data to create a UserLikedAlbum
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLikedAlbum we want to update
     *   }
     * })
     */
    upsert<T extends UserLikedAlbumUpsertArgs>(args: SelectSubset<T, UserLikedAlbumUpsertArgs<ExtArgs>>): Prisma__UserLikedAlbumClient<$Result.GetResult<Prisma.$UserLikedAlbumPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserLikedAlbums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedAlbumCountArgs} args - Arguments to filter UserLikedAlbums to count.
     * @example
     * // Count the number of UserLikedAlbums
     * const count = await prisma.userLikedAlbum.count({
     *   where: {
     *     // ... the filter for the UserLikedAlbums we want to count
     *   }
     * })
    **/
    count<T extends UserLikedAlbumCountArgs>(
      args?: Subset<T, UserLikedAlbumCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLikedAlbumCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLikedAlbum.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedAlbumAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLikedAlbumAggregateArgs>(args: Subset<T, UserLikedAlbumAggregateArgs>): Prisma.PrismaPromise<GetUserLikedAlbumAggregateType<T>>

    /**
     * Group by UserLikedAlbum.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedAlbumGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLikedAlbumGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLikedAlbumGroupByArgs['orderBy'] }
        : { orderBy?: UserLikedAlbumGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLikedAlbumGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLikedAlbumGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserLikedAlbum model
   */
  readonly fields: UserLikedAlbumFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLikedAlbum.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLikedAlbumClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    album<T extends AlbumDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlbumDefaultArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserLikedAlbum model
   */
  interface UserLikedAlbumFieldRefs {
    readonly userId: FieldRef<"UserLikedAlbum", 'String'>
    readonly albumId: FieldRef<"UserLikedAlbum", 'String'>
    readonly likedAt: FieldRef<"UserLikedAlbum", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserLikedAlbum findUnique
   */
  export type UserLikedAlbumFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedAlbum
     */
    select?: UserLikedAlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedAlbum
     */
    omit?: UserLikedAlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedAlbumInclude<ExtArgs> | null
    /**
     * Filter, which UserLikedAlbum to fetch.
     */
    where: UserLikedAlbumWhereUniqueInput
  }

  /**
   * UserLikedAlbum findUniqueOrThrow
   */
  export type UserLikedAlbumFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedAlbum
     */
    select?: UserLikedAlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedAlbum
     */
    omit?: UserLikedAlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedAlbumInclude<ExtArgs> | null
    /**
     * Filter, which UserLikedAlbum to fetch.
     */
    where: UserLikedAlbumWhereUniqueInput
  }

  /**
   * UserLikedAlbum findFirst
   */
  export type UserLikedAlbumFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedAlbum
     */
    select?: UserLikedAlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedAlbum
     */
    omit?: UserLikedAlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedAlbumInclude<ExtArgs> | null
    /**
     * Filter, which UserLikedAlbum to fetch.
     */
    where?: UserLikedAlbumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLikedAlbums to fetch.
     */
    orderBy?: UserLikedAlbumOrderByWithRelationInput | UserLikedAlbumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLikedAlbums.
     */
    cursor?: UserLikedAlbumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLikedAlbums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLikedAlbums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLikedAlbums.
     */
    distinct?: UserLikedAlbumScalarFieldEnum | UserLikedAlbumScalarFieldEnum[]
  }

  /**
   * UserLikedAlbum findFirstOrThrow
   */
  export type UserLikedAlbumFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedAlbum
     */
    select?: UserLikedAlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedAlbum
     */
    omit?: UserLikedAlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedAlbumInclude<ExtArgs> | null
    /**
     * Filter, which UserLikedAlbum to fetch.
     */
    where?: UserLikedAlbumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLikedAlbums to fetch.
     */
    orderBy?: UserLikedAlbumOrderByWithRelationInput | UserLikedAlbumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLikedAlbums.
     */
    cursor?: UserLikedAlbumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLikedAlbums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLikedAlbums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLikedAlbums.
     */
    distinct?: UserLikedAlbumScalarFieldEnum | UserLikedAlbumScalarFieldEnum[]
  }

  /**
   * UserLikedAlbum findMany
   */
  export type UserLikedAlbumFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedAlbum
     */
    select?: UserLikedAlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedAlbum
     */
    omit?: UserLikedAlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedAlbumInclude<ExtArgs> | null
    /**
     * Filter, which UserLikedAlbums to fetch.
     */
    where?: UserLikedAlbumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLikedAlbums to fetch.
     */
    orderBy?: UserLikedAlbumOrderByWithRelationInput | UserLikedAlbumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLikedAlbums.
     */
    cursor?: UserLikedAlbumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLikedAlbums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLikedAlbums.
     */
    skip?: number
    distinct?: UserLikedAlbumScalarFieldEnum | UserLikedAlbumScalarFieldEnum[]
  }

  /**
   * UserLikedAlbum create
   */
  export type UserLikedAlbumCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedAlbum
     */
    select?: UserLikedAlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedAlbum
     */
    omit?: UserLikedAlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedAlbumInclude<ExtArgs> | null
    /**
     * The data needed to create a UserLikedAlbum.
     */
    data: XOR<UserLikedAlbumCreateInput, UserLikedAlbumUncheckedCreateInput>
  }

  /**
   * UserLikedAlbum createMany
   */
  export type UserLikedAlbumCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserLikedAlbums.
     */
    data: UserLikedAlbumCreateManyInput | UserLikedAlbumCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserLikedAlbum createManyAndReturn
   */
  export type UserLikedAlbumCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedAlbum
     */
    select?: UserLikedAlbumSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedAlbum
     */
    omit?: UserLikedAlbumOmit<ExtArgs> | null
    /**
     * The data used to create many UserLikedAlbums.
     */
    data: UserLikedAlbumCreateManyInput | UserLikedAlbumCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedAlbumIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLikedAlbum update
   */
  export type UserLikedAlbumUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedAlbum
     */
    select?: UserLikedAlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedAlbum
     */
    omit?: UserLikedAlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedAlbumInclude<ExtArgs> | null
    /**
     * The data needed to update a UserLikedAlbum.
     */
    data: XOR<UserLikedAlbumUpdateInput, UserLikedAlbumUncheckedUpdateInput>
    /**
     * Choose, which UserLikedAlbum to update.
     */
    where: UserLikedAlbumWhereUniqueInput
  }

  /**
   * UserLikedAlbum updateMany
   */
  export type UserLikedAlbumUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserLikedAlbums.
     */
    data: XOR<UserLikedAlbumUpdateManyMutationInput, UserLikedAlbumUncheckedUpdateManyInput>
    /**
     * Filter which UserLikedAlbums to update
     */
    where?: UserLikedAlbumWhereInput
    /**
     * Limit how many UserLikedAlbums to update.
     */
    limit?: number
  }

  /**
   * UserLikedAlbum updateManyAndReturn
   */
  export type UserLikedAlbumUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedAlbum
     */
    select?: UserLikedAlbumSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedAlbum
     */
    omit?: UserLikedAlbumOmit<ExtArgs> | null
    /**
     * The data used to update UserLikedAlbums.
     */
    data: XOR<UserLikedAlbumUpdateManyMutationInput, UserLikedAlbumUncheckedUpdateManyInput>
    /**
     * Filter which UserLikedAlbums to update
     */
    where?: UserLikedAlbumWhereInput
    /**
     * Limit how many UserLikedAlbums to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedAlbumIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLikedAlbum upsert
   */
  export type UserLikedAlbumUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedAlbum
     */
    select?: UserLikedAlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedAlbum
     */
    omit?: UserLikedAlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedAlbumInclude<ExtArgs> | null
    /**
     * The filter to search for the UserLikedAlbum to update in case it exists.
     */
    where: UserLikedAlbumWhereUniqueInput
    /**
     * In case the UserLikedAlbum found by the `where` argument doesn't exist, create a new UserLikedAlbum with this data.
     */
    create: XOR<UserLikedAlbumCreateInput, UserLikedAlbumUncheckedCreateInput>
    /**
     * In case the UserLikedAlbum was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLikedAlbumUpdateInput, UserLikedAlbumUncheckedUpdateInput>
  }

  /**
   * UserLikedAlbum delete
   */
  export type UserLikedAlbumDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedAlbum
     */
    select?: UserLikedAlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedAlbum
     */
    omit?: UserLikedAlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedAlbumInclude<ExtArgs> | null
    /**
     * Filter which UserLikedAlbum to delete.
     */
    where: UserLikedAlbumWhereUniqueInput
  }

  /**
   * UserLikedAlbum deleteMany
   */
  export type UserLikedAlbumDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLikedAlbums to delete
     */
    where?: UserLikedAlbumWhereInput
    /**
     * Limit how many UserLikedAlbums to delete.
     */
    limit?: number
  }

  /**
   * UserLikedAlbum without action
   */
  export type UserLikedAlbumDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedAlbum
     */
    select?: UserLikedAlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedAlbum
     */
    omit?: UserLikedAlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedAlbumInclude<ExtArgs> | null
  }


  /**
   * Model UserLikedArtist
   */

  export type AggregateUserLikedArtist = {
    _count: UserLikedArtistCountAggregateOutputType | null
    _min: UserLikedArtistMinAggregateOutputType | null
    _max: UserLikedArtistMaxAggregateOutputType | null
  }

  export type UserLikedArtistMinAggregateOutputType = {
    userId: string | null
    artistId: string | null
    likedAt: Date | null
  }

  export type UserLikedArtistMaxAggregateOutputType = {
    userId: string | null
    artistId: string | null
    likedAt: Date | null
  }

  export type UserLikedArtistCountAggregateOutputType = {
    userId: number
    artistId: number
    likedAt: number
    _all: number
  }


  export type UserLikedArtistMinAggregateInputType = {
    userId?: true
    artistId?: true
    likedAt?: true
  }

  export type UserLikedArtistMaxAggregateInputType = {
    userId?: true
    artistId?: true
    likedAt?: true
  }

  export type UserLikedArtistCountAggregateInputType = {
    userId?: true
    artistId?: true
    likedAt?: true
    _all?: true
  }

  export type UserLikedArtistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLikedArtist to aggregate.
     */
    where?: UserLikedArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLikedArtists to fetch.
     */
    orderBy?: UserLikedArtistOrderByWithRelationInput | UserLikedArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLikedArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLikedArtists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLikedArtists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLikedArtists
    **/
    _count?: true | UserLikedArtistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLikedArtistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLikedArtistMaxAggregateInputType
  }

  export type GetUserLikedArtistAggregateType<T extends UserLikedArtistAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLikedArtist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLikedArtist[P]>
      : GetScalarType<T[P], AggregateUserLikedArtist[P]>
  }




  export type UserLikedArtistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLikedArtistWhereInput
    orderBy?: UserLikedArtistOrderByWithAggregationInput | UserLikedArtistOrderByWithAggregationInput[]
    by: UserLikedArtistScalarFieldEnum[] | UserLikedArtistScalarFieldEnum
    having?: UserLikedArtistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLikedArtistCountAggregateInputType | true
    _min?: UserLikedArtistMinAggregateInputType
    _max?: UserLikedArtistMaxAggregateInputType
  }

  export type UserLikedArtistGroupByOutputType = {
    userId: string
    artistId: string
    likedAt: Date
    _count: UserLikedArtistCountAggregateOutputType | null
    _min: UserLikedArtistMinAggregateOutputType | null
    _max: UserLikedArtistMaxAggregateOutputType | null
  }

  type GetUserLikedArtistGroupByPayload<T extends UserLikedArtistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserLikedArtistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLikedArtistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLikedArtistGroupByOutputType[P]>
            : GetScalarType<T[P], UserLikedArtistGroupByOutputType[P]>
        }
      >
    >


  export type UserLikedArtistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    artistId?: boolean
    likedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLikedArtist"]>

  export type UserLikedArtistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    artistId?: boolean
    likedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLikedArtist"]>

  export type UserLikedArtistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    artistId?: boolean
    likedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLikedArtist"]>

  export type UserLikedArtistSelectScalar = {
    userId?: boolean
    artistId?: boolean
    likedAt?: boolean
  }

  export type UserLikedArtistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "artistId" | "likedAt", ExtArgs["result"]["userLikedArtist"]>
  export type UserLikedArtistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
  }
  export type UserLikedArtistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
  }
  export type UserLikedArtistIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
  }

  export type $UserLikedArtistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserLikedArtist"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      artist: Prisma.$ArtistPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      artistId: string
      likedAt: Date
    }, ExtArgs["result"]["userLikedArtist"]>
    composites: {}
  }

  type UserLikedArtistGetPayload<S extends boolean | null | undefined | UserLikedArtistDefaultArgs> = $Result.GetResult<Prisma.$UserLikedArtistPayload, S>

  type UserLikedArtistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserLikedArtistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserLikedArtistCountAggregateInputType | true
    }

  export interface UserLikedArtistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLikedArtist'], meta: { name: 'UserLikedArtist' } }
    /**
     * Find zero or one UserLikedArtist that matches the filter.
     * @param {UserLikedArtistFindUniqueArgs} args - Arguments to find a UserLikedArtist
     * @example
     * // Get one UserLikedArtist
     * const userLikedArtist = await prisma.userLikedArtist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLikedArtistFindUniqueArgs>(args: SelectSubset<T, UserLikedArtistFindUniqueArgs<ExtArgs>>): Prisma__UserLikedArtistClient<$Result.GetResult<Prisma.$UserLikedArtistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserLikedArtist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserLikedArtistFindUniqueOrThrowArgs} args - Arguments to find a UserLikedArtist
     * @example
     * // Get one UserLikedArtist
     * const userLikedArtist = await prisma.userLikedArtist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLikedArtistFindUniqueOrThrowArgs>(args: SelectSubset<T, UserLikedArtistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserLikedArtistClient<$Result.GetResult<Prisma.$UserLikedArtistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLikedArtist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedArtistFindFirstArgs} args - Arguments to find a UserLikedArtist
     * @example
     * // Get one UserLikedArtist
     * const userLikedArtist = await prisma.userLikedArtist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLikedArtistFindFirstArgs>(args?: SelectSubset<T, UserLikedArtistFindFirstArgs<ExtArgs>>): Prisma__UserLikedArtistClient<$Result.GetResult<Prisma.$UserLikedArtistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLikedArtist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedArtistFindFirstOrThrowArgs} args - Arguments to find a UserLikedArtist
     * @example
     * // Get one UserLikedArtist
     * const userLikedArtist = await prisma.userLikedArtist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLikedArtistFindFirstOrThrowArgs>(args?: SelectSubset<T, UserLikedArtistFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserLikedArtistClient<$Result.GetResult<Prisma.$UserLikedArtistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserLikedArtists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedArtistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLikedArtists
     * const userLikedArtists = await prisma.userLikedArtist.findMany()
     * 
     * // Get first 10 UserLikedArtists
     * const userLikedArtists = await prisma.userLikedArtist.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userLikedArtistWithUserIdOnly = await prisma.userLikedArtist.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserLikedArtistFindManyArgs>(args?: SelectSubset<T, UserLikedArtistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLikedArtistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserLikedArtist.
     * @param {UserLikedArtistCreateArgs} args - Arguments to create a UserLikedArtist.
     * @example
     * // Create one UserLikedArtist
     * const UserLikedArtist = await prisma.userLikedArtist.create({
     *   data: {
     *     // ... data to create a UserLikedArtist
     *   }
     * })
     * 
     */
    create<T extends UserLikedArtistCreateArgs>(args: SelectSubset<T, UserLikedArtistCreateArgs<ExtArgs>>): Prisma__UserLikedArtistClient<$Result.GetResult<Prisma.$UserLikedArtistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserLikedArtists.
     * @param {UserLikedArtistCreateManyArgs} args - Arguments to create many UserLikedArtists.
     * @example
     * // Create many UserLikedArtists
     * const userLikedArtist = await prisma.userLikedArtist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserLikedArtistCreateManyArgs>(args?: SelectSubset<T, UserLikedArtistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserLikedArtists and returns the data saved in the database.
     * @param {UserLikedArtistCreateManyAndReturnArgs} args - Arguments to create many UserLikedArtists.
     * @example
     * // Create many UserLikedArtists
     * const userLikedArtist = await prisma.userLikedArtist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserLikedArtists and only return the `userId`
     * const userLikedArtistWithUserIdOnly = await prisma.userLikedArtist.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserLikedArtistCreateManyAndReturnArgs>(args?: SelectSubset<T, UserLikedArtistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLikedArtistPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserLikedArtist.
     * @param {UserLikedArtistDeleteArgs} args - Arguments to delete one UserLikedArtist.
     * @example
     * // Delete one UserLikedArtist
     * const UserLikedArtist = await prisma.userLikedArtist.delete({
     *   where: {
     *     // ... filter to delete one UserLikedArtist
     *   }
     * })
     * 
     */
    delete<T extends UserLikedArtistDeleteArgs>(args: SelectSubset<T, UserLikedArtistDeleteArgs<ExtArgs>>): Prisma__UserLikedArtistClient<$Result.GetResult<Prisma.$UserLikedArtistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserLikedArtist.
     * @param {UserLikedArtistUpdateArgs} args - Arguments to update one UserLikedArtist.
     * @example
     * // Update one UserLikedArtist
     * const userLikedArtist = await prisma.userLikedArtist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserLikedArtistUpdateArgs>(args: SelectSubset<T, UserLikedArtistUpdateArgs<ExtArgs>>): Prisma__UserLikedArtistClient<$Result.GetResult<Prisma.$UserLikedArtistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserLikedArtists.
     * @param {UserLikedArtistDeleteManyArgs} args - Arguments to filter UserLikedArtists to delete.
     * @example
     * // Delete a few UserLikedArtists
     * const { count } = await prisma.userLikedArtist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserLikedArtistDeleteManyArgs>(args?: SelectSubset<T, UserLikedArtistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLikedArtists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedArtistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLikedArtists
     * const userLikedArtist = await prisma.userLikedArtist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserLikedArtistUpdateManyArgs>(args: SelectSubset<T, UserLikedArtistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLikedArtists and returns the data updated in the database.
     * @param {UserLikedArtistUpdateManyAndReturnArgs} args - Arguments to update many UserLikedArtists.
     * @example
     * // Update many UserLikedArtists
     * const userLikedArtist = await prisma.userLikedArtist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserLikedArtists and only return the `userId`
     * const userLikedArtistWithUserIdOnly = await prisma.userLikedArtist.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserLikedArtistUpdateManyAndReturnArgs>(args: SelectSubset<T, UserLikedArtistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLikedArtistPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserLikedArtist.
     * @param {UserLikedArtistUpsertArgs} args - Arguments to update or create a UserLikedArtist.
     * @example
     * // Update or create a UserLikedArtist
     * const userLikedArtist = await prisma.userLikedArtist.upsert({
     *   create: {
     *     // ... data to create a UserLikedArtist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLikedArtist we want to update
     *   }
     * })
     */
    upsert<T extends UserLikedArtistUpsertArgs>(args: SelectSubset<T, UserLikedArtistUpsertArgs<ExtArgs>>): Prisma__UserLikedArtistClient<$Result.GetResult<Prisma.$UserLikedArtistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserLikedArtists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedArtistCountArgs} args - Arguments to filter UserLikedArtists to count.
     * @example
     * // Count the number of UserLikedArtists
     * const count = await prisma.userLikedArtist.count({
     *   where: {
     *     // ... the filter for the UserLikedArtists we want to count
     *   }
     * })
    **/
    count<T extends UserLikedArtistCountArgs>(
      args?: Subset<T, UserLikedArtistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLikedArtistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLikedArtist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedArtistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLikedArtistAggregateArgs>(args: Subset<T, UserLikedArtistAggregateArgs>): Prisma.PrismaPromise<GetUserLikedArtistAggregateType<T>>

    /**
     * Group by UserLikedArtist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedArtistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLikedArtistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLikedArtistGroupByArgs['orderBy'] }
        : { orderBy?: UserLikedArtistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLikedArtistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLikedArtistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserLikedArtist model
   */
  readonly fields: UserLikedArtistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLikedArtist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLikedArtistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    artist<T extends ArtistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArtistDefaultArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserLikedArtist model
   */
  interface UserLikedArtistFieldRefs {
    readonly userId: FieldRef<"UserLikedArtist", 'String'>
    readonly artistId: FieldRef<"UserLikedArtist", 'String'>
    readonly likedAt: FieldRef<"UserLikedArtist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserLikedArtist findUnique
   */
  export type UserLikedArtistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedArtist
     */
    select?: UserLikedArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedArtist
     */
    omit?: UserLikedArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedArtistInclude<ExtArgs> | null
    /**
     * Filter, which UserLikedArtist to fetch.
     */
    where: UserLikedArtistWhereUniqueInput
  }

  /**
   * UserLikedArtist findUniqueOrThrow
   */
  export type UserLikedArtistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedArtist
     */
    select?: UserLikedArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedArtist
     */
    omit?: UserLikedArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedArtistInclude<ExtArgs> | null
    /**
     * Filter, which UserLikedArtist to fetch.
     */
    where: UserLikedArtistWhereUniqueInput
  }

  /**
   * UserLikedArtist findFirst
   */
  export type UserLikedArtistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedArtist
     */
    select?: UserLikedArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedArtist
     */
    omit?: UserLikedArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedArtistInclude<ExtArgs> | null
    /**
     * Filter, which UserLikedArtist to fetch.
     */
    where?: UserLikedArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLikedArtists to fetch.
     */
    orderBy?: UserLikedArtistOrderByWithRelationInput | UserLikedArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLikedArtists.
     */
    cursor?: UserLikedArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLikedArtists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLikedArtists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLikedArtists.
     */
    distinct?: UserLikedArtistScalarFieldEnum | UserLikedArtistScalarFieldEnum[]
  }

  /**
   * UserLikedArtist findFirstOrThrow
   */
  export type UserLikedArtistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedArtist
     */
    select?: UserLikedArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedArtist
     */
    omit?: UserLikedArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedArtistInclude<ExtArgs> | null
    /**
     * Filter, which UserLikedArtist to fetch.
     */
    where?: UserLikedArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLikedArtists to fetch.
     */
    orderBy?: UserLikedArtistOrderByWithRelationInput | UserLikedArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLikedArtists.
     */
    cursor?: UserLikedArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLikedArtists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLikedArtists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLikedArtists.
     */
    distinct?: UserLikedArtistScalarFieldEnum | UserLikedArtistScalarFieldEnum[]
  }

  /**
   * UserLikedArtist findMany
   */
  export type UserLikedArtistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedArtist
     */
    select?: UserLikedArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedArtist
     */
    omit?: UserLikedArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedArtistInclude<ExtArgs> | null
    /**
     * Filter, which UserLikedArtists to fetch.
     */
    where?: UserLikedArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLikedArtists to fetch.
     */
    orderBy?: UserLikedArtistOrderByWithRelationInput | UserLikedArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLikedArtists.
     */
    cursor?: UserLikedArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLikedArtists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLikedArtists.
     */
    skip?: number
    distinct?: UserLikedArtistScalarFieldEnum | UserLikedArtistScalarFieldEnum[]
  }

  /**
   * UserLikedArtist create
   */
  export type UserLikedArtistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedArtist
     */
    select?: UserLikedArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedArtist
     */
    omit?: UserLikedArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedArtistInclude<ExtArgs> | null
    /**
     * The data needed to create a UserLikedArtist.
     */
    data: XOR<UserLikedArtistCreateInput, UserLikedArtistUncheckedCreateInput>
  }

  /**
   * UserLikedArtist createMany
   */
  export type UserLikedArtistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserLikedArtists.
     */
    data: UserLikedArtistCreateManyInput | UserLikedArtistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserLikedArtist createManyAndReturn
   */
  export type UserLikedArtistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedArtist
     */
    select?: UserLikedArtistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedArtist
     */
    omit?: UserLikedArtistOmit<ExtArgs> | null
    /**
     * The data used to create many UserLikedArtists.
     */
    data: UserLikedArtistCreateManyInput | UserLikedArtistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedArtistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLikedArtist update
   */
  export type UserLikedArtistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedArtist
     */
    select?: UserLikedArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedArtist
     */
    omit?: UserLikedArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedArtistInclude<ExtArgs> | null
    /**
     * The data needed to update a UserLikedArtist.
     */
    data: XOR<UserLikedArtistUpdateInput, UserLikedArtistUncheckedUpdateInput>
    /**
     * Choose, which UserLikedArtist to update.
     */
    where: UserLikedArtistWhereUniqueInput
  }

  /**
   * UserLikedArtist updateMany
   */
  export type UserLikedArtistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserLikedArtists.
     */
    data: XOR<UserLikedArtistUpdateManyMutationInput, UserLikedArtistUncheckedUpdateManyInput>
    /**
     * Filter which UserLikedArtists to update
     */
    where?: UserLikedArtistWhereInput
    /**
     * Limit how many UserLikedArtists to update.
     */
    limit?: number
  }

  /**
   * UserLikedArtist updateManyAndReturn
   */
  export type UserLikedArtistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedArtist
     */
    select?: UserLikedArtistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedArtist
     */
    omit?: UserLikedArtistOmit<ExtArgs> | null
    /**
     * The data used to update UserLikedArtists.
     */
    data: XOR<UserLikedArtistUpdateManyMutationInput, UserLikedArtistUncheckedUpdateManyInput>
    /**
     * Filter which UserLikedArtists to update
     */
    where?: UserLikedArtistWhereInput
    /**
     * Limit how many UserLikedArtists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedArtistIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLikedArtist upsert
   */
  export type UserLikedArtistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedArtist
     */
    select?: UserLikedArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedArtist
     */
    omit?: UserLikedArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedArtistInclude<ExtArgs> | null
    /**
     * The filter to search for the UserLikedArtist to update in case it exists.
     */
    where: UserLikedArtistWhereUniqueInput
    /**
     * In case the UserLikedArtist found by the `where` argument doesn't exist, create a new UserLikedArtist with this data.
     */
    create: XOR<UserLikedArtistCreateInput, UserLikedArtistUncheckedCreateInput>
    /**
     * In case the UserLikedArtist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLikedArtistUpdateInput, UserLikedArtistUncheckedUpdateInput>
  }

  /**
   * UserLikedArtist delete
   */
  export type UserLikedArtistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedArtist
     */
    select?: UserLikedArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedArtist
     */
    omit?: UserLikedArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedArtistInclude<ExtArgs> | null
    /**
     * Filter which UserLikedArtist to delete.
     */
    where: UserLikedArtistWhereUniqueInput
  }

  /**
   * UserLikedArtist deleteMany
   */
  export type UserLikedArtistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLikedArtists to delete
     */
    where?: UserLikedArtistWhereInput
    /**
     * Limit how many UserLikedArtists to delete.
     */
    limit?: number
  }

  /**
   * UserLikedArtist without action
   */
  export type UserLikedArtistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedArtist
     */
    select?: UserLikedArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedArtist
     */
    omit?: UserLikedArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedArtistInclude<ExtArgs> | null
  }


  /**
   * Model UserLikedPlaylist
   */

  export type AggregateUserLikedPlaylist = {
    _count: UserLikedPlaylistCountAggregateOutputType | null
    _min: UserLikedPlaylistMinAggregateOutputType | null
    _max: UserLikedPlaylistMaxAggregateOutputType | null
  }

  export type UserLikedPlaylistMinAggregateOutputType = {
    userId: string | null
    playlistId: string | null
    likedAt: Date | null
  }

  export type UserLikedPlaylistMaxAggregateOutputType = {
    userId: string | null
    playlistId: string | null
    likedAt: Date | null
  }

  export type UserLikedPlaylistCountAggregateOutputType = {
    userId: number
    playlistId: number
    likedAt: number
    _all: number
  }


  export type UserLikedPlaylistMinAggregateInputType = {
    userId?: true
    playlistId?: true
    likedAt?: true
  }

  export type UserLikedPlaylistMaxAggregateInputType = {
    userId?: true
    playlistId?: true
    likedAt?: true
  }

  export type UserLikedPlaylistCountAggregateInputType = {
    userId?: true
    playlistId?: true
    likedAt?: true
    _all?: true
  }

  export type UserLikedPlaylistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLikedPlaylist to aggregate.
     */
    where?: UserLikedPlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLikedPlaylists to fetch.
     */
    orderBy?: UserLikedPlaylistOrderByWithRelationInput | UserLikedPlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLikedPlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLikedPlaylists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLikedPlaylists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLikedPlaylists
    **/
    _count?: true | UserLikedPlaylistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLikedPlaylistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLikedPlaylistMaxAggregateInputType
  }

  export type GetUserLikedPlaylistAggregateType<T extends UserLikedPlaylistAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLikedPlaylist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLikedPlaylist[P]>
      : GetScalarType<T[P], AggregateUserLikedPlaylist[P]>
  }




  export type UserLikedPlaylistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLikedPlaylistWhereInput
    orderBy?: UserLikedPlaylistOrderByWithAggregationInput | UserLikedPlaylistOrderByWithAggregationInput[]
    by: UserLikedPlaylistScalarFieldEnum[] | UserLikedPlaylistScalarFieldEnum
    having?: UserLikedPlaylistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLikedPlaylistCountAggregateInputType | true
    _min?: UserLikedPlaylistMinAggregateInputType
    _max?: UserLikedPlaylistMaxAggregateInputType
  }

  export type UserLikedPlaylistGroupByOutputType = {
    userId: string
    playlistId: string
    likedAt: Date
    _count: UserLikedPlaylistCountAggregateOutputType | null
    _min: UserLikedPlaylistMinAggregateOutputType | null
    _max: UserLikedPlaylistMaxAggregateOutputType | null
  }

  type GetUserLikedPlaylistGroupByPayload<T extends UserLikedPlaylistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserLikedPlaylistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLikedPlaylistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLikedPlaylistGroupByOutputType[P]>
            : GetScalarType<T[P], UserLikedPlaylistGroupByOutputType[P]>
        }
      >
    >


  export type UserLikedPlaylistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    playlistId?: boolean
    likedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLikedPlaylist"]>

  export type UserLikedPlaylistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    playlistId?: boolean
    likedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLikedPlaylist"]>

  export type UserLikedPlaylistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    playlistId?: boolean
    likedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLikedPlaylist"]>

  export type UserLikedPlaylistSelectScalar = {
    userId?: boolean
    playlistId?: boolean
    likedAt?: boolean
  }

  export type UserLikedPlaylistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "playlistId" | "likedAt", ExtArgs["result"]["userLikedPlaylist"]>
  export type UserLikedPlaylistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
  }
  export type UserLikedPlaylistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
  }
  export type UserLikedPlaylistIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
  }

  export type $UserLikedPlaylistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserLikedPlaylist"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      playlist: Prisma.$PlaylistPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      playlistId: string
      likedAt: Date
    }, ExtArgs["result"]["userLikedPlaylist"]>
    composites: {}
  }

  type UserLikedPlaylistGetPayload<S extends boolean | null | undefined | UserLikedPlaylistDefaultArgs> = $Result.GetResult<Prisma.$UserLikedPlaylistPayload, S>

  type UserLikedPlaylistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserLikedPlaylistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserLikedPlaylistCountAggregateInputType | true
    }

  export interface UserLikedPlaylistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLikedPlaylist'], meta: { name: 'UserLikedPlaylist' } }
    /**
     * Find zero or one UserLikedPlaylist that matches the filter.
     * @param {UserLikedPlaylistFindUniqueArgs} args - Arguments to find a UserLikedPlaylist
     * @example
     * // Get one UserLikedPlaylist
     * const userLikedPlaylist = await prisma.userLikedPlaylist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLikedPlaylistFindUniqueArgs>(args: SelectSubset<T, UserLikedPlaylistFindUniqueArgs<ExtArgs>>): Prisma__UserLikedPlaylistClient<$Result.GetResult<Prisma.$UserLikedPlaylistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserLikedPlaylist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserLikedPlaylistFindUniqueOrThrowArgs} args - Arguments to find a UserLikedPlaylist
     * @example
     * // Get one UserLikedPlaylist
     * const userLikedPlaylist = await prisma.userLikedPlaylist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLikedPlaylistFindUniqueOrThrowArgs>(args: SelectSubset<T, UserLikedPlaylistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserLikedPlaylistClient<$Result.GetResult<Prisma.$UserLikedPlaylistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLikedPlaylist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedPlaylistFindFirstArgs} args - Arguments to find a UserLikedPlaylist
     * @example
     * // Get one UserLikedPlaylist
     * const userLikedPlaylist = await prisma.userLikedPlaylist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLikedPlaylistFindFirstArgs>(args?: SelectSubset<T, UserLikedPlaylistFindFirstArgs<ExtArgs>>): Prisma__UserLikedPlaylistClient<$Result.GetResult<Prisma.$UserLikedPlaylistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLikedPlaylist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedPlaylistFindFirstOrThrowArgs} args - Arguments to find a UserLikedPlaylist
     * @example
     * // Get one UserLikedPlaylist
     * const userLikedPlaylist = await prisma.userLikedPlaylist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLikedPlaylistFindFirstOrThrowArgs>(args?: SelectSubset<T, UserLikedPlaylistFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserLikedPlaylistClient<$Result.GetResult<Prisma.$UserLikedPlaylistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserLikedPlaylists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedPlaylistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLikedPlaylists
     * const userLikedPlaylists = await prisma.userLikedPlaylist.findMany()
     * 
     * // Get first 10 UserLikedPlaylists
     * const userLikedPlaylists = await prisma.userLikedPlaylist.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userLikedPlaylistWithUserIdOnly = await prisma.userLikedPlaylist.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserLikedPlaylistFindManyArgs>(args?: SelectSubset<T, UserLikedPlaylistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLikedPlaylistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserLikedPlaylist.
     * @param {UserLikedPlaylistCreateArgs} args - Arguments to create a UserLikedPlaylist.
     * @example
     * // Create one UserLikedPlaylist
     * const UserLikedPlaylist = await prisma.userLikedPlaylist.create({
     *   data: {
     *     // ... data to create a UserLikedPlaylist
     *   }
     * })
     * 
     */
    create<T extends UserLikedPlaylistCreateArgs>(args: SelectSubset<T, UserLikedPlaylistCreateArgs<ExtArgs>>): Prisma__UserLikedPlaylistClient<$Result.GetResult<Prisma.$UserLikedPlaylistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserLikedPlaylists.
     * @param {UserLikedPlaylistCreateManyArgs} args - Arguments to create many UserLikedPlaylists.
     * @example
     * // Create many UserLikedPlaylists
     * const userLikedPlaylist = await prisma.userLikedPlaylist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserLikedPlaylistCreateManyArgs>(args?: SelectSubset<T, UserLikedPlaylistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserLikedPlaylists and returns the data saved in the database.
     * @param {UserLikedPlaylistCreateManyAndReturnArgs} args - Arguments to create many UserLikedPlaylists.
     * @example
     * // Create many UserLikedPlaylists
     * const userLikedPlaylist = await prisma.userLikedPlaylist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserLikedPlaylists and only return the `userId`
     * const userLikedPlaylistWithUserIdOnly = await prisma.userLikedPlaylist.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserLikedPlaylistCreateManyAndReturnArgs>(args?: SelectSubset<T, UserLikedPlaylistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLikedPlaylistPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserLikedPlaylist.
     * @param {UserLikedPlaylistDeleteArgs} args - Arguments to delete one UserLikedPlaylist.
     * @example
     * // Delete one UserLikedPlaylist
     * const UserLikedPlaylist = await prisma.userLikedPlaylist.delete({
     *   where: {
     *     // ... filter to delete one UserLikedPlaylist
     *   }
     * })
     * 
     */
    delete<T extends UserLikedPlaylistDeleteArgs>(args: SelectSubset<T, UserLikedPlaylistDeleteArgs<ExtArgs>>): Prisma__UserLikedPlaylistClient<$Result.GetResult<Prisma.$UserLikedPlaylistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserLikedPlaylist.
     * @param {UserLikedPlaylistUpdateArgs} args - Arguments to update one UserLikedPlaylist.
     * @example
     * // Update one UserLikedPlaylist
     * const userLikedPlaylist = await prisma.userLikedPlaylist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserLikedPlaylistUpdateArgs>(args: SelectSubset<T, UserLikedPlaylistUpdateArgs<ExtArgs>>): Prisma__UserLikedPlaylistClient<$Result.GetResult<Prisma.$UserLikedPlaylistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserLikedPlaylists.
     * @param {UserLikedPlaylistDeleteManyArgs} args - Arguments to filter UserLikedPlaylists to delete.
     * @example
     * // Delete a few UserLikedPlaylists
     * const { count } = await prisma.userLikedPlaylist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserLikedPlaylistDeleteManyArgs>(args?: SelectSubset<T, UserLikedPlaylistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLikedPlaylists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedPlaylistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLikedPlaylists
     * const userLikedPlaylist = await prisma.userLikedPlaylist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserLikedPlaylistUpdateManyArgs>(args: SelectSubset<T, UserLikedPlaylistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLikedPlaylists and returns the data updated in the database.
     * @param {UserLikedPlaylistUpdateManyAndReturnArgs} args - Arguments to update many UserLikedPlaylists.
     * @example
     * // Update many UserLikedPlaylists
     * const userLikedPlaylist = await prisma.userLikedPlaylist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserLikedPlaylists and only return the `userId`
     * const userLikedPlaylistWithUserIdOnly = await prisma.userLikedPlaylist.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserLikedPlaylistUpdateManyAndReturnArgs>(args: SelectSubset<T, UserLikedPlaylistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLikedPlaylistPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserLikedPlaylist.
     * @param {UserLikedPlaylistUpsertArgs} args - Arguments to update or create a UserLikedPlaylist.
     * @example
     * // Update or create a UserLikedPlaylist
     * const userLikedPlaylist = await prisma.userLikedPlaylist.upsert({
     *   create: {
     *     // ... data to create a UserLikedPlaylist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLikedPlaylist we want to update
     *   }
     * })
     */
    upsert<T extends UserLikedPlaylistUpsertArgs>(args: SelectSubset<T, UserLikedPlaylistUpsertArgs<ExtArgs>>): Prisma__UserLikedPlaylistClient<$Result.GetResult<Prisma.$UserLikedPlaylistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserLikedPlaylists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedPlaylistCountArgs} args - Arguments to filter UserLikedPlaylists to count.
     * @example
     * // Count the number of UserLikedPlaylists
     * const count = await prisma.userLikedPlaylist.count({
     *   where: {
     *     // ... the filter for the UserLikedPlaylists we want to count
     *   }
     * })
    **/
    count<T extends UserLikedPlaylistCountArgs>(
      args?: Subset<T, UserLikedPlaylistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLikedPlaylistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLikedPlaylist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedPlaylistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLikedPlaylistAggregateArgs>(args: Subset<T, UserLikedPlaylistAggregateArgs>): Prisma.PrismaPromise<GetUserLikedPlaylistAggregateType<T>>

    /**
     * Group by UserLikedPlaylist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikedPlaylistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLikedPlaylistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLikedPlaylistGroupByArgs['orderBy'] }
        : { orderBy?: UserLikedPlaylistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLikedPlaylistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLikedPlaylistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserLikedPlaylist model
   */
  readonly fields: UserLikedPlaylistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLikedPlaylist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLikedPlaylistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    playlist<T extends PlaylistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaylistDefaultArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserLikedPlaylist model
   */
  interface UserLikedPlaylistFieldRefs {
    readonly userId: FieldRef<"UserLikedPlaylist", 'String'>
    readonly playlistId: FieldRef<"UserLikedPlaylist", 'String'>
    readonly likedAt: FieldRef<"UserLikedPlaylist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserLikedPlaylist findUnique
   */
  export type UserLikedPlaylistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedPlaylist
     */
    select?: UserLikedPlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedPlaylist
     */
    omit?: UserLikedPlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedPlaylistInclude<ExtArgs> | null
    /**
     * Filter, which UserLikedPlaylist to fetch.
     */
    where: UserLikedPlaylistWhereUniqueInput
  }

  /**
   * UserLikedPlaylist findUniqueOrThrow
   */
  export type UserLikedPlaylistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedPlaylist
     */
    select?: UserLikedPlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedPlaylist
     */
    omit?: UserLikedPlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedPlaylistInclude<ExtArgs> | null
    /**
     * Filter, which UserLikedPlaylist to fetch.
     */
    where: UserLikedPlaylistWhereUniqueInput
  }

  /**
   * UserLikedPlaylist findFirst
   */
  export type UserLikedPlaylistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedPlaylist
     */
    select?: UserLikedPlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedPlaylist
     */
    omit?: UserLikedPlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedPlaylistInclude<ExtArgs> | null
    /**
     * Filter, which UserLikedPlaylist to fetch.
     */
    where?: UserLikedPlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLikedPlaylists to fetch.
     */
    orderBy?: UserLikedPlaylistOrderByWithRelationInput | UserLikedPlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLikedPlaylists.
     */
    cursor?: UserLikedPlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLikedPlaylists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLikedPlaylists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLikedPlaylists.
     */
    distinct?: UserLikedPlaylistScalarFieldEnum | UserLikedPlaylistScalarFieldEnum[]
  }

  /**
   * UserLikedPlaylist findFirstOrThrow
   */
  export type UserLikedPlaylistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedPlaylist
     */
    select?: UserLikedPlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedPlaylist
     */
    omit?: UserLikedPlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedPlaylistInclude<ExtArgs> | null
    /**
     * Filter, which UserLikedPlaylist to fetch.
     */
    where?: UserLikedPlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLikedPlaylists to fetch.
     */
    orderBy?: UserLikedPlaylistOrderByWithRelationInput | UserLikedPlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLikedPlaylists.
     */
    cursor?: UserLikedPlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLikedPlaylists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLikedPlaylists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLikedPlaylists.
     */
    distinct?: UserLikedPlaylistScalarFieldEnum | UserLikedPlaylistScalarFieldEnum[]
  }

  /**
   * UserLikedPlaylist findMany
   */
  export type UserLikedPlaylistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedPlaylist
     */
    select?: UserLikedPlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedPlaylist
     */
    omit?: UserLikedPlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedPlaylistInclude<ExtArgs> | null
    /**
     * Filter, which UserLikedPlaylists to fetch.
     */
    where?: UserLikedPlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLikedPlaylists to fetch.
     */
    orderBy?: UserLikedPlaylistOrderByWithRelationInput | UserLikedPlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLikedPlaylists.
     */
    cursor?: UserLikedPlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLikedPlaylists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLikedPlaylists.
     */
    skip?: number
    distinct?: UserLikedPlaylistScalarFieldEnum | UserLikedPlaylistScalarFieldEnum[]
  }

  /**
   * UserLikedPlaylist create
   */
  export type UserLikedPlaylistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedPlaylist
     */
    select?: UserLikedPlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedPlaylist
     */
    omit?: UserLikedPlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedPlaylistInclude<ExtArgs> | null
    /**
     * The data needed to create a UserLikedPlaylist.
     */
    data: XOR<UserLikedPlaylistCreateInput, UserLikedPlaylistUncheckedCreateInput>
  }

  /**
   * UserLikedPlaylist createMany
   */
  export type UserLikedPlaylistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserLikedPlaylists.
     */
    data: UserLikedPlaylistCreateManyInput | UserLikedPlaylistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserLikedPlaylist createManyAndReturn
   */
  export type UserLikedPlaylistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedPlaylist
     */
    select?: UserLikedPlaylistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedPlaylist
     */
    omit?: UserLikedPlaylistOmit<ExtArgs> | null
    /**
     * The data used to create many UserLikedPlaylists.
     */
    data: UserLikedPlaylistCreateManyInput | UserLikedPlaylistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedPlaylistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLikedPlaylist update
   */
  export type UserLikedPlaylistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedPlaylist
     */
    select?: UserLikedPlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedPlaylist
     */
    omit?: UserLikedPlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedPlaylistInclude<ExtArgs> | null
    /**
     * The data needed to update a UserLikedPlaylist.
     */
    data: XOR<UserLikedPlaylistUpdateInput, UserLikedPlaylistUncheckedUpdateInput>
    /**
     * Choose, which UserLikedPlaylist to update.
     */
    where: UserLikedPlaylistWhereUniqueInput
  }

  /**
   * UserLikedPlaylist updateMany
   */
  export type UserLikedPlaylistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserLikedPlaylists.
     */
    data: XOR<UserLikedPlaylistUpdateManyMutationInput, UserLikedPlaylistUncheckedUpdateManyInput>
    /**
     * Filter which UserLikedPlaylists to update
     */
    where?: UserLikedPlaylistWhereInput
    /**
     * Limit how many UserLikedPlaylists to update.
     */
    limit?: number
  }

  /**
   * UserLikedPlaylist updateManyAndReturn
   */
  export type UserLikedPlaylistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedPlaylist
     */
    select?: UserLikedPlaylistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedPlaylist
     */
    omit?: UserLikedPlaylistOmit<ExtArgs> | null
    /**
     * The data used to update UserLikedPlaylists.
     */
    data: XOR<UserLikedPlaylistUpdateManyMutationInput, UserLikedPlaylistUncheckedUpdateManyInput>
    /**
     * Filter which UserLikedPlaylists to update
     */
    where?: UserLikedPlaylistWhereInput
    /**
     * Limit how many UserLikedPlaylists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedPlaylistIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLikedPlaylist upsert
   */
  export type UserLikedPlaylistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedPlaylist
     */
    select?: UserLikedPlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedPlaylist
     */
    omit?: UserLikedPlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedPlaylistInclude<ExtArgs> | null
    /**
     * The filter to search for the UserLikedPlaylist to update in case it exists.
     */
    where: UserLikedPlaylistWhereUniqueInput
    /**
     * In case the UserLikedPlaylist found by the `where` argument doesn't exist, create a new UserLikedPlaylist with this data.
     */
    create: XOR<UserLikedPlaylistCreateInput, UserLikedPlaylistUncheckedCreateInput>
    /**
     * In case the UserLikedPlaylist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLikedPlaylistUpdateInput, UserLikedPlaylistUncheckedUpdateInput>
  }

  /**
   * UserLikedPlaylist delete
   */
  export type UserLikedPlaylistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedPlaylist
     */
    select?: UserLikedPlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedPlaylist
     */
    omit?: UserLikedPlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedPlaylistInclude<ExtArgs> | null
    /**
     * Filter which UserLikedPlaylist to delete.
     */
    where: UserLikedPlaylistWhereUniqueInput
  }

  /**
   * UserLikedPlaylist deleteMany
   */
  export type UserLikedPlaylistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLikedPlaylists to delete
     */
    where?: UserLikedPlaylistWhereInput
    /**
     * Limit how many UserLikedPlaylists to delete.
     */
    limit?: number
  }

  /**
   * UserLikedPlaylist without action
   */
  export type UserLikedPlaylistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLikedPlaylist
     */
    select?: UserLikedPlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLikedPlaylist
     */
    omit?: UserLikedPlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLikedPlaylistInclude<ExtArgs> | null
  }


  /**
   * Model UserFollow
   */

  export type AggregateUserFollow = {
    _count: UserFollowCountAggregateOutputType | null
    _min: UserFollowMinAggregateOutputType | null
    _max: UserFollowMaxAggregateOutputType | null
  }

  export type UserFollowMinAggregateOutputType = {
    followerId: string | null
    followingId: string | null
    followedAt: Date | null
  }

  export type UserFollowMaxAggregateOutputType = {
    followerId: string | null
    followingId: string | null
    followedAt: Date | null
  }

  export type UserFollowCountAggregateOutputType = {
    followerId: number
    followingId: number
    followedAt: number
    _all: number
  }


  export type UserFollowMinAggregateInputType = {
    followerId?: true
    followingId?: true
    followedAt?: true
  }

  export type UserFollowMaxAggregateInputType = {
    followerId?: true
    followingId?: true
    followedAt?: true
  }

  export type UserFollowCountAggregateInputType = {
    followerId?: true
    followingId?: true
    followedAt?: true
    _all?: true
  }

  export type UserFollowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFollow to aggregate.
     */
    where?: UserFollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFollows to fetch.
     */
    orderBy?: UserFollowOrderByWithRelationInput | UserFollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFollows
    **/
    _count?: true | UserFollowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFollowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFollowMaxAggregateInputType
  }

  export type GetUserFollowAggregateType<T extends UserFollowAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFollow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFollow[P]>
      : GetScalarType<T[P], AggregateUserFollow[P]>
  }




  export type UserFollowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFollowWhereInput
    orderBy?: UserFollowOrderByWithAggregationInput | UserFollowOrderByWithAggregationInput[]
    by: UserFollowScalarFieldEnum[] | UserFollowScalarFieldEnum
    having?: UserFollowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFollowCountAggregateInputType | true
    _min?: UserFollowMinAggregateInputType
    _max?: UserFollowMaxAggregateInputType
  }

  export type UserFollowGroupByOutputType = {
    followerId: string
    followingId: string
    followedAt: Date
    _count: UserFollowCountAggregateOutputType | null
    _min: UserFollowMinAggregateOutputType | null
    _max: UserFollowMaxAggregateOutputType | null
  }

  type GetUserFollowGroupByPayload<T extends UserFollowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFollowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFollowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFollowGroupByOutputType[P]>
            : GetScalarType<T[P], UserFollowGroupByOutputType[P]>
        }
      >
    >


  export type UserFollowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    followerId?: boolean
    followingId?: boolean
    followedAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFollow"]>

  export type UserFollowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    followerId?: boolean
    followingId?: boolean
    followedAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFollow"]>

  export type UserFollowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    followerId?: boolean
    followingId?: boolean
    followedAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFollow"]>

  export type UserFollowSelectScalar = {
    followerId?: boolean
    followingId?: boolean
    followedAt?: boolean
  }

  export type UserFollowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"followerId" | "followingId" | "followedAt", ExtArgs["result"]["userFollow"]>
  export type UserFollowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserFollowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserFollowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserFollowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFollow"
    objects: {
      follower: Prisma.$UserPayload<ExtArgs>
      following: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      followerId: string
      followingId: string
      followedAt: Date
    }, ExtArgs["result"]["userFollow"]>
    composites: {}
  }

  type UserFollowGetPayload<S extends boolean | null | undefined | UserFollowDefaultArgs> = $Result.GetResult<Prisma.$UserFollowPayload, S>

  type UserFollowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFollowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserFollowCountAggregateInputType | true
    }

  export interface UserFollowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFollow'], meta: { name: 'UserFollow' } }
    /**
     * Find zero or one UserFollow that matches the filter.
     * @param {UserFollowFindUniqueArgs} args - Arguments to find a UserFollow
     * @example
     * // Get one UserFollow
     * const userFollow = await prisma.userFollow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFollowFindUniqueArgs>(args: SelectSubset<T, UserFollowFindUniqueArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserFollow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFollowFindUniqueOrThrowArgs} args - Arguments to find a UserFollow
     * @example
     * // Get one UserFollow
     * const userFollow = await prisma.userFollow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFollowFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFollowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFollow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowFindFirstArgs} args - Arguments to find a UserFollow
     * @example
     * // Get one UserFollow
     * const userFollow = await prisma.userFollow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFollowFindFirstArgs>(args?: SelectSubset<T, UserFollowFindFirstArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFollow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowFindFirstOrThrowArgs} args - Arguments to find a UserFollow
     * @example
     * // Get one UserFollow
     * const userFollow = await prisma.userFollow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFollowFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFollowFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserFollows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFollows
     * const userFollows = await prisma.userFollow.findMany()
     * 
     * // Get first 10 UserFollows
     * const userFollows = await prisma.userFollow.findMany({ take: 10 })
     * 
     * // Only select the `followerId`
     * const userFollowWithFollowerIdOnly = await prisma.userFollow.findMany({ select: { followerId: true } })
     * 
     */
    findMany<T extends UserFollowFindManyArgs>(args?: SelectSubset<T, UserFollowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserFollow.
     * @param {UserFollowCreateArgs} args - Arguments to create a UserFollow.
     * @example
     * // Create one UserFollow
     * const UserFollow = await prisma.userFollow.create({
     *   data: {
     *     // ... data to create a UserFollow
     *   }
     * })
     * 
     */
    create<T extends UserFollowCreateArgs>(args: SelectSubset<T, UserFollowCreateArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserFollows.
     * @param {UserFollowCreateManyArgs} args - Arguments to create many UserFollows.
     * @example
     * // Create many UserFollows
     * const userFollow = await prisma.userFollow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFollowCreateManyArgs>(args?: SelectSubset<T, UserFollowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserFollows and returns the data saved in the database.
     * @param {UserFollowCreateManyAndReturnArgs} args - Arguments to create many UserFollows.
     * @example
     * // Create many UserFollows
     * const userFollow = await prisma.userFollow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserFollows and only return the `followerId`
     * const userFollowWithFollowerIdOnly = await prisma.userFollow.createManyAndReturn({
     *   select: { followerId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserFollowCreateManyAndReturnArgs>(args?: SelectSubset<T, UserFollowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserFollow.
     * @param {UserFollowDeleteArgs} args - Arguments to delete one UserFollow.
     * @example
     * // Delete one UserFollow
     * const UserFollow = await prisma.userFollow.delete({
     *   where: {
     *     // ... filter to delete one UserFollow
     *   }
     * })
     * 
     */
    delete<T extends UserFollowDeleteArgs>(args: SelectSubset<T, UserFollowDeleteArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserFollow.
     * @param {UserFollowUpdateArgs} args - Arguments to update one UserFollow.
     * @example
     * // Update one UserFollow
     * const userFollow = await prisma.userFollow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFollowUpdateArgs>(args: SelectSubset<T, UserFollowUpdateArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserFollows.
     * @param {UserFollowDeleteManyArgs} args - Arguments to filter UserFollows to delete.
     * @example
     * // Delete a few UserFollows
     * const { count } = await prisma.userFollow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFollowDeleteManyArgs>(args?: SelectSubset<T, UserFollowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFollows
     * const userFollow = await prisma.userFollow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFollowUpdateManyArgs>(args: SelectSubset<T, UserFollowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFollows and returns the data updated in the database.
     * @param {UserFollowUpdateManyAndReturnArgs} args - Arguments to update many UserFollows.
     * @example
     * // Update many UserFollows
     * const userFollow = await prisma.userFollow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserFollows and only return the `followerId`
     * const userFollowWithFollowerIdOnly = await prisma.userFollow.updateManyAndReturn({
     *   select: { followerId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserFollowUpdateManyAndReturnArgs>(args: SelectSubset<T, UserFollowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserFollow.
     * @param {UserFollowUpsertArgs} args - Arguments to update or create a UserFollow.
     * @example
     * // Update or create a UserFollow
     * const userFollow = await prisma.userFollow.upsert({
     *   create: {
     *     // ... data to create a UserFollow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFollow we want to update
     *   }
     * })
     */
    upsert<T extends UserFollowUpsertArgs>(args: SelectSubset<T, UserFollowUpsertArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowCountArgs} args - Arguments to filter UserFollows to count.
     * @example
     * // Count the number of UserFollows
     * const count = await prisma.userFollow.count({
     *   where: {
     *     // ... the filter for the UserFollows we want to count
     *   }
     * })
    **/
    count<T extends UserFollowCountArgs>(
      args?: Subset<T, UserFollowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFollowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFollow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFollowAggregateArgs>(args: Subset<T, UserFollowAggregateArgs>): Prisma.PrismaPromise<GetUserFollowAggregateType<T>>

    /**
     * Group by UserFollow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFollowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFollowGroupByArgs['orderBy'] }
        : { orderBy?: UserFollowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFollowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFollowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFollow model
   */
  readonly fields: UserFollowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFollow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFollowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    follower<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    following<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFollow model
   */
  interface UserFollowFieldRefs {
    readonly followerId: FieldRef<"UserFollow", 'String'>
    readonly followingId: FieldRef<"UserFollow", 'String'>
    readonly followedAt: FieldRef<"UserFollow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserFollow findUnique
   */
  export type UserFollowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * Filter, which UserFollow to fetch.
     */
    where: UserFollowWhereUniqueInput
  }

  /**
   * UserFollow findUniqueOrThrow
   */
  export type UserFollowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * Filter, which UserFollow to fetch.
     */
    where: UserFollowWhereUniqueInput
  }

  /**
   * UserFollow findFirst
   */
  export type UserFollowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * Filter, which UserFollow to fetch.
     */
    where?: UserFollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFollows to fetch.
     */
    orderBy?: UserFollowOrderByWithRelationInput | UserFollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFollows.
     */
    cursor?: UserFollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFollows.
     */
    distinct?: UserFollowScalarFieldEnum | UserFollowScalarFieldEnum[]
  }

  /**
   * UserFollow findFirstOrThrow
   */
  export type UserFollowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * Filter, which UserFollow to fetch.
     */
    where?: UserFollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFollows to fetch.
     */
    orderBy?: UserFollowOrderByWithRelationInput | UserFollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFollows.
     */
    cursor?: UserFollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFollows.
     */
    distinct?: UserFollowScalarFieldEnum | UserFollowScalarFieldEnum[]
  }

  /**
   * UserFollow findMany
   */
  export type UserFollowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * Filter, which UserFollows to fetch.
     */
    where?: UserFollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFollows to fetch.
     */
    orderBy?: UserFollowOrderByWithRelationInput | UserFollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFollows.
     */
    cursor?: UserFollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFollows.
     */
    skip?: number
    distinct?: UserFollowScalarFieldEnum | UserFollowScalarFieldEnum[]
  }

  /**
   * UserFollow create
   */
  export type UserFollowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * The data needed to create a UserFollow.
     */
    data: XOR<UserFollowCreateInput, UserFollowUncheckedCreateInput>
  }

  /**
   * UserFollow createMany
   */
  export type UserFollowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFollows.
     */
    data: UserFollowCreateManyInput | UserFollowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFollow createManyAndReturn
   */
  export type UserFollowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * The data used to create many UserFollows.
     */
    data: UserFollowCreateManyInput | UserFollowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFollow update
   */
  export type UserFollowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * The data needed to update a UserFollow.
     */
    data: XOR<UserFollowUpdateInput, UserFollowUncheckedUpdateInput>
    /**
     * Choose, which UserFollow to update.
     */
    where: UserFollowWhereUniqueInput
  }

  /**
   * UserFollow updateMany
   */
  export type UserFollowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFollows.
     */
    data: XOR<UserFollowUpdateManyMutationInput, UserFollowUncheckedUpdateManyInput>
    /**
     * Filter which UserFollows to update
     */
    where?: UserFollowWhereInput
    /**
     * Limit how many UserFollows to update.
     */
    limit?: number
  }

  /**
   * UserFollow updateManyAndReturn
   */
  export type UserFollowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * The data used to update UserFollows.
     */
    data: XOR<UserFollowUpdateManyMutationInput, UserFollowUncheckedUpdateManyInput>
    /**
     * Filter which UserFollows to update
     */
    where?: UserFollowWhereInput
    /**
     * Limit how many UserFollows to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFollow upsert
   */
  export type UserFollowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * The filter to search for the UserFollow to update in case it exists.
     */
    where: UserFollowWhereUniqueInput
    /**
     * In case the UserFollow found by the `where` argument doesn't exist, create a new UserFollow with this data.
     */
    create: XOR<UserFollowCreateInput, UserFollowUncheckedCreateInput>
    /**
     * In case the UserFollow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFollowUpdateInput, UserFollowUncheckedUpdateInput>
  }

  /**
   * UserFollow delete
   */
  export type UserFollowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * Filter which UserFollow to delete.
     */
    where: UserFollowWhereUniqueInput
  }

  /**
   * UserFollow deleteMany
   */
  export type UserFollowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFollows to delete
     */
    where?: UserFollowWhereInput
    /**
     * Limit how many UserFollows to delete.
     */
    limit?: number
  }

  /**
   * UserFollow without action
   */
  export type UserFollowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
  }


  /**
   * Model PlayHistory
   */

  export type AggregatePlayHistory = {
    _count: PlayHistoryCountAggregateOutputType | null
    _avg: PlayHistoryAvgAggregateOutputType | null
    _sum: PlayHistorySumAggregateOutputType | null
    _min: PlayHistoryMinAggregateOutputType | null
    _max: PlayHistoryMaxAggregateOutputType | null
  }

  export type PlayHistoryAvgAggregateOutputType = {
    duration: number | null
  }

  export type PlayHistorySumAggregateOutputType = {
    duration: number | null
  }

  export type PlayHistoryMinAggregateOutputType = {
    id: string | null
    playedAt: Date | null
    duration: number | null
    deviceType: string | null
    userId: string | null
    songId: string | null
  }

  export type PlayHistoryMaxAggregateOutputType = {
    id: string | null
    playedAt: Date | null
    duration: number | null
    deviceType: string | null
    userId: string | null
    songId: string | null
  }

  export type PlayHistoryCountAggregateOutputType = {
    id: number
    playedAt: number
    duration: number
    deviceType: number
    userId: number
    songId: number
    _all: number
  }


  export type PlayHistoryAvgAggregateInputType = {
    duration?: true
  }

  export type PlayHistorySumAggregateInputType = {
    duration?: true
  }

  export type PlayHistoryMinAggregateInputType = {
    id?: true
    playedAt?: true
    duration?: true
    deviceType?: true
    userId?: true
    songId?: true
  }

  export type PlayHistoryMaxAggregateInputType = {
    id?: true
    playedAt?: true
    duration?: true
    deviceType?: true
    userId?: true
    songId?: true
  }

  export type PlayHistoryCountAggregateInputType = {
    id?: true
    playedAt?: true
    duration?: true
    deviceType?: true
    userId?: true
    songId?: true
    _all?: true
  }

  export type PlayHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayHistory to aggregate.
     */
    where?: PlayHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayHistories to fetch.
     */
    orderBy?: PlayHistoryOrderByWithRelationInput | PlayHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayHistories
    **/
    _count?: true | PlayHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayHistoryMaxAggregateInputType
  }

  export type GetPlayHistoryAggregateType<T extends PlayHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayHistory[P]>
      : GetScalarType<T[P], AggregatePlayHistory[P]>
  }




  export type PlayHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayHistoryWhereInput
    orderBy?: PlayHistoryOrderByWithAggregationInput | PlayHistoryOrderByWithAggregationInput[]
    by: PlayHistoryScalarFieldEnum[] | PlayHistoryScalarFieldEnum
    having?: PlayHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayHistoryCountAggregateInputType | true
    _avg?: PlayHistoryAvgAggregateInputType
    _sum?: PlayHistorySumAggregateInputType
    _min?: PlayHistoryMinAggregateInputType
    _max?: PlayHistoryMaxAggregateInputType
  }

  export type PlayHistoryGroupByOutputType = {
    id: string
    playedAt: Date
    duration: number
    deviceType: string | null
    userId: string
    songId: string
    _count: PlayHistoryCountAggregateOutputType | null
    _avg: PlayHistoryAvgAggregateOutputType | null
    _sum: PlayHistorySumAggregateOutputType | null
    _min: PlayHistoryMinAggregateOutputType | null
    _max: PlayHistoryMaxAggregateOutputType | null
  }

  type GetPlayHistoryGroupByPayload<T extends PlayHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], PlayHistoryGroupByOutputType[P]>
        }
      >
    >


  export type PlayHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playedAt?: boolean
    duration?: boolean
    deviceType?: boolean
    userId?: boolean
    songId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playHistory"]>

  export type PlayHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playedAt?: boolean
    duration?: boolean
    deviceType?: boolean
    userId?: boolean
    songId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playHistory"]>

  export type PlayHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playedAt?: boolean
    duration?: boolean
    deviceType?: boolean
    userId?: boolean
    songId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playHistory"]>

  export type PlayHistorySelectScalar = {
    id?: boolean
    playedAt?: boolean
    duration?: boolean
    deviceType?: boolean
    userId?: boolean
    songId?: boolean
  }

  export type PlayHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playedAt" | "duration" | "deviceType" | "userId" | "songId", ExtArgs["result"]["playHistory"]>
  export type PlayHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }
  export type PlayHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }
  export type PlayHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }

  export type $PlayHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayHistory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      song: Prisma.$SongPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playedAt: Date
      duration: number
      deviceType: string | null
      userId: string
      songId: string
    }, ExtArgs["result"]["playHistory"]>
    composites: {}
  }

  type PlayHistoryGetPayload<S extends boolean | null | undefined | PlayHistoryDefaultArgs> = $Result.GetResult<Prisma.$PlayHistoryPayload, S>

  type PlayHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlayHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlayHistoryCountAggregateInputType | true
    }

  export interface PlayHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayHistory'], meta: { name: 'PlayHistory' } }
    /**
     * Find zero or one PlayHistory that matches the filter.
     * @param {PlayHistoryFindUniqueArgs} args - Arguments to find a PlayHistory
     * @example
     * // Get one PlayHistory
     * const playHistory = await prisma.playHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayHistoryFindUniqueArgs>(args: SelectSubset<T, PlayHistoryFindUniqueArgs<ExtArgs>>): Prisma__PlayHistoryClient<$Result.GetResult<Prisma.$PlayHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlayHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlayHistoryFindUniqueOrThrowArgs} args - Arguments to find a PlayHistory
     * @example
     * // Get one PlayHistory
     * const playHistory = await prisma.playHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayHistoryClient<$Result.GetResult<Prisma.$PlayHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayHistoryFindFirstArgs} args - Arguments to find a PlayHistory
     * @example
     * // Get one PlayHistory
     * const playHistory = await prisma.playHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayHistoryFindFirstArgs>(args?: SelectSubset<T, PlayHistoryFindFirstArgs<ExtArgs>>): Prisma__PlayHistoryClient<$Result.GetResult<Prisma.$PlayHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayHistoryFindFirstOrThrowArgs} args - Arguments to find a PlayHistory
     * @example
     * // Get one PlayHistory
     * const playHistory = await prisma.playHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayHistoryClient<$Result.GetResult<Prisma.$PlayHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlayHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayHistories
     * const playHistories = await prisma.playHistory.findMany()
     * 
     * // Get first 10 PlayHistories
     * const playHistories = await prisma.playHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playHistoryWithIdOnly = await prisma.playHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayHistoryFindManyArgs>(args?: SelectSubset<T, PlayHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlayHistory.
     * @param {PlayHistoryCreateArgs} args - Arguments to create a PlayHistory.
     * @example
     * // Create one PlayHistory
     * const PlayHistory = await prisma.playHistory.create({
     *   data: {
     *     // ... data to create a PlayHistory
     *   }
     * })
     * 
     */
    create<T extends PlayHistoryCreateArgs>(args: SelectSubset<T, PlayHistoryCreateArgs<ExtArgs>>): Prisma__PlayHistoryClient<$Result.GetResult<Prisma.$PlayHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlayHistories.
     * @param {PlayHistoryCreateManyArgs} args - Arguments to create many PlayHistories.
     * @example
     * // Create many PlayHistories
     * const playHistory = await prisma.playHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayHistoryCreateManyArgs>(args?: SelectSubset<T, PlayHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayHistories and returns the data saved in the database.
     * @param {PlayHistoryCreateManyAndReturnArgs} args - Arguments to create many PlayHistories.
     * @example
     * // Create many PlayHistories
     * const playHistory = await prisma.playHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayHistories and only return the `id`
     * const playHistoryWithIdOnly = await prisma.playHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlayHistory.
     * @param {PlayHistoryDeleteArgs} args - Arguments to delete one PlayHistory.
     * @example
     * // Delete one PlayHistory
     * const PlayHistory = await prisma.playHistory.delete({
     *   where: {
     *     // ... filter to delete one PlayHistory
     *   }
     * })
     * 
     */
    delete<T extends PlayHistoryDeleteArgs>(args: SelectSubset<T, PlayHistoryDeleteArgs<ExtArgs>>): Prisma__PlayHistoryClient<$Result.GetResult<Prisma.$PlayHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlayHistory.
     * @param {PlayHistoryUpdateArgs} args - Arguments to update one PlayHistory.
     * @example
     * // Update one PlayHistory
     * const playHistory = await prisma.playHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayHistoryUpdateArgs>(args: SelectSubset<T, PlayHistoryUpdateArgs<ExtArgs>>): Prisma__PlayHistoryClient<$Result.GetResult<Prisma.$PlayHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlayHistories.
     * @param {PlayHistoryDeleteManyArgs} args - Arguments to filter PlayHistories to delete.
     * @example
     * // Delete a few PlayHistories
     * const { count } = await prisma.playHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayHistoryDeleteManyArgs>(args?: SelectSubset<T, PlayHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayHistories
     * const playHistory = await prisma.playHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayHistoryUpdateManyArgs>(args: SelectSubset<T, PlayHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayHistories and returns the data updated in the database.
     * @param {PlayHistoryUpdateManyAndReturnArgs} args - Arguments to update many PlayHistories.
     * @example
     * // Update many PlayHistories
     * const playHistory = await prisma.playHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlayHistories and only return the `id`
     * const playHistoryWithIdOnly = await prisma.playHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlayHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, PlayHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlayHistory.
     * @param {PlayHistoryUpsertArgs} args - Arguments to update or create a PlayHistory.
     * @example
     * // Update or create a PlayHistory
     * const playHistory = await prisma.playHistory.upsert({
     *   create: {
     *     // ... data to create a PlayHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayHistory we want to update
     *   }
     * })
     */
    upsert<T extends PlayHistoryUpsertArgs>(args: SelectSubset<T, PlayHistoryUpsertArgs<ExtArgs>>): Prisma__PlayHistoryClient<$Result.GetResult<Prisma.$PlayHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlayHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayHistoryCountArgs} args - Arguments to filter PlayHistories to count.
     * @example
     * // Count the number of PlayHistories
     * const count = await prisma.playHistory.count({
     *   where: {
     *     // ... the filter for the PlayHistories we want to count
     *   }
     * })
    **/
    count<T extends PlayHistoryCountArgs>(
      args?: Subset<T, PlayHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayHistoryAggregateArgs>(args: Subset<T, PlayHistoryAggregateArgs>): Prisma.PrismaPromise<GetPlayHistoryAggregateType<T>>

    /**
     * Group by PlayHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayHistoryGroupByArgs['orderBy'] }
        : { orderBy?: PlayHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayHistory model
   */
  readonly fields: PlayHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    song<T extends SongDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SongDefaultArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayHistory model
   */
  interface PlayHistoryFieldRefs {
    readonly id: FieldRef<"PlayHistory", 'String'>
    readonly playedAt: FieldRef<"PlayHistory", 'DateTime'>
    readonly duration: FieldRef<"PlayHistory", 'Int'>
    readonly deviceType: FieldRef<"PlayHistory", 'String'>
    readonly userId: FieldRef<"PlayHistory", 'String'>
    readonly songId: FieldRef<"PlayHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PlayHistory findUnique
   */
  export type PlayHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayHistory
     */
    select?: PlayHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayHistory
     */
    omit?: PlayHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PlayHistory to fetch.
     */
    where: PlayHistoryWhereUniqueInput
  }

  /**
   * PlayHistory findUniqueOrThrow
   */
  export type PlayHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayHistory
     */
    select?: PlayHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayHistory
     */
    omit?: PlayHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PlayHistory to fetch.
     */
    where: PlayHistoryWhereUniqueInput
  }

  /**
   * PlayHistory findFirst
   */
  export type PlayHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayHistory
     */
    select?: PlayHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayHistory
     */
    omit?: PlayHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PlayHistory to fetch.
     */
    where?: PlayHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayHistories to fetch.
     */
    orderBy?: PlayHistoryOrderByWithRelationInput | PlayHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayHistories.
     */
    cursor?: PlayHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayHistories.
     */
    distinct?: PlayHistoryScalarFieldEnum | PlayHistoryScalarFieldEnum[]
  }

  /**
   * PlayHistory findFirstOrThrow
   */
  export type PlayHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayHistory
     */
    select?: PlayHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayHistory
     */
    omit?: PlayHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PlayHistory to fetch.
     */
    where?: PlayHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayHistories to fetch.
     */
    orderBy?: PlayHistoryOrderByWithRelationInput | PlayHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayHistories.
     */
    cursor?: PlayHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayHistories.
     */
    distinct?: PlayHistoryScalarFieldEnum | PlayHistoryScalarFieldEnum[]
  }

  /**
   * PlayHistory findMany
   */
  export type PlayHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayHistory
     */
    select?: PlayHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayHistory
     */
    omit?: PlayHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PlayHistories to fetch.
     */
    where?: PlayHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayHistories to fetch.
     */
    orderBy?: PlayHistoryOrderByWithRelationInput | PlayHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayHistories.
     */
    cursor?: PlayHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayHistories.
     */
    skip?: number
    distinct?: PlayHistoryScalarFieldEnum | PlayHistoryScalarFieldEnum[]
  }

  /**
   * PlayHistory create
   */
  export type PlayHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayHistory
     */
    select?: PlayHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayHistory
     */
    omit?: PlayHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayHistory.
     */
    data: XOR<PlayHistoryCreateInput, PlayHistoryUncheckedCreateInput>
  }

  /**
   * PlayHistory createMany
   */
  export type PlayHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayHistories.
     */
    data: PlayHistoryCreateManyInput | PlayHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayHistory createManyAndReturn
   */
  export type PlayHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayHistory
     */
    select?: PlayHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayHistory
     */
    omit?: PlayHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many PlayHistories.
     */
    data: PlayHistoryCreateManyInput | PlayHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayHistory update
   */
  export type PlayHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayHistory
     */
    select?: PlayHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayHistory
     */
    omit?: PlayHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayHistory.
     */
    data: XOR<PlayHistoryUpdateInput, PlayHistoryUncheckedUpdateInput>
    /**
     * Choose, which PlayHistory to update.
     */
    where: PlayHistoryWhereUniqueInput
  }

  /**
   * PlayHistory updateMany
   */
  export type PlayHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayHistories.
     */
    data: XOR<PlayHistoryUpdateManyMutationInput, PlayHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PlayHistories to update
     */
    where?: PlayHistoryWhereInput
    /**
     * Limit how many PlayHistories to update.
     */
    limit?: number
  }

  /**
   * PlayHistory updateManyAndReturn
   */
  export type PlayHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayHistory
     */
    select?: PlayHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayHistory
     */
    omit?: PlayHistoryOmit<ExtArgs> | null
    /**
     * The data used to update PlayHistories.
     */
    data: XOR<PlayHistoryUpdateManyMutationInput, PlayHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PlayHistories to update
     */
    where?: PlayHistoryWhereInput
    /**
     * Limit how many PlayHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayHistory upsert
   */
  export type PlayHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayHistory
     */
    select?: PlayHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayHistory
     */
    omit?: PlayHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayHistory to update in case it exists.
     */
    where: PlayHistoryWhereUniqueInput
    /**
     * In case the PlayHistory found by the `where` argument doesn't exist, create a new PlayHistory with this data.
     */
    create: XOR<PlayHistoryCreateInput, PlayHistoryUncheckedCreateInput>
    /**
     * In case the PlayHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayHistoryUpdateInput, PlayHistoryUncheckedUpdateInput>
  }

  /**
   * PlayHistory delete
   */
  export type PlayHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayHistory
     */
    select?: PlayHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayHistory
     */
    omit?: PlayHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayHistoryInclude<ExtArgs> | null
    /**
     * Filter which PlayHistory to delete.
     */
    where: PlayHistoryWhereUniqueInput
  }

  /**
   * PlayHistory deleteMany
   */
  export type PlayHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayHistories to delete
     */
    where?: PlayHistoryWhereInput
    /**
     * Limit how many PlayHistories to delete.
     */
    limit?: number
  }

  /**
   * PlayHistory without action
   */
  export type PlayHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayHistory
     */
    select?: PlayHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayHistory
     */
    omit?: PlayHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayHistoryInclude<ExtArgs> | null
  }


  /**
   * Model SearchHistory
   */

  export type AggregateSearchHistory = {
    _count: SearchHistoryCountAggregateOutputType | null
    _min: SearchHistoryMinAggregateOutputType | null
    _max: SearchHistoryMaxAggregateOutputType | null
  }

  export type SearchHistoryMinAggregateOutputType = {
    id: string | null
    query: string | null
    resultType: string | null
    resultId: string | null
    searchedAt: Date | null
    userId: string | null
  }

  export type SearchHistoryMaxAggregateOutputType = {
    id: string | null
    query: string | null
    resultType: string | null
    resultId: string | null
    searchedAt: Date | null
    userId: string | null
  }

  export type SearchHistoryCountAggregateOutputType = {
    id: number
    query: number
    resultType: number
    resultId: number
    searchedAt: number
    userId: number
    _all: number
  }


  export type SearchHistoryMinAggregateInputType = {
    id?: true
    query?: true
    resultType?: true
    resultId?: true
    searchedAt?: true
    userId?: true
  }

  export type SearchHistoryMaxAggregateInputType = {
    id?: true
    query?: true
    resultType?: true
    resultId?: true
    searchedAt?: true
    userId?: true
  }

  export type SearchHistoryCountAggregateInputType = {
    id?: true
    query?: true
    resultType?: true
    resultId?: true
    searchedAt?: true
    userId?: true
    _all?: true
  }

  export type SearchHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchHistory to aggregate.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SearchHistories
    **/
    _count?: true | SearchHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SearchHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SearchHistoryMaxAggregateInputType
  }

  export type GetSearchHistoryAggregateType<T extends SearchHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSearchHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSearchHistory[P]>
      : GetScalarType<T[P], AggregateSearchHistory[P]>
  }




  export type SearchHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchHistoryWhereInput
    orderBy?: SearchHistoryOrderByWithAggregationInput | SearchHistoryOrderByWithAggregationInput[]
    by: SearchHistoryScalarFieldEnum[] | SearchHistoryScalarFieldEnum
    having?: SearchHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SearchHistoryCountAggregateInputType | true
    _min?: SearchHistoryMinAggregateInputType
    _max?: SearchHistoryMaxAggregateInputType
  }

  export type SearchHistoryGroupByOutputType = {
    id: string
    query: string
    resultType: string | null
    resultId: string | null
    searchedAt: Date
    userId: string
    _count: SearchHistoryCountAggregateOutputType | null
    _min: SearchHistoryMinAggregateOutputType | null
    _max: SearchHistoryMaxAggregateOutputType | null
  }

  type GetSearchHistoryGroupByPayload<T extends SearchHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SearchHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SearchHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SearchHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], SearchHistoryGroupByOutputType[P]>
        }
      >
    >


  export type SearchHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query?: boolean
    resultType?: boolean
    resultId?: boolean
    searchedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["searchHistory"]>

  export type SearchHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query?: boolean
    resultType?: boolean
    resultId?: boolean
    searchedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["searchHistory"]>

  export type SearchHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query?: boolean
    resultType?: boolean
    resultId?: boolean
    searchedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["searchHistory"]>

  export type SearchHistorySelectScalar = {
    id?: boolean
    query?: boolean
    resultType?: boolean
    resultId?: boolean
    searchedAt?: boolean
    userId?: boolean
  }

  export type SearchHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "query" | "resultType" | "resultId" | "searchedAt" | "userId", ExtArgs["result"]["searchHistory"]>
  export type SearchHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SearchHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SearchHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SearchHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SearchHistory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      query: string
      resultType: string | null
      resultId: string | null
      searchedAt: Date
      userId: string
    }, ExtArgs["result"]["searchHistory"]>
    composites: {}
  }

  type SearchHistoryGetPayload<S extends boolean | null | undefined | SearchHistoryDefaultArgs> = $Result.GetResult<Prisma.$SearchHistoryPayload, S>

  type SearchHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SearchHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SearchHistoryCountAggregateInputType | true
    }

  export interface SearchHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SearchHistory'], meta: { name: 'SearchHistory' } }
    /**
     * Find zero or one SearchHistory that matches the filter.
     * @param {SearchHistoryFindUniqueArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SearchHistoryFindUniqueArgs>(args: SelectSubset<T, SearchHistoryFindUniqueArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SearchHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SearchHistoryFindUniqueOrThrowArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SearchHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SearchHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryFindFirstArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SearchHistoryFindFirstArgs>(args?: SelectSubset<T, SearchHistoryFindFirstArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryFindFirstOrThrowArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SearchHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SearchHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SearchHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SearchHistories
     * const searchHistories = await prisma.searchHistory.findMany()
     * 
     * // Get first 10 SearchHistories
     * const searchHistories = await prisma.searchHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const searchHistoryWithIdOnly = await prisma.searchHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SearchHistoryFindManyArgs>(args?: SelectSubset<T, SearchHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SearchHistory.
     * @param {SearchHistoryCreateArgs} args - Arguments to create a SearchHistory.
     * @example
     * // Create one SearchHistory
     * const SearchHistory = await prisma.searchHistory.create({
     *   data: {
     *     // ... data to create a SearchHistory
     *   }
     * })
     * 
     */
    create<T extends SearchHistoryCreateArgs>(args: SelectSubset<T, SearchHistoryCreateArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SearchHistories.
     * @param {SearchHistoryCreateManyArgs} args - Arguments to create many SearchHistories.
     * @example
     * // Create many SearchHistories
     * const searchHistory = await prisma.searchHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SearchHistoryCreateManyArgs>(args?: SelectSubset<T, SearchHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SearchHistories and returns the data saved in the database.
     * @param {SearchHistoryCreateManyAndReturnArgs} args - Arguments to create many SearchHistories.
     * @example
     * // Create many SearchHistories
     * const searchHistory = await prisma.searchHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SearchHistories and only return the `id`
     * const searchHistoryWithIdOnly = await prisma.searchHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SearchHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, SearchHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SearchHistory.
     * @param {SearchHistoryDeleteArgs} args - Arguments to delete one SearchHistory.
     * @example
     * // Delete one SearchHistory
     * const SearchHistory = await prisma.searchHistory.delete({
     *   where: {
     *     // ... filter to delete one SearchHistory
     *   }
     * })
     * 
     */
    delete<T extends SearchHistoryDeleteArgs>(args: SelectSubset<T, SearchHistoryDeleteArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SearchHistory.
     * @param {SearchHistoryUpdateArgs} args - Arguments to update one SearchHistory.
     * @example
     * // Update one SearchHistory
     * const searchHistory = await prisma.searchHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SearchHistoryUpdateArgs>(args: SelectSubset<T, SearchHistoryUpdateArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SearchHistories.
     * @param {SearchHistoryDeleteManyArgs} args - Arguments to filter SearchHistories to delete.
     * @example
     * // Delete a few SearchHistories
     * const { count } = await prisma.searchHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SearchHistoryDeleteManyArgs>(args?: SelectSubset<T, SearchHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SearchHistories
     * const searchHistory = await prisma.searchHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SearchHistoryUpdateManyArgs>(args: SelectSubset<T, SearchHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchHistories and returns the data updated in the database.
     * @param {SearchHistoryUpdateManyAndReturnArgs} args - Arguments to update many SearchHistories.
     * @example
     * // Update many SearchHistories
     * const searchHistory = await prisma.searchHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SearchHistories and only return the `id`
     * const searchHistoryWithIdOnly = await prisma.searchHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SearchHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, SearchHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SearchHistory.
     * @param {SearchHistoryUpsertArgs} args - Arguments to update or create a SearchHistory.
     * @example
     * // Update or create a SearchHistory
     * const searchHistory = await prisma.searchHistory.upsert({
     *   create: {
     *     // ... data to create a SearchHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SearchHistory we want to update
     *   }
     * })
     */
    upsert<T extends SearchHistoryUpsertArgs>(args: SelectSubset<T, SearchHistoryUpsertArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SearchHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryCountArgs} args - Arguments to filter SearchHistories to count.
     * @example
     * // Count the number of SearchHistories
     * const count = await prisma.searchHistory.count({
     *   where: {
     *     // ... the filter for the SearchHistories we want to count
     *   }
     * })
    **/
    count<T extends SearchHistoryCountArgs>(
      args?: Subset<T, SearchHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SearchHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SearchHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SearchHistoryAggregateArgs>(args: Subset<T, SearchHistoryAggregateArgs>): Prisma.PrismaPromise<GetSearchHistoryAggregateType<T>>

    /**
     * Group by SearchHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SearchHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SearchHistoryGroupByArgs['orderBy'] }
        : { orderBy?: SearchHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SearchHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSearchHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SearchHistory model
   */
  readonly fields: SearchHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SearchHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SearchHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SearchHistory model
   */
  interface SearchHistoryFieldRefs {
    readonly id: FieldRef<"SearchHistory", 'String'>
    readonly query: FieldRef<"SearchHistory", 'String'>
    readonly resultType: FieldRef<"SearchHistory", 'String'>
    readonly resultId: FieldRef<"SearchHistory", 'String'>
    readonly searchedAt: FieldRef<"SearchHistory", 'DateTime'>
    readonly userId: FieldRef<"SearchHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SearchHistory findUnique
   */
  export type SearchHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory findUniqueOrThrow
   */
  export type SearchHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory findFirst
   */
  export type SearchHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchHistories.
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchHistories.
     */
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * SearchHistory findFirstOrThrow
   */
  export type SearchHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchHistories.
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchHistories.
     */
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * SearchHistory findMany
   */
  export type SearchHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistories to fetch.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SearchHistories.
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * SearchHistory create
   */
  export type SearchHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a SearchHistory.
     */
    data: XOR<SearchHistoryCreateInput, SearchHistoryUncheckedCreateInput>
  }

  /**
   * SearchHistory createMany
   */
  export type SearchHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SearchHistories.
     */
    data: SearchHistoryCreateManyInput | SearchHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SearchHistory createManyAndReturn
   */
  export type SearchHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many SearchHistories.
     */
    data: SearchHistoryCreateManyInput | SearchHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SearchHistory update
   */
  export type SearchHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a SearchHistory.
     */
    data: XOR<SearchHistoryUpdateInput, SearchHistoryUncheckedUpdateInput>
    /**
     * Choose, which SearchHistory to update.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory updateMany
   */
  export type SearchHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SearchHistories.
     */
    data: XOR<SearchHistoryUpdateManyMutationInput, SearchHistoryUncheckedUpdateManyInput>
    /**
     * Filter which SearchHistories to update
     */
    where?: SearchHistoryWhereInput
    /**
     * Limit how many SearchHistories to update.
     */
    limit?: number
  }

  /**
   * SearchHistory updateManyAndReturn
   */
  export type SearchHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * The data used to update SearchHistories.
     */
    data: XOR<SearchHistoryUpdateManyMutationInput, SearchHistoryUncheckedUpdateManyInput>
    /**
     * Filter which SearchHistories to update
     */
    where?: SearchHistoryWhereInput
    /**
     * Limit how many SearchHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SearchHistory upsert
   */
  export type SearchHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the SearchHistory to update in case it exists.
     */
    where: SearchHistoryWhereUniqueInput
    /**
     * In case the SearchHistory found by the `where` argument doesn't exist, create a new SearchHistory with this data.
     */
    create: XOR<SearchHistoryCreateInput, SearchHistoryUncheckedCreateInput>
    /**
     * In case the SearchHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SearchHistoryUpdateInput, SearchHistoryUncheckedUpdateInput>
  }

  /**
   * SearchHistory delete
   */
  export type SearchHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter which SearchHistory to delete.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory deleteMany
   */
  export type SearchHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchHistories to delete
     */
    where?: SearchHistoryWhereInput
    /**
     * Limit how many SearchHistories to delete.
     */
    limit?: number
  }

  /**
   * SearchHistory without action
   */
  export type SearchHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
  }


  /**
   * Model UserRecommendation
   */

  export type AggregateUserRecommendation = {
    _count: UserRecommendationCountAggregateOutputType | null
    _avg: UserRecommendationAvgAggregateOutputType | null
    _sum: UserRecommendationSumAggregateOutputType | null
    _min: UserRecommendationMinAggregateOutputType | null
    _max: UserRecommendationMaxAggregateOutputType | null
  }

  export type UserRecommendationAvgAggregateOutputType = {
    score: number | null
  }

  export type UserRecommendationSumAggregateOutputType = {
    score: number | null
  }

  export type UserRecommendationMinAggregateOutputType = {
    id: string | null
    type: string | null
    targetId: string | null
    score: number | null
    reason: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type UserRecommendationMaxAggregateOutputType = {
    id: string | null
    type: string | null
    targetId: string | null
    score: number | null
    reason: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type UserRecommendationCountAggregateOutputType = {
    id: number
    type: number
    targetId: number
    score: number
    reason: number
    createdAt: number
    userId: number
    _all: number
  }


  export type UserRecommendationAvgAggregateInputType = {
    score?: true
  }

  export type UserRecommendationSumAggregateInputType = {
    score?: true
  }

  export type UserRecommendationMinAggregateInputType = {
    id?: true
    type?: true
    targetId?: true
    score?: true
    reason?: true
    createdAt?: true
    userId?: true
  }

  export type UserRecommendationMaxAggregateInputType = {
    id?: true
    type?: true
    targetId?: true
    score?: true
    reason?: true
    createdAt?: true
    userId?: true
  }

  export type UserRecommendationCountAggregateInputType = {
    id?: true
    type?: true
    targetId?: true
    score?: true
    reason?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type UserRecommendationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRecommendation to aggregate.
     */
    where?: UserRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRecommendations to fetch.
     */
    orderBy?: UserRecommendationOrderByWithRelationInput | UserRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRecommendations
    **/
    _count?: true | UserRecommendationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRecommendationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRecommendationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRecommendationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRecommendationMaxAggregateInputType
  }

  export type GetUserRecommendationAggregateType<T extends UserRecommendationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRecommendation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRecommendation[P]>
      : GetScalarType<T[P], AggregateUserRecommendation[P]>
  }




  export type UserRecommendationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRecommendationWhereInput
    orderBy?: UserRecommendationOrderByWithAggregationInput | UserRecommendationOrderByWithAggregationInput[]
    by: UserRecommendationScalarFieldEnum[] | UserRecommendationScalarFieldEnum
    having?: UserRecommendationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRecommendationCountAggregateInputType | true
    _avg?: UserRecommendationAvgAggregateInputType
    _sum?: UserRecommendationSumAggregateInputType
    _min?: UserRecommendationMinAggregateInputType
    _max?: UserRecommendationMaxAggregateInputType
  }

  export type UserRecommendationGroupByOutputType = {
    id: string
    type: string
    targetId: string
    score: number
    reason: string | null
    createdAt: Date
    userId: string
    _count: UserRecommendationCountAggregateOutputType | null
    _avg: UserRecommendationAvgAggregateOutputType | null
    _sum: UserRecommendationSumAggregateOutputType | null
    _min: UserRecommendationMinAggregateOutputType | null
    _max: UserRecommendationMaxAggregateOutputType | null
  }

  type GetUserRecommendationGroupByPayload<T extends UserRecommendationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRecommendationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRecommendationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRecommendationGroupByOutputType[P]>
            : GetScalarType<T[P], UserRecommendationGroupByOutputType[P]>
        }
      >
    >


  export type UserRecommendationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    targetId?: boolean
    score?: boolean
    reason?: boolean
    createdAt?: boolean
    userId?: boolean
  }, ExtArgs["result"]["userRecommendation"]>

  export type UserRecommendationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    targetId?: boolean
    score?: boolean
    reason?: boolean
    createdAt?: boolean
    userId?: boolean
  }, ExtArgs["result"]["userRecommendation"]>

  export type UserRecommendationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    targetId?: boolean
    score?: boolean
    reason?: boolean
    createdAt?: boolean
    userId?: boolean
  }, ExtArgs["result"]["userRecommendation"]>

  export type UserRecommendationSelectScalar = {
    id?: boolean
    type?: boolean
    targetId?: boolean
    score?: boolean
    reason?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type UserRecommendationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "targetId" | "score" | "reason" | "createdAt" | "userId", ExtArgs["result"]["userRecommendation"]>

  export type $UserRecommendationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRecommendation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      targetId: string
      score: number
      reason: string | null
      createdAt: Date
      userId: string
    }, ExtArgs["result"]["userRecommendation"]>
    composites: {}
  }

  type UserRecommendationGetPayload<S extends boolean | null | undefined | UserRecommendationDefaultArgs> = $Result.GetResult<Prisma.$UserRecommendationPayload, S>

  type UserRecommendationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRecommendationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRecommendationCountAggregateInputType | true
    }

  export interface UserRecommendationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRecommendation'], meta: { name: 'UserRecommendation' } }
    /**
     * Find zero or one UserRecommendation that matches the filter.
     * @param {UserRecommendationFindUniqueArgs} args - Arguments to find a UserRecommendation
     * @example
     * // Get one UserRecommendation
     * const userRecommendation = await prisma.userRecommendation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRecommendationFindUniqueArgs>(args: SelectSubset<T, UserRecommendationFindUniqueArgs<ExtArgs>>): Prisma__UserRecommendationClient<$Result.GetResult<Prisma.$UserRecommendationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRecommendation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRecommendationFindUniqueOrThrowArgs} args - Arguments to find a UserRecommendation
     * @example
     * // Get one UserRecommendation
     * const userRecommendation = await prisma.userRecommendation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRecommendationFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRecommendationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRecommendationClient<$Result.GetResult<Prisma.$UserRecommendationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRecommendation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRecommendationFindFirstArgs} args - Arguments to find a UserRecommendation
     * @example
     * // Get one UserRecommendation
     * const userRecommendation = await prisma.userRecommendation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRecommendationFindFirstArgs>(args?: SelectSubset<T, UserRecommendationFindFirstArgs<ExtArgs>>): Prisma__UserRecommendationClient<$Result.GetResult<Prisma.$UserRecommendationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRecommendation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRecommendationFindFirstOrThrowArgs} args - Arguments to find a UserRecommendation
     * @example
     * // Get one UserRecommendation
     * const userRecommendation = await prisma.userRecommendation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRecommendationFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRecommendationFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRecommendationClient<$Result.GetResult<Prisma.$UserRecommendationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRecommendations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRecommendationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRecommendations
     * const userRecommendations = await prisma.userRecommendation.findMany()
     * 
     * // Get first 10 UserRecommendations
     * const userRecommendations = await prisma.userRecommendation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRecommendationWithIdOnly = await prisma.userRecommendation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRecommendationFindManyArgs>(args?: SelectSubset<T, UserRecommendationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRecommendationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRecommendation.
     * @param {UserRecommendationCreateArgs} args - Arguments to create a UserRecommendation.
     * @example
     * // Create one UserRecommendation
     * const UserRecommendation = await prisma.userRecommendation.create({
     *   data: {
     *     // ... data to create a UserRecommendation
     *   }
     * })
     * 
     */
    create<T extends UserRecommendationCreateArgs>(args: SelectSubset<T, UserRecommendationCreateArgs<ExtArgs>>): Prisma__UserRecommendationClient<$Result.GetResult<Prisma.$UserRecommendationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRecommendations.
     * @param {UserRecommendationCreateManyArgs} args - Arguments to create many UserRecommendations.
     * @example
     * // Create many UserRecommendations
     * const userRecommendation = await prisma.userRecommendation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRecommendationCreateManyArgs>(args?: SelectSubset<T, UserRecommendationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRecommendations and returns the data saved in the database.
     * @param {UserRecommendationCreateManyAndReturnArgs} args - Arguments to create many UserRecommendations.
     * @example
     * // Create many UserRecommendations
     * const userRecommendation = await prisma.userRecommendation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRecommendations and only return the `id`
     * const userRecommendationWithIdOnly = await prisma.userRecommendation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRecommendationCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRecommendationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRecommendationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserRecommendation.
     * @param {UserRecommendationDeleteArgs} args - Arguments to delete one UserRecommendation.
     * @example
     * // Delete one UserRecommendation
     * const UserRecommendation = await prisma.userRecommendation.delete({
     *   where: {
     *     // ... filter to delete one UserRecommendation
     *   }
     * })
     * 
     */
    delete<T extends UserRecommendationDeleteArgs>(args: SelectSubset<T, UserRecommendationDeleteArgs<ExtArgs>>): Prisma__UserRecommendationClient<$Result.GetResult<Prisma.$UserRecommendationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRecommendation.
     * @param {UserRecommendationUpdateArgs} args - Arguments to update one UserRecommendation.
     * @example
     * // Update one UserRecommendation
     * const userRecommendation = await prisma.userRecommendation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRecommendationUpdateArgs>(args: SelectSubset<T, UserRecommendationUpdateArgs<ExtArgs>>): Prisma__UserRecommendationClient<$Result.GetResult<Prisma.$UserRecommendationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRecommendations.
     * @param {UserRecommendationDeleteManyArgs} args - Arguments to filter UserRecommendations to delete.
     * @example
     * // Delete a few UserRecommendations
     * const { count } = await prisma.userRecommendation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRecommendationDeleteManyArgs>(args?: SelectSubset<T, UserRecommendationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRecommendationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRecommendations
     * const userRecommendation = await prisma.userRecommendation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRecommendationUpdateManyArgs>(args: SelectSubset<T, UserRecommendationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRecommendations and returns the data updated in the database.
     * @param {UserRecommendationUpdateManyAndReturnArgs} args - Arguments to update many UserRecommendations.
     * @example
     * // Update many UserRecommendations
     * const userRecommendation = await prisma.userRecommendation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserRecommendations and only return the `id`
     * const userRecommendationWithIdOnly = await prisma.userRecommendation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserRecommendationUpdateManyAndReturnArgs>(args: SelectSubset<T, UserRecommendationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRecommendationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserRecommendation.
     * @param {UserRecommendationUpsertArgs} args - Arguments to update or create a UserRecommendation.
     * @example
     * // Update or create a UserRecommendation
     * const userRecommendation = await prisma.userRecommendation.upsert({
     *   create: {
     *     // ... data to create a UserRecommendation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRecommendation we want to update
     *   }
     * })
     */
    upsert<T extends UserRecommendationUpsertArgs>(args: SelectSubset<T, UserRecommendationUpsertArgs<ExtArgs>>): Prisma__UserRecommendationClient<$Result.GetResult<Prisma.$UserRecommendationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRecommendationCountArgs} args - Arguments to filter UserRecommendations to count.
     * @example
     * // Count the number of UserRecommendations
     * const count = await prisma.userRecommendation.count({
     *   where: {
     *     // ... the filter for the UserRecommendations we want to count
     *   }
     * })
    **/
    count<T extends UserRecommendationCountArgs>(
      args?: Subset<T, UserRecommendationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRecommendationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRecommendationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRecommendationAggregateArgs>(args: Subset<T, UserRecommendationAggregateArgs>): Prisma.PrismaPromise<GetUserRecommendationAggregateType<T>>

    /**
     * Group by UserRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRecommendationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRecommendationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRecommendationGroupByArgs['orderBy'] }
        : { orderBy?: UserRecommendationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRecommendationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRecommendationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRecommendation model
   */
  readonly fields: UserRecommendationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRecommendation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRecommendationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRecommendation model
   */
  interface UserRecommendationFieldRefs {
    readonly id: FieldRef<"UserRecommendation", 'String'>
    readonly type: FieldRef<"UserRecommendation", 'String'>
    readonly targetId: FieldRef<"UserRecommendation", 'String'>
    readonly score: FieldRef<"UserRecommendation", 'Float'>
    readonly reason: FieldRef<"UserRecommendation", 'String'>
    readonly createdAt: FieldRef<"UserRecommendation", 'DateTime'>
    readonly userId: FieldRef<"UserRecommendation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserRecommendation findUnique
   */
  export type UserRecommendationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecommendation
     */
    select?: UserRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecommendation
     */
    omit?: UserRecommendationOmit<ExtArgs> | null
    /**
     * Filter, which UserRecommendation to fetch.
     */
    where: UserRecommendationWhereUniqueInput
  }

  /**
   * UserRecommendation findUniqueOrThrow
   */
  export type UserRecommendationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecommendation
     */
    select?: UserRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecommendation
     */
    omit?: UserRecommendationOmit<ExtArgs> | null
    /**
     * Filter, which UserRecommendation to fetch.
     */
    where: UserRecommendationWhereUniqueInput
  }

  /**
   * UserRecommendation findFirst
   */
  export type UserRecommendationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecommendation
     */
    select?: UserRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecommendation
     */
    omit?: UserRecommendationOmit<ExtArgs> | null
    /**
     * Filter, which UserRecommendation to fetch.
     */
    where?: UserRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRecommendations to fetch.
     */
    orderBy?: UserRecommendationOrderByWithRelationInput | UserRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRecommendations.
     */
    cursor?: UserRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRecommendations.
     */
    distinct?: UserRecommendationScalarFieldEnum | UserRecommendationScalarFieldEnum[]
  }

  /**
   * UserRecommendation findFirstOrThrow
   */
  export type UserRecommendationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecommendation
     */
    select?: UserRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecommendation
     */
    omit?: UserRecommendationOmit<ExtArgs> | null
    /**
     * Filter, which UserRecommendation to fetch.
     */
    where?: UserRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRecommendations to fetch.
     */
    orderBy?: UserRecommendationOrderByWithRelationInput | UserRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRecommendations.
     */
    cursor?: UserRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRecommendations.
     */
    distinct?: UserRecommendationScalarFieldEnum | UserRecommendationScalarFieldEnum[]
  }

  /**
   * UserRecommendation findMany
   */
  export type UserRecommendationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecommendation
     */
    select?: UserRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecommendation
     */
    omit?: UserRecommendationOmit<ExtArgs> | null
    /**
     * Filter, which UserRecommendations to fetch.
     */
    where?: UserRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRecommendations to fetch.
     */
    orderBy?: UserRecommendationOrderByWithRelationInput | UserRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRecommendations.
     */
    cursor?: UserRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRecommendations.
     */
    skip?: number
    distinct?: UserRecommendationScalarFieldEnum | UserRecommendationScalarFieldEnum[]
  }

  /**
   * UserRecommendation create
   */
  export type UserRecommendationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecommendation
     */
    select?: UserRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecommendation
     */
    omit?: UserRecommendationOmit<ExtArgs> | null
    /**
     * The data needed to create a UserRecommendation.
     */
    data: XOR<UserRecommendationCreateInput, UserRecommendationUncheckedCreateInput>
  }

  /**
   * UserRecommendation createMany
   */
  export type UserRecommendationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRecommendations.
     */
    data: UserRecommendationCreateManyInput | UserRecommendationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRecommendation createManyAndReturn
   */
  export type UserRecommendationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecommendation
     */
    select?: UserRecommendationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecommendation
     */
    omit?: UserRecommendationOmit<ExtArgs> | null
    /**
     * The data used to create many UserRecommendations.
     */
    data: UserRecommendationCreateManyInput | UserRecommendationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRecommendation update
   */
  export type UserRecommendationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecommendation
     */
    select?: UserRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecommendation
     */
    omit?: UserRecommendationOmit<ExtArgs> | null
    /**
     * The data needed to update a UserRecommendation.
     */
    data: XOR<UserRecommendationUpdateInput, UserRecommendationUncheckedUpdateInput>
    /**
     * Choose, which UserRecommendation to update.
     */
    where: UserRecommendationWhereUniqueInput
  }

  /**
   * UserRecommendation updateMany
   */
  export type UserRecommendationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRecommendations.
     */
    data: XOR<UserRecommendationUpdateManyMutationInput, UserRecommendationUncheckedUpdateManyInput>
    /**
     * Filter which UserRecommendations to update
     */
    where?: UserRecommendationWhereInput
    /**
     * Limit how many UserRecommendations to update.
     */
    limit?: number
  }

  /**
   * UserRecommendation updateManyAndReturn
   */
  export type UserRecommendationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecommendation
     */
    select?: UserRecommendationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecommendation
     */
    omit?: UserRecommendationOmit<ExtArgs> | null
    /**
     * The data used to update UserRecommendations.
     */
    data: XOR<UserRecommendationUpdateManyMutationInput, UserRecommendationUncheckedUpdateManyInput>
    /**
     * Filter which UserRecommendations to update
     */
    where?: UserRecommendationWhereInput
    /**
     * Limit how many UserRecommendations to update.
     */
    limit?: number
  }

  /**
   * UserRecommendation upsert
   */
  export type UserRecommendationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecommendation
     */
    select?: UserRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecommendation
     */
    omit?: UserRecommendationOmit<ExtArgs> | null
    /**
     * The filter to search for the UserRecommendation to update in case it exists.
     */
    where: UserRecommendationWhereUniqueInput
    /**
     * In case the UserRecommendation found by the `where` argument doesn't exist, create a new UserRecommendation with this data.
     */
    create: XOR<UserRecommendationCreateInput, UserRecommendationUncheckedCreateInput>
    /**
     * In case the UserRecommendation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRecommendationUpdateInput, UserRecommendationUncheckedUpdateInput>
  }

  /**
   * UserRecommendation delete
   */
  export type UserRecommendationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecommendation
     */
    select?: UserRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecommendation
     */
    omit?: UserRecommendationOmit<ExtArgs> | null
    /**
     * Filter which UserRecommendation to delete.
     */
    where: UserRecommendationWhereUniqueInput
  }

  /**
   * UserRecommendation deleteMany
   */
  export type UserRecommendationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRecommendations to delete
     */
    where?: UserRecommendationWhereInput
    /**
     * Limit how many UserRecommendations to delete.
     */
    limit?: number
  }

  /**
   * UserRecommendation without action
   */
  export type UserRecommendationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecommendation
     */
    select?: UserRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecommendation
     */
    omit?: UserRecommendationOmit<ExtArgs> | null
  }


  /**
   * Model UserQueue
   */

  export type AggregateUserQueue = {
    _count: UserQueueCountAggregateOutputType | null
    _avg: UserQueueAvgAggregateOutputType | null
    _sum: UserQueueSumAggregateOutputType | null
    _min: UserQueueMinAggregateOutputType | null
    _max: UserQueueMaxAggregateOutputType | null
  }

  export type UserQueueAvgAggregateOutputType = {
    position: number | null
  }

  export type UserQueueSumAggregateOutputType = {
    position: number | null
  }

  export type UserQueueMinAggregateOutputType = {
    id: string | null
    position: number | null
    createdAt: Date | null
    userId: string | null
    songId: string | null
  }

  export type UserQueueMaxAggregateOutputType = {
    id: string | null
    position: number | null
    createdAt: Date | null
    userId: string | null
    songId: string | null
  }

  export type UserQueueCountAggregateOutputType = {
    id: number
    position: number
    createdAt: number
    userId: number
    songId: number
    _all: number
  }


  export type UserQueueAvgAggregateInputType = {
    position?: true
  }

  export type UserQueueSumAggregateInputType = {
    position?: true
  }

  export type UserQueueMinAggregateInputType = {
    id?: true
    position?: true
    createdAt?: true
    userId?: true
    songId?: true
  }

  export type UserQueueMaxAggregateInputType = {
    id?: true
    position?: true
    createdAt?: true
    userId?: true
    songId?: true
  }

  export type UserQueueCountAggregateInputType = {
    id?: true
    position?: true
    createdAt?: true
    userId?: true
    songId?: true
    _all?: true
  }

  export type UserQueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserQueue to aggregate.
     */
    where?: UserQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQueues to fetch.
     */
    orderBy?: UserQueueOrderByWithRelationInput | UserQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserQueues
    **/
    _count?: true | UserQueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserQueueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserQueueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserQueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserQueueMaxAggregateInputType
  }

  export type GetUserQueueAggregateType<T extends UserQueueAggregateArgs> = {
        [P in keyof T & keyof AggregateUserQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserQueue[P]>
      : GetScalarType<T[P], AggregateUserQueue[P]>
  }




  export type UserQueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserQueueWhereInput
    orderBy?: UserQueueOrderByWithAggregationInput | UserQueueOrderByWithAggregationInput[]
    by: UserQueueScalarFieldEnum[] | UserQueueScalarFieldEnum
    having?: UserQueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserQueueCountAggregateInputType | true
    _avg?: UserQueueAvgAggregateInputType
    _sum?: UserQueueSumAggregateInputType
    _min?: UserQueueMinAggregateInputType
    _max?: UserQueueMaxAggregateInputType
  }

  export type UserQueueGroupByOutputType = {
    id: string
    position: number
    createdAt: Date
    userId: string
    songId: string
    _count: UserQueueCountAggregateOutputType | null
    _avg: UserQueueAvgAggregateOutputType | null
    _sum: UserQueueSumAggregateOutputType | null
    _min: UserQueueMinAggregateOutputType | null
    _max: UserQueueMaxAggregateOutputType | null
  }

  type GetUserQueueGroupByPayload<T extends UserQueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserQueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserQueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserQueueGroupByOutputType[P]>
            : GetScalarType<T[P], UserQueueGroupByOutputType[P]>
        }
      >
    >


  export type UserQueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    position?: boolean
    createdAt?: boolean
    userId?: boolean
    songId?: boolean
  }, ExtArgs["result"]["userQueue"]>

  export type UserQueueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    position?: boolean
    createdAt?: boolean
    userId?: boolean
    songId?: boolean
  }, ExtArgs["result"]["userQueue"]>

  export type UserQueueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    position?: boolean
    createdAt?: boolean
    userId?: boolean
    songId?: boolean
  }, ExtArgs["result"]["userQueue"]>

  export type UserQueueSelectScalar = {
    id?: boolean
    position?: boolean
    createdAt?: boolean
    userId?: boolean
    songId?: boolean
  }

  export type UserQueueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "position" | "createdAt" | "userId" | "songId", ExtArgs["result"]["userQueue"]>

  export type $UserQueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserQueue"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      position: number
      createdAt: Date
      userId: string
      songId: string
    }, ExtArgs["result"]["userQueue"]>
    composites: {}
  }

  type UserQueueGetPayload<S extends boolean | null | undefined | UserQueueDefaultArgs> = $Result.GetResult<Prisma.$UserQueuePayload, S>

  type UserQueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserQueueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserQueueCountAggregateInputType | true
    }

  export interface UserQueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserQueue'], meta: { name: 'UserQueue' } }
    /**
     * Find zero or one UserQueue that matches the filter.
     * @param {UserQueueFindUniqueArgs} args - Arguments to find a UserQueue
     * @example
     * // Get one UserQueue
     * const userQueue = await prisma.userQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserQueueFindUniqueArgs>(args: SelectSubset<T, UserQueueFindUniqueArgs<ExtArgs>>): Prisma__UserQueueClient<$Result.GetResult<Prisma.$UserQueuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserQueue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserQueueFindUniqueOrThrowArgs} args - Arguments to find a UserQueue
     * @example
     * // Get one UserQueue
     * const userQueue = await prisma.userQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserQueueFindUniqueOrThrowArgs>(args: SelectSubset<T, UserQueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserQueueClient<$Result.GetResult<Prisma.$UserQueuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQueueFindFirstArgs} args - Arguments to find a UserQueue
     * @example
     * // Get one UserQueue
     * const userQueue = await prisma.userQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserQueueFindFirstArgs>(args?: SelectSubset<T, UserQueueFindFirstArgs<ExtArgs>>): Prisma__UserQueueClient<$Result.GetResult<Prisma.$UserQueuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQueueFindFirstOrThrowArgs} args - Arguments to find a UserQueue
     * @example
     * // Get one UserQueue
     * const userQueue = await prisma.userQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserQueueFindFirstOrThrowArgs>(args?: SelectSubset<T, UserQueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserQueueClient<$Result.GetResult<Prisma.$UserQueuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserQueues
     * const userQueues = await prisma.userQueue.findMany()
     * 
     * // Get first 10 UserQueues
     * const userQueues = await prisma.userQueue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userQueueWithIdOnly = await prisma.userQueue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserQueueFindManyArgs>(args?: SelectSubset<T, UserQueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQueuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserQueue.
     * @param {UserQueueCreateArgs} args - Arguments to create a UserQueue.
     * @example
     * // Create one UserQueue
     * const UserQueue = await prisma.userQueue.create({
     *   data: {
     *     // ... data to create a UserQueue
     *   }
     * })
     * 
     */
    create<T extends UserQueueCreateArgs>(args: SelectSubset<T, UserQueueCreateArgs<ExtArgs>>): Prisma__UserQueueClient<$Result.GetResult<Prisma.$UserQueuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserQueues.
     * @param {UserQueueCreateManyArgs} args - Arguments to create many UserQueues.
     * @example
     * // Create many UserQueues
     * const userQueue = await prisma.userQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserQueueCreateManyArgs>(args?: SelectSubset<T, UserQueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserQueues and returns the data saved in the database.
     * @param {UserQueueCreateManyAndReturnArgs} args - Arguments to create many UserQueues.
     * @example
     * // Create many UserQueues
     * const userQueue = await prisma.userQueue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserQueues and only return the `id`
     * const userQueueWithIdOnly = await prisma.userQueue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserQueueCreateManyAndReturnArgs>(args?: SelectSubset<T, UserQueueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQueuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserQueue.
     * @param {UserQueueDeleteArgs} args - Arguments to delete one UserQueue.
     * @example
     * // Delete one UserQueue
     * const UserQueue = await prisma.userQueue.delete({
     *   where: {
     *     // ... filter to delete one UserQueue
     *   }
     * })
     * 
     */
    delete<T extends UserQueueDeleteArgs>(args: SelectSubset<T, UserQueueDeleteArgs<ExtArgs>>): Prisma__UserQueueClient<$Result.GetResult<Prisma.$UserQueuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserQueue.
     * @param {UserQueueUpdateArgs} args - Arguments to update one UserQueue.
     * @example
     * // Update one UserQueue
     * const userQueue = await prisma.userQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserQueueUpdateArgs>(args: SelectSubset<T, UserQueueUpdateArgs<ExtArgs>>): Prisma__UserQueueClient<$Result.GetResult<Prisma.$UserQueuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserQueues.
     * @param {UserQueueDeleteManyArgs} args - Arguments to filter UserQueues to delete.
     * @example
     * // Delete a few UserQueues
     * const { count } = await prisma.userQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserQueueDeleteManyArgs>(args?: SelectSubset<T, UserQueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserQueues
     * const userQueue = await prisma.userQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserQueueUpdateManyArgs>(args: SelectSubset<T, UserQueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserQueues and returns the data updated in the database.
     * @param {UserQueueUpdateManyAndReturnArgs} args - Arguments to update many UserQueues.
     * @example
     * // Update many UserQueues
     * const userQueue = await prisma.userQueue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserQueues and only return the `id`
     * const userQueueWithIdOnly = await prisma.userQueue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserQueueUpdateManyAndReturnArgs>(args: SelectSubset<T, UserQueueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQueuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserQueue.
     * @param {UserQueueUpsertArgs} args - Arguments to update or create a UserQueue.
     * @example
     * // Update or create a UserQueue
     * const userQueue = await prisma.userQueue.upsert({
     *   create: {
     *     // ... data to create a UserQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserQueue we want to update
     *   }
     * })
     */
    upsert<T extends UserQueueUpsertArgs>(args: SelectSubset<T, UserQueueUpsertArgs<ExtArgs>>): Prisma__UserQueueClient<$Result.GetResult<Prisma.$UserQueuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQueueCountArgs} args - Arguments to filter UserQueues to count.
     * @example
     * // Count the number of UserQueues
     * const count = await prisma.userQueue.count({
     *   where: {
     *     // ... the filter for the UserQueues we want to count
     *   }
     * })
    **/
    count<T extends UserQueueCountArgs>(
      args?: Subset<T, UserQueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserQueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserQueueAggregateArgs>(args: Subset<T, UserQueueAggregateArgs>): Prisma.PrismaPromise<GetUserQueueAggregateType<T>>

    /**
     * Group by UserQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserQueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserQueueGroupByArgs['orderBy'] }
        : { orderBy?: UserQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserQueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserQueue model
   */
  readonly fields: UserQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserQueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserQueue model
   */
  interface UserQueueFieldRefs {
    readonly id: FieldRef<"UserQueue", 'String'>
    readonly position: FieldRef<"UserQueue", 'Int'>
    readonly createdAt: FieldRef<"UserQueue", 'DateTime'>
    readonly userId: FieldRef<"UserQueue", 'String'>
    readonly songId: FieldRef<"UserQueue", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserQueue findUnique
   */
  export type UserQueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQueue
     */
    select?: UserQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQueue
     */
    omit?: UserQueueOmit<ExtArgs> | null
    /**
     * Filter, which UserQueue to fetch.
     */
    where: UserQueueWhereUniqueInput
  }

  /**
   * UserQueue findUniqueOrThrow
   */
  export type UserQueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQueue
     */
    select?: UserQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQueue
     */
    omit?: UserQueueOmit<ExtArgs> | null
    /**
     * Filter, which UserQueue to fetch.
     */
    where: UserQueueWhereUniqueInput
  }

  /**
   * UserQueue findFirst
   */
  export type UserQueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQueue
     */
    select?: UserQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQueue
     */
    omit?: UserQueueOmit<ExtArgs> | null
    /**
     * Filter, which UserQueue to fetch.
     */
    where?: UserQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQueues to fetch.
     */
    orderBy?: UserQueueOrderByWithRelationInput | UserQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserQueues.
     */
    cursor?: UserQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserQueues.
     */
    distinct?: UserQueueScalarFieldEnum | UserQueueScalarFieldEnum[]
  }

  /**
   * UserQueue findFirstOrThrow
   */
  export type UserQueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQueue
     */
    select?: UserQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQueue
     */
    omit?: UserQueueOmit<ExtArgs> | null
    /**
     * Filter, which UserQueue to fetch.
     */
    where?: UserQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQueues to fetch.
     */
    orderBy?: UserQueueOrderByWithRelationInput | UserQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserQueues.
     */
    cursor?: UserQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserQueues.
     */
    distinct?: UserQueueScalarFieldEnum | UserQueueScalarFieldEnum[]
  }

  /**
   * UserQueue findMany
   */
  export type UserQueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQueue
     */
    select?: UserQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQueue
     */
    omit?: UserQueueOmit<ExtArgs> | null
    /**
     * Filter, which UserQueues to fetch.
     */
    where?: UserQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQueues to fetch.
     */
    orderBy?: UserQueueOrderByWithRelationInput | UserQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserQueues.
     */
    cursor?: UserQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQueues.
     */
    skip?: number
    distinct?: UserQueueScalarFieldEnum | UserQueueScalarFieldEnum[]
  }

  /**
   * UserQueue create
   */
  export type UserQueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQueue
     */
    select?: UserQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQueue
     */
    omit?: UserQueueOmit<ExtArgs> | null
    /**
     * The data needed to create a UserQueue.
     */
    data: XOR<UserQueueCreateInput, UserQueueUncheckedCreateInput>
  }

  /**
   * UserQueue createMany
   */
  export type UserQueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserQueues.
     */
    data: UserQueueCreateManyInput | UserQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserQueue createManyAndReturn
   */
  export type UserQueueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQueue
     */
    select?: UserQueueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserQueue
     */
    omit?: UserQueueOmit<ExtArgs> | null
    /**
     * The data used to create many UserQueues.
     */
    data: UserQueueCreateManyInput | UserQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserQueue update
   */
  export type UserQueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQueue
     */
    select?: UserQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQueue
     */
    omit?: UserQueueOmit<ExtArgs> | null
    /**
     * The data needed to update a UserQueue.
     */
    data: XOR<UserQueueUpdateInput, UserQueueUncheckedUpdateInput>
    /**
     * Choose, which UserQueue to update.
     */
    where: UserQueueWhereUniqueInput
  }

  /**
   * UserQueue updateMany
   */
  export type UserQueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserQueues.
     */
    data: XOR<UserQueueUpdateManyMutationInput, UserQueueUncheckedUpdateManyInput>
    /**
     * Filter which UserQueues to update
     */
    where?: UserQueueWhereInput
    /**
     * Limit how many UserQueues to update.
     */
    limit?: number
  }

  /**
   * UserQueue updateManyAndReturn
   */
  export type UserQueueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQueue
     */
    select?: UserQueueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserQueue
     */
    omit?: UserQueueOmit<ExtArgs> | null
    /**
     * The data used to update UserQueues.
     */
    data: XOR<UserQueueUpdateManyMutationInput, UserQueueUncheckedUpdateManyInput>
    /**
     * Filter which UserQueues to update
     */
    where?: UserQueueWhereInput
    /**
     * Limit how many UserQueues to update.
     */
    limit?: number
  }

  /**
   * UserQueue upsert
   */
  export type UserQueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQueue
     */
    select?: UserQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQueue
     */
    omit?: UserQueueOmit<ExtArgs> | null
    /**
     * The filter to search for the UserQueue to update in case it exists.
     */
    where: UserQueueWhereUniqueInput
    /**
     * In case the UserQueue found by the `where` argument doesn't exist, create a new UserQueue with this data.
     */
    create: XOR<UserQueueCreateInput, UserQueueUncheckedCreateInput>
    /**
     * In case the UserQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserQueueUpdateInput, UserQueueUncheckedUpdateInput>
  }

  /**
   * UserQueue delete
   */
  export type UserQueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQueue
     */
    select?: UserQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQueue
     */
    omit?: UserQueueOmit<ExtArgs> | null
    /**
     * Filter which UserQueue to delete.
     */
    where: UserQueueWhereUniqueInput
  }

  /**
   * UserQueue deleteMany
   */
  export type UserQueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserQueues to delete
     */
    where?: UserQueueWhereInput
    /**
     * Limit how many UserQueues to delete.
     */
    limit?: number
  }

  /**
   * UserQueue without action
   */
  export type UserQueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQueue
     */
    select?: UserQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQueue
     */
    omit?: UserQueueOmit<ExtArgs> | null
  }


  /**
   * Model Chart
   */

  export type AggregateChart = {
    _count: ChartCountAggregateOutputType | null
    _min: ChartMinAggregateOutputType | null
    _max: ChartMaxAggregateOutputType | null
  }

  export type ChartMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.ChartType | null
    period: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
  }

  export type ChartMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.ChartType | null
    period: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
  }

  export type ChartCountAggregateOutputType = {
    id: number
    name: number
    type: number
    period: number
    startDate: number
    endDate: number
    createdAt: number
    _all: number
  }


  export type ChartMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    period?: true
    startDate?: true
    endDate?: true
    createdAt?: true
  }

  export type ChartMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    period?: true
    startDate?: true
    endDate?: true
    createdAt?: true
  }

  export type ChartCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    period?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    _all?: true
  }

  export type ChartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chart to aggregate.
     */
    where?: ChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Charts to fetch.
     */
    orderBy?: ChartOrderByWithRelationInput | ChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Charts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Charts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Charts
    **/
    _count?: true | ChartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChartMaxAggregateInputType
  }

  export type GetChartAggregateType<T extends ChartAggregateArgs> = {
        [P in keyof T & keyof AggregateChart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChart[P]>
      : GetScalarType<T[P], AggregateChart[P]>
  }




  export type ChartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChartWhereInput
    orderBy?: ChartOrderByWithAggregationInput | ChartOrderByWithAggregationInput[]
    by: ChartScalarFieldEnum[] | ChartScalarFieldEnum
    having?: ChartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChartCountAggregateInputType | true
    _min?: ChartMinAggregateInputType
    _max?: ChartMaxAggregateInputType
  }

  export type ChartGroupByOutputType = {
    id: string
    name: string
    type: $Enums.ChartType
    period: string
    startDate: Date
    endDate: Date
    createdAt: Date
    _count: ChartCountAggregateOutputType | null
    _min: ChartMinAggregateOutputType | null
    _max: ChartMaxAggregateOutputType | null
  }

  type GetChartGroupByPayload<T extends ChartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChartGroupByOutputType[P]>
            : GetScalarType<T[P], ChartGroupByOutputType[P]>
        }
      >
    >


  export type ChartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    period?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    items?: boolean | Chart$itemsArgs<ExtArgs>
    _count?: boolean | ChartCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chart"]>

  export type ChartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    period?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["chart"]>

  export type ChartSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    period?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["chart"]>

  export type ChartSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    period?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
  }

  export type ChartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "period" | "startDate" | "endDate" | "createdAt", ExtArgs["result"]["chart"]>
  export type ChartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | Chart$itemsArgs<ExtArgs>
    _count?: boolean | ChartCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ChartIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ChartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chart"
    objects: {
      items: Prisma.$ChartItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.ChartType
      period: string
      startDate: Date
      endDate: Date
      createdAt: Date
    }, ExtArgs["result"]["chart"]>
    composites: {}
  }

  type ChartGetPayload<S extends boolean | null | undefined | ChartDefaultArgs> = $Result.GetResult<Prisma.$ChartPayload, S>

  type ChartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChartCountAggregateInputType | true
    }

  export interface ChartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chart'], meta: { name: 'Chart' } }
    /**
     * Find zero or one Chart that matches the filter.
     * @param {ChartFindUniqueArgs} args - Arguments to find a Chart
     * @example
     * // Get one Chart
     * const chart = await prisma.chart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChartFindUniqueArgs>(args: SelectSubset<T, ChartFindUniqueArgs<ExtArgs>>): Prisma__ChartClient<$Result.GetResult<Prisma.$ChartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChartFindUniqueOrThrowArgs} args - Arguments to find a Chart
     * @example
     * // Get one Chart
     * const chart = await prisma.chart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChartFindUniqueOrThrowArgs>(args: SelectSubset<T, ChartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChartClient<$Result.GetResult<Prisma.$ChartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartFindFirstArgs} args - Arguments to find a Chart
     * @example
     * // Get one Chart
     * const chart = await prisma.chart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChartFindFirstArgs>(args?: SelectSubset<T, ChartFindFirstArgs<ExtArgs>>): Prisma__ChartClient<$Result.GetResult<Prisma.$ChartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartFindFirstOrThrowArgs} args - Arguments to find a Chart
     * @example
     * // Get one Chart
     * const chart = await prisma.chart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChartFindFirstOrThrowArgs>(args?: SelectSubset<T, ChartFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChartClient<$Result.GetResult<Prisma.$ChartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Charts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Charts
     * const charts = await prisma.chart.findMany()
     * 
     * // Get first 10 Charts
     * const charts = await prisma.chart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chartWithIdOnly = await prisma.chart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChartFindManyArgs>(args?: SelectSubset<T, ChartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chart.
     * @param {ChartCreateArgs} args - Arguments to create a Chart.
     * @example
     * // Create one Chart
     * const Chart = await prisma.chart.create({
     *   data: {
     *     // ... data to create a Chart
     *   }
     * })
     * 
     */
    create<T extends ChartCreateArgs>(args: SelectSubset<T, ChartCreateArgs<ExtArgs>>): Prisma__ChartClient<$Result.GetResult<Prisma.$ChartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Charts.
     * @param {ChartCreateManyArgs} args - Arguments to create many Charts.
     * @example
     * // Create many Charts
     * const chart = await prisma.chart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChartCreateManyArgs>(args?: SelectSubset<T, ChartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Charts and returns the data saved in the database.
     * @param {ChartCreateManyAndReturnArgs} args - Arguments to create many Charts.
     * @example
     * // Create many Charts
     * const chart = await prisma.chart.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Charts and only return the `id`
     * const chartWithIdOnly = await prisma.chart.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChartCreateManyAndReturnArgs>(args?: SelectSubset<T, ChartCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chart.
     * @param {ChartDeleteArgs} args - Arguments to delete one Chart.
     * @example
     * // Delete one Chart
     * const Chart = await prisma.chart.delete({
     *   where: {
     *     // ... filter to delete one Chart
     *   }
     * })
     * 
     */
    delete<T extends ChartDeleteArgs>(args: SelectSubset<T, ChartDeleteArgs<ExtArgs>>): Prisma__ChartClient<$Result.GetResult<Prisma.$ChartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chart.
     * @param {ChartUpdateArgs} args - Arguments to update one Chart.
     * @example
     * // Update one Chart
     * const chart = await prisma.chart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChartUpdateArgs>(args: SelectSubset<T, ChartUpdateArgs<ExtArgs>>): Prisma__ChartClient<$Result.GetResult<Prisma.$ChartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Charts.
     * @param {ChartDeleteManyArgs} args - Arguments to filter Charts to delete.
     * @example
     * // Delete a few Charts
     * const { count } = await prisma.chart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChartDeleteManyArgs>(args?: SelectSubset<T, ChartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Charts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Charts
     * const chart = await prisma.chart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChartUpdateManyArgs>(args: SelectSubset<T, ChartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Charts and returns the data updated in the database.
     * @param {ChartUpdateManyAndReturnArgs} args - Arguments to update many Charts.
     * @example
     * // Update many Charts
     * const chart = await prisma.chart.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Charts and only return the `id`
     * const chartWithIdOnly = await prisma.chart.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChartUpdateManyAndReturnArgs>(args: SelectSubset<T, ChartUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chart.
     * @param {ChartUpsertArgs} args - Arguments to update or create a Chart.
     * @example
     * // Update or create a Chart
     * const chart = await prisma.chart.upsert({
     *   create: {
     *     // ... data to create a Chart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chart we want to update
     *   }
     * })
     */
    upsert<T extends ChartUpsertArgs>(args: SelectSubset<T, ChartUpsertArgs<ExtArgs>>): Prisma__ChartClient<$Result.GetResult<Prisma.$ChartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Charts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartCountArgs} args - Arguments to filter Charts to count.
     * @example
     * // Count the number of Charts
     * const count = await prisma.chart.count({
     *   where: {
     *     // ... the filter for the Charts we want to count
     *   }
     * })
    **/
    count<T extends ChartCountArgs>(
      args?: Subset<T, ChartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChartAggregateArgs>(args: Subset<T, ChartAggregateArgs>): Prisma.PrismaPromise<GetChartAggregateType<T>>

    /**
     * Group by Chart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChartGroupByArgs['orderBy'] }
        : { orderBy?: ChartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chart model
   */
  readonly fields: ChartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends Chart$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Chart$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chart model
   */
  interface ChartFieldRefs {
    readonly id: FieldRef<"Chart", 'String'>
    readonly name: FieldRef<"Chart", 'String'>
    readonly type: FieldRef<"Chart", 'ChartType'>
    readonly period: FieldRef<"Chart", 'String'>
    readonly startDate: FieldRef<"Chart", 'DateTime'>
    readonly endDate: FieldRef<"Chart", 'DateTime'>
    readonly createdAt: FieldRef<"Chart", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Chart findUnique
   */
  export type ChartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chart
     */
    select?: ChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chart
     */
    omit?: ChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartInclude<ExtArgs> | null
    /**
     * Filter, which Chart to fetch.
     */
    where: ChartWhereUniqueInput
  }

  /**
   * Chart findUniqueOrThrow
   */
  export type ChartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chart
     */
    select?: ChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chart
     */
    omit?: ChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartInclude<ExtArgs> | null
    /**
     * Filter, which Chart to fetch.
     */
    where: ChartWhereUniqueInput
  }

  /**
   * Chart findFirst
   */
  export type ChartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chart
     */
    select?: ChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chart
     */
    omit?: ChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartInclude<ExtArgs> | null
    /**
     * Filter, which Chart to fetch.
     */
    where?: ChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Charts to fetch.
     */
    orderBy?: ChartOrderByWithRelationInput | ChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Charts.
     */
    cursor?: ChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Charts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Charts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Charts.
     */
    distinct?: ChartScalarFieldEnum | ChartScalarFieldEnum[]
  }

  /**
   * Chart findFirstOrThrow
   */
  export type ChartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chart
     */
    select?: ChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chart
     */
    omit?: ChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartInclude<ExtArgs> | null
    /**
     * Filter, which Chart to fetch.
     */
    where?: ChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Charts to fetch.
     */
    orderBy?: ChartOrderByWithRelationInput | ChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Charts.
     */
    cursor?: ChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Charts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Charts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Charts.
     */
    distinct?: ChartScalarFieldEnum | ChartScalarFieldEnum[]
  }

  /**
   * Chart findMany
   */
  export type ChartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chart
     */
    select?: ChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chart
     */
    omit?: ChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartInclude<ExtArgs> | null
    /**
     * Filter, which Charts to fetch.
     */
    where?: ChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Charts to fetch.
     */
    orderBy?: ChartOrderByWithRelationInput | ChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Charts.
     */
    cursor?: ChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Charts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Charts.
     */
    skip?: number
    distinct?: ChartScalarFieldEnum | ChartScalarFieldEnum[]
  }

  /**
   * Chart create
   */
  export type ChartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chart
     */
    select?: ChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chart
     */
    omit?: ChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartInclude<ExtArgs> | null
    /**
     * The data needed to create a Chart.
     */
    data: XOR<ChartCreateInput, ChartUncheckedCreateInput>
  }

  /**
   * Chart createMany
   */
  export type ChartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Charts.
     */
    data: ChartCreateManyInput | ChartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chart createManyAndReturn
   */
  export type ChartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chart
     */
    select?: ChartSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chart
     */
    omit?: ChartOmit<ExtArgs> | null
    /**
     * The data used to create many Charts.
     */
    data: ChartCreateManyInput | ChartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chart update
   */
  export type ChartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chart
     */
    select?: ChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chart
     */
    omit?: ChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartInclude<ExtArgs> | null
    /**
     * The data needed to update a Chart.
     */
    data: XOR<ChartUpdateInput, ChartUncheckedUpdateInput>
    /**
     * Choose, which Chart to update.
     */
    where: ChartWhereUniqueInput
  }

  /**
   * Chart updateMany
   */
  export type ChartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Charts.
     */
    data: XOR<ChartUpdateManyMutationInput, ChartUncheckedUpdateManyInput>
    /**
     * Filter which Charts to update
     */
    where?: ChartWhereInput
    /**
     * Limit how many Charts to update.
     */
    limit?: number
  }

  /**
   * Chart updateManyAndReturn
   */
  export type ChartUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chart
     */
    select?: ChartSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chart
     */
    omit?: ChartOmit<ExtArgs> | null
    /**
     * The data used to update Charts.
     */
    data: XOR<ChartUpdateManyMutationInput, ChartUncheckedUpdateManyInput>
    /**
     * Filter which Charts to update
     */
    where?: ChartWhereInput
    /**
     * Limit how many Charts to update.
     */
    limit?: number
  }

  /**
   * Chart upsert
   */
  export type ChartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chart
     */
    select?: ChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chart
     */
    omit?: ChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartInclude<ExtArgs> | null
    /**
     * The filter to search for the Chart to update in case it exists.
     */
    where: ChartWhereUniqueInput
    /**
     * In case the Chart found by the `where` argument doesn't exist, create a new Chart with this data.
     */
    create: XOR<ChartCreateInput, ChartUncheckedCreateInput>
    /**
     * In case the Chart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChartUpdateInput, ChartUncheckedUpdateInput>
  }

  /**
   * Chart delete
   */
  export type ChartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chart
     */
    select?: ChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chart
     */
    omit?: ChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartInclude<ExtArgs> | null
    /**
     * Filter which Chart to delete.
     */
    where: ChartWhereUniqueInput
  }

  /**
   * Chart deleteMany
   */
  export type ChartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Charts to delete
     */
    where?: ChartWhereInput
    /**
     * Limit how many Charts to delete.
     */
    limit?: number
  }

  /**
   * Chart.items
   */
  export type Chart$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartItem
     */
    select?: ChartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartItem
     */
    omit?: ChartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartItemInclude<ExtArgs> | null
    where?: ChartItemWhereInput
    orderBy?: ChartItemOrderByWithRelationInput | ChartItemOrderByWithRelationInput[]
    cursor?: ChartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChartItemScalarFieldEnum | ChartItemScalarFieldEnum[]
  }

  /**
   * Chart without action
   */
  export type ChartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chart
     */
    select?: ChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chart
     */
    omit?: ChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartInclude<ExtArgs> | null
  }


  /**
   * Model ChartItem
   */

  export type AggregateChartItem = {
    _count: ChartItemCountAggregateOutputType | null
    _avg: ChartItemAvgAggregateOutputType | null
    _sum: ChartItemSumAggregateOutputType | null
    _min: ChartItemMinAggregateOutputType | null
    _max: ChartItemMaxAggregateOutputType | null
  }

  export type ChartItemAvgAggregateOutputType = {
    position: number | null
    plays: number | null
  }

  export type ChartItemSumAggregateOutputType = {
    position: number | null
    plays: number | null
  }

  export type ChartItemMinAggregateOutputType = {
    chartId: string | null
    position: number | null
    itemType: string | null
    itemId: string | null
    plays: number | null
  }

  export type ChartItemMaxAggregateOutputType = {
    chartId: string | null
    position: number | null
    itemType: string | null
    itemId: string | null
    plays: number | null
  }

  export type ChartItemCountAggregateOutputType = {
    chartId: number
    position: number
    itemType: number
    itemId: number
    plays: number
    _all: number
  }


  export type ChartItemAvgAggregateInputType = {
    position?: true
    plays?: true
  }

  export type ChartItemSumAggregateInputType = {
    position?: true
    plays?: true
  }

  export type ChartItemMinAggregateInputType = {
    chartId?: true
    position?: true
    itemType?: true
    itemId?: true
    plays?: true
  }

  export type ChartItemMaxAggregateInputType = {
    chartId?: true
    position?: true
    itemType?: true
    itemId?: true
    plays?: true
  }

  export type ChartItemCountAggregateInputType = {
    chartId?: true
    position?: true
    itemType?: true
    itemId?: true
    plays?: true
    _all?: true
  }

  export type ChartItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChartItem to aggregate.
     */
    where?: ChartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartItems to fetch.
     */
    orderBy?: ChartItemOrderByWithRelationInput | ChartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChartItems
    **/
    _count?: true | ChartItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChartItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChartItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChartItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChartItemMaxAggregateInputType
  }

  export type GetChartItemAggregateType<T extends ChartItemAggregateArgs> = {
        [P in keyof T & keyof AggregateChartItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChartItem[P]>
      : GetScalarType<T[P], AggregateChartItem[P]>
  }




  export type ChartItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChartItemWhereInput
    orderBy?: ChartItemOrderByWithAggregationInput | ChartItemOrderByWithAggregationInput[]
    by: ChartItemScalarFieldEnum[] | ChartItemScalarFieldEnum
    having?: ChartItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChartItemCountAggregateInputType | true
    _avg?: ChartItemAvgAggregateInputType
    _sum?: ChartItemSumAggregateInputType
    _min?: ChartItemMinAggregateInputType
    _max?: ChartItemMaxAggregateInputType
  }

  export type ChartItemGroupByOutputType = {
    chartId: string
    position: number
    itemType: string
    itemId: string
    plays: number
    _count: ChartItemCountAggregateOutputType | null
    _avg: ChartItemAvgAggregateOutputType | null
    _sum: ChartItemSumAggregateOutputType | null
    _min: ChartItemMinAggregateOutputType | null
    _max: ChartItemMaxAggregateOutputType | null
  }

  type GetChartItemGroupByPayload<T extends ChartItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChartItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChartItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChartItemGroupByOutputType[P]>
            : GetScalarType<T[P], ChartItemGroupByOutputType[P]>
        }
      >
    >


  export type ChartItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chartId?: boolean
    position?: boolean
    itemType?: boolean
    itemId?: boolean
    plays?: boolean
    chart?: boolean | ChartDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chartItem"]>

  export type ChartItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chartId?: boolean
    position?: boolean
    itemType?: boolean
    itemId?: boolean
    plays?: boolean
    chart?: boolean | ChartDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chartItem"]>

  export type ChartItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chartId?: boolean
    position?: boolean
    itemType?: boolean
    itemId?: boolean
    plays?: boolean
    chart?: boolean | ChartDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chartItem"]>

  export type ChartItemSelectScalar = {
    chartId?: boolean
    position?: boolean
    itemType?: boolean
    itemId?: boolean
    plays?: boolean
  }

  export type ChartItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"chartId" | "position" | "itemType" | "itemId" | "plays", ExtArgs["result"]["chartItem"]>
  export type ChartItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chart?: boolean | ChartDefaultArgs<ExtArgs>
  }
  export type ChartItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chart?: boolean | ChartDefaultArgs<ExtArgs>
  }
  export type ChartItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chart?: boolean | ChartDefaultArgs<ExtArgs>
  }

  export type $ChartItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChartItem"
    objects: {
      chart: Prisma.$ChartPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      chartId: string
      position: number
      itemType: string
      itemId: string
      plays: number
    }, ExtArgs["result"]["chartItem"]>
    composites: {}
  }

  type ChartItemGetPayload<S extends boolean | null | undefined | ChartItemDefaultArgs> = $Result.GetResult<Prisma.$ChartItemPayload, S>

  type ChartItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChartItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChartItemCountAggregateInputType | true
    }

  export interface ChartItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChartItem'], meta: { name: 'ChartItem' } }
    /**
     * Find zero or one ChartItem that matches the filter.
     * @param {ChartItemFindUniqueArgs} args - Arguments to find a ChartItem
     * @example
     * // Get one ChartItem
     * const chartItem = await prisma.chartItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChartItemFindUniqueArgs>(args: SelectSubset<T, ChartItemFindUniqueArgs<ExtArgs>>): Prisma__ChartItemClient<$Result.GetResult<Prisma.$ChartItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChartItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChartItemFindUniqueOrThrowArgs} args - Arguments to find a ChartItem
     * @example
     * // Get one ChartItem
     * const chartItem = await prisma.chartItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChartItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ChartItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChartItemClient<$Result.GetResult<Prisma.$ChartItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChartItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartItemFindFirstArgs} args - Arguments to find a ChartItem
     * @example
     * // Get one ChartItem
     * const chartItem = await prisma.chartItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChartItemFindFirstArgs>(args?: SelectSubset<T, ChartItemFindFirstArgs<ExtArgs>>): Prisma__ChartItemClient<$Result.GetResult<Prisma.$ChartItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChartItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartItemFindFirstOrThrowArgs} args - Arguments to find a ChartItem
     * @example
     * // Get one ChartItem
     * const chartItem = await prisma.chartItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChartItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ChartItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChartItemClient<$Result.GetResult<Prisma.$ChartItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChartItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChartItems
     * const chartItems = await prisma.chartItem.findMany()
     * 
     * // Get first 10 ChartItems
     * const chartItems = await prisma.chartItem.findMany({ take: 10 })
     * 
     * // Only select the `chartId`
     * const chartItemWithChartIdOnly = await prisma.chartItem.findMany({ select: { chartId: true } })
     * 
     */
    findMany<T extends ChartItemFindManyArgs>(args?: SelectSubset<T, ChartItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChartItem.
     * @param {ChartItemCreateArgs} args - Arguments to create a ChartItem.
     * @example
     * // Create one ChartItem
     * const ChartItem = await prisma.chartItem.create({
     *   data: {
     *     // ... data to create a ChartItem
     *   }
     * })
     * 
     */
    create<T extends ChartItemCreateArgs>(args: SelectSubset<T, ChartItemCreateArgs<ExtArgs>>): Prisma__ChartItemClient<$Result.GetResult<Prisma.$ChartItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChartItems.
     * @param {ChartItemCreateManyArgs} args - Arguments to create many ChartItems.
     * @example
     * // Create many ChartItems
     * const chartItem = await prisma.chartItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChartItemCreateManyArgs>(args?: SelectSubset<T, ChartItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChartItems and returns the data saved in the database.
     * @param {ChartItemCreateManyAndReturnArgs} args - Arguments to create many ChartItems.
     * @example
     * // Create many ChartItems
     * const chartItem = await prisma.chartItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChartItems and only return the `chartId`
     * const chartItemWithChartIdOnly = await prisma.chartItem.createManyAndReturn({
     *   select: { chartId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChartItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ChartItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChartItem.
     * @param {ChartItemDeleteArgs} args - Arguments to delete one ChartItem.
     * @example
     * // Delete one ChartItem
     * const ChartItem = await prisma.chartItem.delete({
     *   where: {
     *     // ... filter to delete one ChartItem
     *   }
     * })
     * 
     */
    delete<T extends ChartItemDeleteArgs>(args: SelectSubset<T, ChartItemDeleteArgs<ExtArgs>>): Prisma__ChartItemClient<$Result.GetResult<Prisma.$ChartItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChartItem.
     * @param {ChartItemUpdateArgs} args - Arguments to update one ChartItem.
     * @example
     * // Update one ChartItem
     * const chartItem = await prisma.chartItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChartItemUpdateArgs>(args: SelectSubset<T, ChartItemUpdateArgs<ExtArgs>>): Prisma__ChartItemClient<$Result.GetResult<Prisma.$ChartItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChartItems.
     * @param {ChartItemDeleteManyArgs} args - Arguments to filter ChartItems to delete.
     * @example
     * // Delete a few ChartItems
     * const { count } = await prisma.chartItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChartItemDeleteManyArgs>(args?: SelectSubset<T, ChartItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChartItems
     * const chartItem = await prisma.chartItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChartItemUpdateManyArgs>(args: SelectSubset<T, ChartItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChartItems and returns the data updated in the database.
     * @param {ChartItemUpdateManyAndReturnArgs} args - Arguments to update many ChartItems.
     * @example
     * // Update many ChartItems
     * const chartItem = await prisma.chartItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChartItems and only return the `chartId`
     * const chartItemWithChartIdOnly = await prisma.chartItem.updateManyAndReturn({
     *   select: { chartId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChartItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ChartItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChartItem.
     * @param {ChartItemUpsertArgs} args - Arguments to update or create a ChartItem.
     * @example
     * // Update or create a ChartItem
     * const chartItem = await prisma.chartItem.upsert({
     *   create: {
     *     // ... data to create a ChartItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChartItem we want to update
     *   }
     * })
     */
    upsert<T extends ChartItemUpsertArgs>(args: SelectSubset<T, ChartItemUpsertArgs<ExtArgs>>): Prisma__ChartItemClient<$Result.GetResult<Prisma.$ChartItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartItemCountArgs} args - Arguments to filter ChartItems to count.
     * @example
     * // Count the number of ChartItems
     * const count = await prisma.chartItem.count({
     *   where: {
     *     // ... the filter for the ChartItems we want to count
     *   }
     * })
    **/
    count<T extends ChartItemCountArgs>(
      args?: Subset<T, ChartItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChartItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChartItemAggregateArgs>(args: Subset<T, ChartItemAggregateArgs>): Prisma.PrismaPromise<GetChartItemAggregateType<T>>

    /**
     * Group by ChartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChartItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChartItemGroupByArgs['orderBy'] }
        : { orderBy?: ChartItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChartItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChartItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChartItem model
   */
  readonly fields: ChartItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChartItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChartItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chart<T extends ChartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChartDefaultArgs<ExtArgs>>): Prisma__ChartClient<$Result.GetResult<Prisma.$ChartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChartItem model
   */
  interface ChartItemFieldRefs {
    readonly chartId: FieldRef<"ChartItem", 'String'>
    readonly position: FieldRef<"ChartItem", 'Int'>
    readonly itemType: FieldRef<"ChartItem", 'String'>
    readonly itemId: FieldRef<"ChartItem", 'String'>
    readonly plays: FieldRef<"ChartItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ChartItem findUnique
   */
  export type ChartItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartItem
     */
    select?: ChartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartItem
     */
    omit?: ChartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartItemInclude<ExtArgs> | null
    /**
     * Filter, which ChartItem to fetch.
     */
    where: ChartItemWhereUniqueInput
  }

  /**
   * ChartItem findUniqueOrThrow
   */
  export type ChartItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartItem
     */
    select?: ChartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartItem
     */
    omit?: ChartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartItemInclude<ExtArgs> | null
    /**
     * Filter, which ChartItem to fetch.
     */
    where: ChartItemWhereUniqueInput
  }

  /**
   * ChartItem findFirst
   */
  export type ChartItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartItem
     */
    select?: ChartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartItem
     */
    omit?: ChartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartItemInclude<ExtArgs> | null
    /**
     * Filter, which ChartItem to fetch.
     */
    where?: ChartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartItems to fetch.
     */
    orderBy?: ChartItemOrderByWithRelationInput | ChartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChartItems.
     */
    cursor?: ChartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChartItems.
     */
    distinct?: ChartItemScalarFieldEnum | ChartItemScalarFieldEnum[]
  }

  /**
   * ChartItem findFirstOrThrow
   */
  export type ChartItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartItem
     */
    select?: ChartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartItem
     */
    omit?: ChartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartItemInclude<ExtArgs> | null
    /**
     * Filter, which ChartItem to fetch.
     */
    where?: ChartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartItems to fetch.
     */
    orderBy?: ChartItemOrderByWithRelationInput | ChartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChartItems.
     */
    cursor?: ChartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChartItems.
     */
    distinct?: ChartItemScalarFieldEnum | ChartItemScalarFieldEnum[]
  }

  /**
   * ChartItem findMany
   */
  export type ChartItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartItem
     */
    select?: ChartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartItem
     */
    omit?: ChartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartItemInclude<ExtArgs> | null
    /**
     * Filter, which ChartItems to fetch.
     */
    where?: ChartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartItems to fetch.
     */
    orderBy?: ChartItemOrderByWithRelationInput | ChartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChartItems.
     */
    cursor?: ChartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartItems.
     */
    skip?: number
    distinct?: ChartItemScalarFieldEnum | ChartItemScalarFieldEnum[]
  }

  /**
   * ChartItem create
   */
  export type ChartItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartItem
     */
    select?: ChartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartItem
     */
    omit?: ChartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ChartItem.
     */
    data: XOR<ChartItemCreateInput, ChartItemUncheckedCreateInput>
  }

  /**
   * ChartItem createMany
   */
  export type ChartItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChartItems.
     */
    data: ChartItemCreateManyInput | ChartItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChartItem createManyAndReturn
   */
  export type ChartItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartItem
     */
    select?: ChartItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChartItem
     */
    omit?: ChartItemOmit<ExtArgs> | null
    /**
     * The data used to create many ChartItems.
     */
    data: ChartItemCreateManyInput | ChartItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChartItem update
   */
  export type ChartItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartItem
     */
    select?: ChartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartItem
     */
    omit?: ChartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ChartItem.
     */
    data: XOR<ChartItemUpdateInput, ChartItemUncheckedUpdateInput>
    /**
     * Choose, which ChartItem to update.
     */
    where: ChartItemWhereUniqueInput
  }

  /**
   * ChartItem updateMany
   */
  export type ChartItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChartItems.
     */
    data: XOR<ChartItemUpdateManyMutationInput, ChartItemUncheckedUpdateManyInput>
    /**
     * Filter which ChartItems to update
     */
    where?: ChartItemWhereInput
    /**
     * Limit how many ChartItems to update.
     */
    limit?: number
  }

  /**
   * ChartItem updateManyAndReturn
   */
  export type ChartItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartItem
     */
    select?: ChartItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChartItem
     */
    omit?: ChartItemOmit<ExtArgs> | null
    /**
     * The data used to update ChartItems.
     */
    data: XOR<ChartItemUpdateManyMutationInput, ChartItemUncheckedUpdateManyInput>
    /**
     * Filter which ChartItems to update
     */
    where?: ChartItemWhereInput
    /**
     * Limit how many ChartItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChartItem upsert
   */
  export type ChartItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartItem
     */
    select?: ChartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartItem
     */
    omit?: ChartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ChartItem to update in case it exists.
     */
    where: ChartItemWhereUniqueInput
    /**
     * In case the ChartItem found by the `where` argument doesn't exist, create a new ChartItem with this data.
     */
    create: XOR<ChartItemCreateInput, ChartItemUncheckedCreateInput>
    /**
     * In case the ChartItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChartItemUpdateInput, ChartItemUncheckedUpdateInput>
  }

  /**
   * ChartItem delete
   */
  export type ChartItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartItem
     */
    select?: ChartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartItem
     */
    omit?: ChartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartItemInclude<ExtArgs> | null
    /**
     * Filter which ChartItem to delete.
     */
    where: ChartItemWhereUniqueInput
  }

  /**
   * ChartItem deleteMany
   */
  export type ChartItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChartItems to delete
     */
    where?: ChartItemWhereInput
    /**
     * Limit how many ChartItems to delete.
     */
    limit?: number
  }

  /**
   * ChartItem without action
   */
  export type ChartItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartItem
     */
    select?: ChartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChartItem
     */
    omit?: ChartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartItemInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    name: 'name',
    password: 'password',
    imageId: 'imageId',
    emailVerified: 'emailVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    bio: 'bio',
    country: 'country',
    dateOfBirth: 'dateOfBirth',
    gender: 'gender'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const UserSubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    autoRenew: 'autoRenew',
    paymentMethod: 'paymentMethod'
  };

  export type UserSubscriptionScalarFieldEnum = (typeof UserSubscriptionScalarFieldEnum)[keyof typeof UserSubscriptionScalarFieldEnum]


  export const ArtistScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    bio: 'bio',
    imageId: 'imageId',
    verified: 'verified',
    monthlyListeners: 'monthlyListeners',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ArtistScalarFieldEnum = (typeof ArtistScalarFieldEnum)[keyof typeof ArtistScalarFieldEnum]


  export const AlbumScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    description: 'description',
    imageId: 'imageId',
    albumType: 'albumType',
    releaseDate: 'releaseDate',
    totalTracks: 'totalTracks',
    duration: 'duration',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    artistId: 'artistId'
  };

  export type AlbumScalarFieldEnum = (typeof AlbumScalarFieldEnum)[keyof typeof AlbumScalarFieldEnum]


  export const SongScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    audioId: 'audioId',
    duration: 'duration',
    trackNumber: 'trackNumber',
    lyrics: 'lyrics',
    isExplicit: 'isExplicit',
    playCount: 'playCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    albumId: 'albumId'
  };

  export type SongScalarFieldEnum = (typeof SongScalarFieldEnum)[keyof typeof SongScalarFieldEnum]


  export const GenreScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    color: 'color'
  };

  export type GenreScalarFieldEnum = (typeof GenreScalarFieldEnum)[keyof typeof GenreScalarFieldEnum]


  export const SongArtistScalarFieldEnum: {
    id: 'id',
    songId: 'songId',
    artistId: 'artistId',
    role: 'role',
    order: 'order'
  };

  export type SongArtistScalarFieldEnum = (typeof SongArtistScalarFieldEnum)[keyof typeof SongArtistScalarFieldEnum]


  export const SongCreditScalarFieldEnum: {
    id: 'id',
    songId: 'songId',
    artistId: 'artistId',
    name: 'name',
    role: 'role',
    details: 'details',
    order: 'order'
  };

  export type SongCreditScalarFieldEnum = (typeof SongCreditScalarFieldEnum)[keyof typeof SongCreditScalarFieldEnum]


  export const SongGenreScalarFieldEnum: {
    songId: 'songId',
    genreId: 'genreId'
  };

  export type SongGenreScalarFieldEnum = (typeof SongGenreScalarFieldEnum)[keyof typeof SongGenreScalarFieldEnum]


  export const AlbumGenreScalarFieldEnum: {
    albumId: 'albumId',
    genreId: 'genreId'
  };

  export type AlbumGenreScalarFieldEnum = (typeof AlbumGenreScalarFieldEnum)[keyof typeof AlbumGenreScalarFieldEnum]


  export const ArtistGenreScalarFieldEnum: {
    artistId: 'artistId',
    genreId: 'genreId'
  };

  export type ArtistGenreScalarFieldEnum = (typeof ArtistGenreScalarFieldEnum)[keyof typeof ArtistGenreScalarFieldEnum]


  export const PlaylistScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    imageId: 'imageId',
    isPublic: 'isPublic',
    isOfficial: 'isOfficial',
    totalTracks: 'totalTracks',
    duration: 'duration',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type PlaylistScalarFieldEnum = (typeof PlaylistScalarFieldEnum)[keyof typeof PlaylistScalarFieldEnum]


  export const PlaylistItemScalarFieldEnum: {
    id: 'id',
    position: 'position',
    addedAt: 'addedAt',
    playlistId: 'playlistId',
    songId: 'songId'
  };

  export type PlaylistItemScalarFieldEnum = (typeof PlaylistItemScalarFieldEnum)[keyof typeof PlaylistItemScalarFieldEnum]


  export const UserLikedSongScalarFieldEnum: {
    userId: 'userId',
    songId: 'songId',
    likedAt: 'likedAt'
  };

  export type UserLikedSongScalarFieldEnum = (typeof UserLikedSongScalarFieldEnum)[keyof typeof UserLikedSongScalarFieldEnum]


  export const UserLikedAlbumScalarFieldEnum: {
    userId: 'userId',
    albumId: 'albumId',
    likedAt: 'likedAt'
  };

  export type UserLikedAlbumScalarFieldEnum = (typeof UserLikedAlbumScalarFieldEnum)[keyof typeof UserLikedAlbumScalarFieldEnum]


  export const UserLikedArtistScalarFieldEnum: {
    userId: 'userId',
    artistId: 'artistId',
    likedAt: 'likedAt'
  };

  export type UserLikedArtistScalarFieldEnum = (typeof UserLikedArtistScalarFieldEnum)[keyof typeof UserLikedArtistScalarFieldEnum]


  export const UserLikedPlaylistScalarFieldEnum: {
    userId: 'userId',
    playlistId: 'playlistId',
    likedAt: 'likedAt'
  };

  export type UserLikedPlaylistScalarFieldEnum = (typeof UserLikedPlaylistScalarFieldEnum)[keyof typeof UserLikedPlaylistScalarFieldEnum]


  export const UserFollowScalarFieldEnum: {
    followerId: 'followerId',
    followingId: 'followingId',
    followedAt: 'followedAt'
  };

  export type UserFollowScalarFieldEnum = (typeof UserFollowScalarFieldEnum)[keyof typeof UserFollowScalarFieldEnum]


  export const PlayHistoryScalarFieldEnum: {
    id: 'id',
    playedAt: 'playedAt',
    duration: 'duration',
    deviceType: 'deviceType',
    userId: 'userId',
    songId: 'songId'
  };

  export type PlayHistoryScalarFieldEnum = (typeof PlayHistoryScalarFieldEnum)[keyof typeof PlayHistoryScalarFieldEnum]


  export const SearchHistoryScalarFieldEnum: {
    id: 'id',
    query: 'query',
    resultType: 'resultType',
    resultId: 'resultId',
    searchedAt: 'searchedAt',
    userId: 'userId'
  };

  export type SearchHistoryScalarFieldEnum = (typeof SearchHistoryScalarFieldEnum)[keyof typeof SearchHistoryScalarFieldEnum]


  export const UserRecommendationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    targetId: 'targetId',
    score: 'score',
    reason: 'reason',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type UserRecommendationScalarFieldEnum = (typeof UserRecommendationScalarFieldEnum)[keyof typeof UserRecommendationScalarFieldEnum]


  export const UserQueueScalarFieldEnum: {
    id: 'id',
    position: 'position',
    createdAt: 'createdAt',
    userId: 'userId',
    songId: 'songId'
  };

  export type UserQueueScalarFieldEnum = (typeof UserQueueScalarFieldEnum)[keyof typeof UserQueueScalarFieldEnum]


  export const ChartScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    period: 'period',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt'
  };

  export type ChartScalarFieldEnum = (typeof ChartScalarFieldEnum)[keyof typeof ChartScalarFieldEnum]


  export const ChartItemScalarFieldEnum: {
    chartId: 'chartId',
    position: 'position',
    itemType: 'itemType',
    itemId: 'itemId',
    plays: 'plays'
  };

  export type ChartItemScalarFieldEnum = (typeof ChartItemScalarFieldEnum)[keyof typeof ChartItemScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'SubscriptionType'
   */
  export type EnumSubscriptionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionType'>
    


  /**
   * Reference to a field of type 'SubscriptionType[]'
   */
  export type ListEnumSubscriptionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionType[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'AlbumType'
   */
  export type EnumAlbumTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlbumType'>
    


  /**
   * Reference to a field of type 'AlbumType[]'
   */
  export type ListEnumAlbumTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlbumType[]'>
    


  /**
   * Reference to a field of type 'ArtistRole'
   */
  export type EnumArtistRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ArtistRole'>
    


  /**
   * Reference to a field of type 'ArtistRole[]'
   */
  export type ListEnumArtistRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ArtistRole[]'>
    


  /**
   * Reference to a field of type 'CreditRole'
   */
  export type EnumCreditRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreditRole'>
    


  /**
   * Reference to a field of type 'CreditRole[]'
   */
  export type ListEnumCreditRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreditRole[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ChartType'
   */
  export type EnumChartTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChartType'>
    


  /**
   * Reference to a field of type 'ChartType[]'
   */
  export type ListEnumChartTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChartType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    imageId?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    bio?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    gender?: EnumGenderNullableFilter<"User"> | $Enums.Gender | null
    subscription?: XOR<UserSubscriptionNullableScalarRelationFilter, UserSubscriptionWhereInput> | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    playlists?: PlaylistListRelationFilter
    likedSongs?: UserLikedSongListRelationFilter
    likedAlbums?: UserLikedAlbumListRelationFilter
    likedPlaylists?: UserLikedPlaylistListRelationFilter
    likedArtists?: UserLikedArtistListRelationFilter
    playHistory?: PlayHistoryListRelationFilter
    searchHistory?: SearchHistoryListRelationFilter
    followers?: UserFollowListRelationFilter
    following?: UserFollowListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    imageId?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bio?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    subscription?: UserSubscriptionOrderByWithRelationInput
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    playlists?: PlaylistOrderByRelationAggregateInput
    likedSongs?: UserLikedSongOrderByRelationAggregateInput
    likedAlbums?: UserLikedAlbumOrderByRelationAggregateInput
    likedPlaylists?: UserLikedPlaylistOrderByRelationAggregateInput
    likedArtists?: UserLikedArtistOrderByRelationAggregateInput
    playHistory?: PlayHistoryOrderByRelationAggregateInput
    searchHistory?: SearchHistoryOrderByRelationAggregateInput
    followers?: UserFollowOrderByRelationAggregateInput
    following?: UserFollowOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    imageId?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    bio?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    gender?: EnumGenderNullableFilter<"User"> | $Enums.Gender | null
    subscription?: XOR<UserSubscriptionNullableScalarRelationFilter, UserSubscriptionWhereInput> | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    playlists?: PlaylistListRelationFilter
    likedSongs?: UserLikedSongListRelationFilter
    likedAlbums?: UserLikedAlbumListRelationFilter
    likedPlaylists?: UserLikedPlaylistListRelationFilter
    likedArtists?: UserLikedArtistListRelationFilter
    playHistory?: PlayHistoryListRelationFilter
    searchHistory?: SearchHistoryListRelationFilter
    followers?: UserFollowListRelationFilter
    following?: UserFollowListRelationFilter
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    imageId?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bio?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    imageId?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    country?: StringNullableWithAggregatesFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    gender?: EnumGenderNullableWithAggregatesFilter<"User"> | $Enums.Gender | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type UserSubscriptionWhereInput = {
    AND?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    OR?: UserSubscriptionWhereInput[]
    NOT?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    id?: StringFilter<"UserSubscription"> | string
    userId?: StringFilter<"UserSubscription"> | string
    type?: EnumSubscriptionTypeFilter<"UserSubscription"> | $Enums.SubscriptionType
    status?: EnumSubscriptionStatusFilter<"UserSubscription"> | $Enums.SubscriptionStatus
    startDate?: DateTimeFilter<"UserSubscription"> | Date | string
    endDate?: DateTimeNullableFilter<"UserSubscription"> | Date | string | null
    autoRenew?: BoolFilter<"UserSubscription"> | boolean
    paymentMethod?: StringNullableFilter<"UserSubscription"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    autoRenew?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    OR?: UserSubscriptionWhereInput[]
    NOT?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    type?: EnumSubscriptionTypeFilter<"UserSubscription"> | $Enums.SubscriptionType
    status?: EnumSubscriptionStatusFilter<"UserSubscription"> | $Enums.SubscriptionStatus
    startDate?: DateTimeFilter<"UserSubscription"> | Date | string
    endDate?: DateTimeNullableFilter<"UserSubscription"> | Date | string | null
    autoRenew?: BoolFilter<"UserSubscription"> | boolean
    paymentMethod?: StringNullableFilter<"UserSubscription"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    autoRenew?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    _count?: UserSubscriptionCountOrderByAggregateInput
    _max?: UserSubscriptionMaxOrderByAggregateInput
    _min?: UserSubscriptionMinOrderByAggregateInput
  }

  export type UserSubscriptionScalarWhereWithAggregatesInput = {
    AND?: UserSubscriptionScalarWhereWithAggregatesInput | UserSubscriptionScalarWhereWithAggregatesInput[]
    OR?: UserSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: UserSubscriptionScalarWhereWithAggregatesInput | UserSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSubscription"> | string
    userId?: StringWithAggregatesFilter<"UserSubscription"> | string
    type?: EnumSubscriptionTypeWithAggregatesFilter<"UserSubscription"> | $Enums.SubscriptionType
    status?: EnumSubscriptionStatusWithAggregatesFilter<"UserSubscription"> | $Enums.SubscriptionStatus
    startDate?: DateTimeWithAggregatesFilter<"UserSubscription"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"UserSubscription"> | Date | string | null
    autoRenew?: BoolWithAggregatesFilter<"UserSubscription"> | boolean
    paymentMethod?: StringNullableWithAggregatesFilter<"UserSubscription"> | string | null
  }

  export type ArtistWhereInput = {
    AND?: ArtistWhereInput | ArtistWhereInput[]
    OR?: ArtistWhereInput[]
    NOT?: ArtistWhereInput | ArtistWhereInput[]
    id?: StringFilter<"Artist"> | string
    name?: StringFilter<"Artist"> | string
    slug?: StringFilter<"Artist"> | string
    bio?: StringNullableFilter<"Artist"> | string | null
    imageId?: StringFilter<"Artist"> | string
    verified?: BoolFilter<"Artist"> | boolean
    monthlyListeners?: IntFilter<"Artist"> | number
    createdAt?: DateTimeFilter<"Artist"> | Date | string
    updatedAt?: DateTimeFilter<"Artist"> | Date | string
    albums?: AlbumListRelationFilter
    songs?: SongArtistListRelationFilter
    genres?: ArtistGenreListRelationFilter
    likedBy?: UserLikedArtistListRelationFilter
    credits?: SongCreditListRelationFilter
  }

  export type ArtistOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    bio?: SortOrderInput | SortOrder
    imageId?: SortOrder
    verified?: SortOrder
    monthlyListeners?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    albums?: AlbumOrderByRelationAggregateInput
    songs?: SongArtistOrderByRelationAggregateInput
    genres?: ArtistGenreOrderByRelationAggregateInput
    likedBy?: UserLikedArtistOrderByRelationAggregateInput
    credits?: SongCreditOrderByRelationAggregateInput
  }

  export type ArtistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ArtistWhereInput | ArtistWhereInput[]
    OR?: ArtistWhereInput[]
    NOT?: ArtistWhereInput | ArtistWhereInput[]
    name?: StringFilter<"Artist"> | string
    bio?: StringNullableFilter<"Artist"> | string | null
    imageId?: StringFilter<"Artist"> | string
    verified?: BoolFilter<"Artist"> | boolean
    monthlyListeners?: IntFilter<"Artist"> | number
    createdAt?: DateTimeFilter<"Artist"> | Date | string
    updatedAt?: DateTimeFilter<"Artist"> | Date | string
    albums?: AlbumListRelationFilter
    songs?: SongArtistListRelationFilter
    genres?: ArtistGenreListRelationFilter
    likedBy?: UserLikedArtistListRelationFilter
    credits?: SongCreditListRelationFilter
  }, "id" | "slug">

  export type ArtistOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    bio?: SortOrderInput | SortOrder
    imageId?: SortOrder
    verified?: SortOrder
    monthlyListeners?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ArtistCountOrderByAggregateInput
    _avg?: ArtistAvgOrderByAggregateInput
    _max?: ArtistMaxOrderByAggregateInput
    _min?: ArtistMinOrderByAggregateInput
    _sum?: ArtistSumOrderByAggregateInput
  }

  export type ArtistScalarWhereWithAggregatesInput = {
    AND?: ArtistScalarWhereWithAggregatesInput | ArtistScalarWhereWithAggregatesInput[]
    OR?: ArtistScalarWhereWithAggregatesInput[]
    NOT?: ArtistScalarWhereWithAggregatesInput | ArtistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Artist"> | string
    name?: StringWithAggregatesFilter<"Artist"> | string
    slug?: StringWithAggregatesFilter<"Artist"> | string
    bio?: StringNullableWithAggregatesFilter<"Artist"> | string | null
    imageId?: StringWithAggregatesFilter<"Artist"> | string
    verified?: BoolWithAggregatesFilter<"Artist"> | boolean
    monthlyListeners?: IntWithAggregatesFilter<"Artist"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Artist"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Artist"> | Date | string
  }

  export type AlbumWhereInput = {
    AND?: AlbumWhereInput | AlbumWhereInput[]
    OR?: AlbumWhereInput[]
    NOT?: AlbumWhereInput | AlbumWhereInput[]
    id?: StringFilter<"Album"> | string
    title?: StringFilter<"Album"> | string
    slug?: StringFilter<"Album"> | string
    description?: StringNullableFilter<"Album"> | string | null
    imageId?: StringFilter<"Album"> | string
    albumType?: EnumAlbumTypeFilter<"Album"> | $Enums.AlbumType
    releaseDate?: DateTimeFilter<"Album"> | Date | string
    totalTracks?: IntFilter<"Album"> | number
    duration?: IntFilter<"Album"> | number
    createdAt?: DateTimeFilter<"Album"> | Date | string
    updatedAt?: DateTimeFilter<"Album"> | Date | string
    artistId?: StringFilter<"Album"> | string
    artist?: XOR<ArtistScalarRelationFilter, ArtistWhereInput>
    songs?: SongListRelationFilter
    genres?: AlbumGenreListRelationFilter
    likedBy?: UserLikedAlbumListRelationFilter
  }

  export type AlbumOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    imageId?: SortOrder
    albumType?: SortOrder
    releaseDate?: SortOrder
    totalTracks?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    artistId?: SortOrder
    artist?: ArtistOrderByWithRelationInput
    songs?: SongOrderByRelationAggregateInput
    genres?: AlbumGenreOrderByRelationAggregateInput
    likedBy?: UserLikedAlbumOrderByRelationAggregateInput
  }

  export type AlbumWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: AlbumWhereInput | AlbumWhereInput[]
    OR?: AlbumWhereInput[]
    NOT?: AlbumWhereInput | AlbumWhereInput[]
    title?: StringFilter<"Album"> | string
    description?: StringNullableFilter<"Album"> | string | null
    imageId?: StringFilter<"Album"> | string
    albumType?: EnumAlbumTypeFilter<"Album"> | $Enums.AlbumType
    releaseDate?: DateTimeFilter<"Album"> | Date | string
    totalTracks?: IntFilter<"Album"> | number
    duration?: IntFilter<"Album"> | number
    createdAt?: DateTimeFilter<"Album"> | Date | string
    updatedAt?: DateTimeFilter<"Album"> | Date | string
    artistId?: StringFilter<"Album"> | string
    artist?: XOR<ArtistScalarRelationFilter, ArtistWhereInput>
    songs?: SongListRelationFilter
    genres?: AlbumGenreListRelationFilter
    likedBy?: UserLikedAlbumListRelationFilter
  }, "id" | "slug">

  export type AlbumOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    imageId?: SortOrder
    albumType?: SortOrder
    releaseDate?: SortOrder
    totalTracks?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    artistId?: SortOrder
    _count?: AlbumCountOrderByAggregateInput
    _avg?: AlbumAvgOrderByAggregateInput
    _max?: AlbumMaxOrderByAggregateInput
    _min?: AlbumMinOrderByAggregateInput
    _sum?: AlbumSumOrderByAggregateInput
  }

  export type AlbumScalarWhereWithAggregatesInput = {
    AND?: AlbumScalarWhereWithAggregatesInput | AlbumScalarWhereWithAggregatesInput[]
    OR?: AlbumScalarWhereWithAggregatesInput[]
    NOT?: AlbumScalarWhereWithAggregatesInput | AlbumScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Album"> | string
    title?: StringWithAggregatesFilter<"Album"> | string
    slug?: StringWithAggregatesFilter<"Album"> | string
    description?: StringNullableWithAggregatesFilter<"Album"> | string | null
    imageId?: StringWithAggregatesFilter<"Album"> | string
    albumType?: EnumAlbumTypeWithAggregatesFilter<"Album"> | $Enums.AlbumType
    releaseDate?: DateTimeWithAggregatesFilter<"Album"> | Date | string
    totalTracks?: IntWithAggregatesFilter<"Album"> | number
    duration?: IntWithAggregatesFilter<"Album"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Album"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Album"> | Date | string
    artistId?: StringWithAggregatesFilter<"Album"> | string
  }

  export type SongWhereInput = {
    AND?: SongWhereInput | SongWhereInput[]
    OR?: SongWhereInput[]
    NOT?: SongWhereInput | SongWhereInput[]
    id?: StringFilter<"Song"> | string
    title?: StringFilter<"Song"> | string
    slug?: StringFilter<"Song"> | string
    audioId?: StringFilter<"Song"> | string
    duration?: IntFilter<"Song"> | number
    trackNumber?: IntFilter<"Song"> | number
    lyrics?: StringNullableFilter<"Song"> | string | null
    isExplicit?: BoolFilter<"Song"> | boolean
    playCount?: IntFilter<"Song"> | number
    createdAt?: DateTimeFilter<"Song"> | Date | string
    updatedAt?: DateTimeFilter<"Song"> | Date | string
    albumId?: StringFilter<"Song"> | string
    album?: XOR<AlbumScalarRelationFilter, AlbumWhereInput>
    artists?: SongArtistListRelationFilter
    credits?: SongCreditListRelationFilter
    genres?: SongGenreListRelationFilter
    likedBy?: UserLikedSongListRelationFilter
    playlistItems?: PlaylistItemListRelationFilter
    playHistory?: PlayHistoryListRelationFilter
  }

  export type SongOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    audioId?: SortOrder
    duration?: SortOrder
    trackNumber?: SortOrder
    lyrics?: SortOrderInput | SortOrder
    isExplicit?: SortOrder
    playCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    albumId?: SortOrder
    album?: AlbumOrderByWithRelationInput
    artists?: SongArtistOrderByRelationAggregateInput
    credits?: SongCreditOrderByRelationAggregateInput
    genres?: SongGenreOrderByRelationAggregateInput
    likedBy?: UserLikedSongOrderByRelationAggregateInput
    playlistItems?: PlaylistItemOrderByRelationAggregateInput
    playHistory?: PlayHistoryOrderByRelationAggregateInput
  }

  export type SongWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: SongWhereInput | SongWhereInput[]
    OR?: SongWhereInput[]
    NOT?: SongWhereInput | SongWhereInput[]
    title?: StringFilter<"Song"> | string
    audioId?: StringFilter<"Song"> | string
    duration?: IntFilter<"Song"> | number
    trackNumber?: IntFilter<"Song"> | number
    lyrics?: StringNullableFilter<"Song"> | string | null
    isExplicit?: BoolFilter<"Song"> | boolean
    playCount?: IntFilter<"Song"> | number
    createdAt?: DateTimeFilter<"Song"> | Date | string
    updatedAt?: DateTimeFilter<"Song"> | Date | string
    albumId?: StringFilter<"Song"> | string
    album?: XOR<AlbumScalarRelationFilter, AlbumWhereInput>
    artists?: SongArtistListRelationFilter
    credits?: SongCreditListRelationFilter
    genres?: SongGenreListRelationFilter
    likedBy?: UserLikedSongListRelationFilter
    playlistItems?: PlaylistItemListRelationFilter
    playHistory?: PlayHistoryListRelationFilter
  }, "id" | "slug">

  export type SongOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    audioId?: SortOrder
    duration?: SortOrder
    trackNumber?: SortOrder
    lyrics?: SortOrderInput | SortOrder
    isExplicit?: SortOrder
    playCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    albumId?: SortOrder
    _count?: SongCountOrderByAggregateInput
    _avg?: SongAvgOrderByAggregateInput
    _max?: SongMaxOrderByAggregateInput
    _min?: SongMinOrderByAggregateInput
    _sum?: SongSumOrderByAggregateInput
  }

  export type SongScalarWhereWithAggregatesInput = {
    AND?: SongScalarWhereWithAggregatesInput | SongScalarWhereWithAggregatesInput[]
    OR?: SongScalarWhereWithAggregatesInput[]
    NOT?: SongScalarWhereWithAggregatesInput | SongScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Song"> | string
    title?: StringWithAggregatesFilter<"Song"> | string
    slug?: StringWithAggregatesFilter<"Song"> | string
    audioId?: StringWithAggregatesFilter<"Song"> | string
    duration?: IntWithAggregatesFilter<"Song"> | number
    trackNumber?: IntWithAggregatesFilter<"Song"> | number
    lyrics?: StringNullableWithAggregatesFilter<"Song"> | string | null
    isExplicit?: BoolWithAggregatesFilter<"Song"> | boolean
    playCount?: IntWithAggregatesFilter<"Song"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Song"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Song"> | Date | string
    albumId?: StringWithAggregatesFilter<"Song"> | string
  }

  export type GenreWhereInput = {
    AND?: GenreWhereInput | GenreWhereInput[]
    OR?: GenreWhereInput[]
    NOT?: GenreWhereInput | GenreWhereInput[]
    id?: StringFilter<"Genre"> | string
    name?: StringFilter<"Genre"> | string
    slug?: StringFilter<"Genre"> | string
    description?: StringNullableFilter<"Genre"> | string | null
    color?: StringNullableFilter<"Genre"> | string | null
    songs?: SongGenreListRelationFilter
    albums?: AlbumGenreListRelationFilter
    artists?: ArtistGenreListRelationFilter
  }

  export type GenreOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    songs?: SongGenreOrderByRelationAggregateInput
    albums?: AlbumGenreOrderByRelationAggregateInput
    artists?: ArtistGenreOrderByRelationAggregateInput
  }

  export type GenreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: GenreWhereInput | GenreWhereInput[]
    OR?: GenreWhereInput[]
    NOT?: GenreWhereInput | GenreWhereInput[]
    description?: StringNullableFilter<"Genre"> | string | null
    color?: StringNullableFilter<"Genre"> | string | null
    songs?: SongGenreListRelationFilter
    albums?: AlbumGenreListRelationFilter
    artists?: ArtistGenreListRelationFilter
  }, "id" | "name" | "slug">

  export type GenreOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    _count?: GenreCountOrderByAggregateInput
    _max?: GenreMaxOrderByAggregateInput
    _min?: GenreMinOrderByAggregateInput
  }

  export type GenreScalarWhereWithAggregatesInput = {
    AND?: GenreScalarWhereWithAggregatesInput | GenreScalarWhereWithAggregatesInput[]
    OR?: GenreScalarWhereWithAggregatesInput[]
    NOT?: GenreScalarWhereWithAggregatesInput | GenreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Genre"> | string
    name?: StringWithAggregatesFilter<"Genre"> | string
    slug?: StringWithAggregatesFilter<"Genre"> | string
    description?: StringNullableWithAggregatesFilter<"Genre"> | string | null
    color?: StringNullableWithAggregatesFilter<"Genre"> | string | null
  }

  export type SongArtistWhereInput = {
    AND?: SongArtistWhereInput | SongArtistWhereInput[]
    OR?: SongArtistWhereInput[]
    NOT?: SongArtistWhereInput | SongArtistWhereInput[]
    id?: StringFilter<"SongArtist"> | string
    songId?: StringFilter<"SongArtist"> | string
    artistId?: StringFilter<"SongArtist"> | string
    role?: EnumArtistRoleFilter<"SongArtist"> | $Enums.ArtistRole
    order?: IntFilter<"SongArtist"> | number
    song?: XOR<SongScalarRelationFilter, SongWhereInput>
    artist?: XOR<ArtistScalarRelationFilter, ArtistWhereInput>
  }

  export type SongArtistOrderByWithRelationInput = {
    id?: SortOrder
    songId?: SortOrder
    artistId?: SortOrder
    role?: SortOrder
    order?: SortOrder
    song?: SongOrderByWithRelationInput
    artist?: ArtistOrderByWithRelationInput
  }

  export type SongArtistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    songId_artistId_role?: SongArtistSongIdArtistIdRoleCompoundUniqueInput
    AND?: SongArtistWhereInput | SongArtistWhereInput[]
    OR?: SongArtistWhereInput[]
    NOT?: SongArtistWhereInput | SongArtistWhereInput[]
    songId?: StringFilter<"SongArtist"> | string
    artistId?: StringFilter<"SongArtist"> | string
    role?: EnumArtistRoleFilter<"SongArtist"> | $Enums.ArtistRole
    order?: IntFilter<"SongArtist"> | number
    song?: XOR<SongScalarRelationFilter, SongWhereInput>
    artist?: XOR<ArtistScalarRelationFilter, ArtistWhereInput>
  }, "id" | "songId_artistId_role">

  export type SongArtistOrderByWithAggregationInput = {
    id?: SortOrder
    songId?: SortOrder
    artistId?: SortOrder
    role?: SortOrder
    order?: SortOrder
    _count?: SongArtistCountOrderByAggregateInput
    _avg?: SongArtistAvgOrderByAggregateInput
    _max?: SongArtistMaxOrderByAggregateInput
    _min?: SongArtistMinOrderByAggregateInput
    _sum?: SongArtistSumOrderByAggregateInput
  }

  export type SongArtistScalarWhereWithAggregatesInput = {
    AND?: SongArtistScalarWhereWithAggregatesInput | SongArtistScalarWhereWithAggregatesInput[]
    OR?: SongArtistScalarWhereWithAggregatesInput[]
    NOT?: SongArtistScalarWhereWithAggregatesInput | SongArtistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SongArtist"> | string
    songId?: StringWithAggregatesFilter<"SongArtist"> | string
    artistId?: StringWithAggregatesFilter<"SongArtist"> | string
    role?: EnumArtistRoleWithAggregatesFilter<"SongArtist"> | $Enums.ArtistRole
    order?: IntWithAggregatesFilter<"SongArtist"> | number
  }

  export type SongCreditWhereInput = {
    AND?: SongCreditWhereInput | SongCreditWhereInput[]
    OR?: SongCreditWhereInput[]
    NOT?: SongCreditWhereInput | SongCreditWhereInput[]
    id?: StringFilter<"SongCredit"> | string
    songId?: StringFilter<"SongCredit"> | string
    artistId?: StringNullableFilter<"SongCredit"> | string | null
    name?: StringFilter<"SongCredit"> | string
    role?: EnumCreditRoleFilter<"SongCredit"> | $Enums.CreditRole
    details?: StringNullableFilter<"SongCredit"> | string | null
    order?: IntFilter<"SongCredit"> | number
    song?: XOR<SongScalarRelationFilter, SongWhereInput>
    artist?: XOR<ArtistNullableScalarRelationFilter, ArtistWhereInput> | null
  }

  export type SongCreditOrderByWithRelationInput = {
    id?: SortOrder
    songId?: SortOrder
    artistId?: SortOrderInput | SortOrder
    name?: SortOrder
    role?: SortOrder
    details?: SortOrderInput | SortOrder
    order?: SortOrder
    song?: SongOrderByWithRelationInput
    artist?: ArtistOrderByWithRelationInput
  }

  export type SongCreditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SongCreditWhereInput | SongCreditWhereInput[]
    OR?: SongCreditWhereInput[]
    NOT?: SongCreditWhereInput | SongCreditWhereInput[]
    songId?: StringFilter<"SongCredit"> | string
    artistId?: StringNullableFilter<"SongCredit"> | string | null
    name?: StringFilter<"SongCredit"> | string
    role?: EnumCreditRoleFilter<"SongCredit"> | $Enums.CreditRole
    details?: StringNullableFilter<"SongCredit"> | string | null
    order?: IntFilter<"SongCredit"> | number
    song?: XOR<SongScalarRelationFilter, SongWhereInput>
    artist?: XOR<ArtistNullableScalarRelationFilter, ArtistWhereInput> | null
  }, "id">

  export type SongCreditOrderByWithAggregationInput = {
    id?: SortOrder
    songId?: SortOrder
    artistId?: SortOrderInput | SortOrder
    name?: SortOrder
    role?: SortOrder
    details?: SortOrderInput | SortOrder
    order?: SortOrder
    _count?: SongCreditCountOrderByAggregateInput
    _avg?: SongCreditAvgOrderByAggregateInput
    _max?: SongCreditMaxOrderByAggregateInput
    _min?: SongCreditMinOrderByAggregateInput
    _sum?: SongCreditSumOrderByAggregateInput
  }

  export type SongCreditScalarWhereWithAggregatesInput = {
    AND?: SongCreditScalarWhereWithAggregatesInput | SongCreditScalarWhereWithAggregatesInput[]
    OR?: SongCreditScalarWhereWithAggregatesInput[]
    NOT?: SongCreditScalarWhereWithAggregatesInput | SongCreditScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SongCredit"> | string
    songId?: StringWithAggregatesFilter<"SongCredit"> | string
    artistId?: StringNullableWithAggregatesFilter<"SongCredit"> | string | null
    name?: StringWithAggregatesFilter<"SongCredit"> | string
    role?: EnumCreditRoleWithAggregatesFilter<"SongCredit"> | $Enums.CreditRole
    details?: StringNullableWithAggregatesFilter<"SongCredit"> | string | null
    order?: IntWithAggregatesFilter<"SongCredit"> | number
  }

  export type SongGenreWhereInput = {
    AND?: SongGenreWhereInput | SongGenreWhereInput[]
    OR?: SongGenreWhereInput[]
    NOT?: SongGenreWhereInput | SongGenreWhereInput[]
    songId?: StringFilter<"SongGenre"> | string
    genreId?: StringFilter<"SongGenre"> | string
    song?: XOR<SongScalarRelationFilter, SongWhereInput>
    genre?: XOR<GenreScalarRelationFilter, GenreWhereInput>
  }

  export type SongGenreOrderByWithRelationInput = {
    songId?: SortOrder
    genreId?: SortOrder
    song?: SongOrderByWithRelationInput
    genre?: GenreOrderByWithRelationInput
  }

  export type SongGenreWhereUniqueInput = Prisma.AtLeast<{
    songId_genreId?: SongGenreSongIdGenreIdCompoundUniqueInput
    AND?: SongGenreWhereInput | SongGenreWhereInput[]
    OR?: SongGenreWhereInput[]
    NOT?: SongGenreWhereInput | SongGenreWhereInput[]
    songId?: StringFilter<"SongGenre"> | string
    genreId?: StringFilter<"SongGenre"> | string
    song?: XOR<SongScalarRelationFilter, SongWhereInput>
    genre?: XOR<GenreScalarRelationFilter, GenreWhereInput>
  }, "songId_genreId">

  export type SongGenreOrderByWithAggregationInput = {
    songId?: SortOrder
    genreId?: SortOrder
    _count?: SongGenreCountOrderByAggregateInput
    _max?: SongGenreMaxOrderByAggregateInput
    _min?: SongGenreMinOrderByAggregateInput
  }

  export type SongGenreScalarWhereWithAggregatesInput = {
    AND?: SongGenreScalarWhereWithAggregatesInput | SongGenreScalarWhereWithAggregatesInput[]
    OR?: SongGenreScalarWhereWithAggregatesInput[]
    NOT?: SongGenreScalarWhereWithAggregatesInput | SongGenreScalarWhereWithAggregatesInput[]
    songId?: StringWithAggregatesFilter<"SongGenre"> | string
    genreId?: StringWithAggregatesFilter<"SongGenre"> | string
  }

  export type AlbumGenreWhereInput = {
    AND?: AlbumGenreWhereInput | AlbumGenreWhereInput[]
    OR?: AlbumGenreWhereInput[]
    NOT?: AlbumGenreWhereInput | AlbumGenreWhereInput[]
    albumId?: StringFilter<"AlbumGenre"> | string
    genreId?: StringFilter<"AlbumGenre"> | string
    album?: XOR<AlbumScalarRelationFilter, AlbumWhereInput>
    genre?: XOR<GenreScalarRelationFilter, GenreWhereInput>
  }

  export type AlbumGenreOrderByWithRelationInput = {
    albumId?: SortOrder
    genreId?: SortOrder
    album?: AlbumOrderByWithRelationInput
    genre?: GenreOrderByWithRelationInput
  }

  export type AlbumGenreWhereUniqueInput = Prisma.AtLeast<{
    albumId_genreId?: AlbumGenreAlbumIdGenreIdCompoundUniqueInput
    AND?: AlbumGenreWhereInput | AlbumGenreWhereInput[]
    OR?: AlbumGenreWhereInput[]
    NOT?: AlbumGenreWhereInput | AlbumGenreWhereInput[]
    albumId?: StringFilter<"AlbumGenre"> | string
    genreId?: StringFilter<"AlbumGenre"> | string
    album?: XOR<AlbumScalarRelationFilter, AlbumWhereInput>
    genre?: XOR<GenreScalarRelationFilter, GenreWhereInput>
  }, "albumId_genreId">

  export type AlbumGenreOrderByWithAggregationInput = {
    albumId?: SortOrder
    genreId?: SortOrder
    _count?: AlbumGenreCountOrderByAggregateInput
    _max?: AlbumGenreMaxOrderByAggregateInput
    _min?: AlbumGenreMinOrderByAggregateInput
  }

  export type AlbumGenreScalarWhereWithAggregatesInput = {
    AND?: AlbumGenreScalarWhereWithAggregatesInput | AlbumGenreScalarWhereWithAggregatesInput[]
    OR?: AlbumGenreScalarWhereWithAggregatesInput[]
    NOT?: AlbumGenreScalarWhereWithAggregatesInput | AlbumGenreScalarWhereWithAggregatesInput[]
    albumId?: StringWithAggregatesFilter<"AlbumGenre"> | string
    genreId?: StringWithAggregatesFilter<"AlbumGenre"> | string
  }

  export type ArtistGenreWhereInput = {
    AND?: ArtistGenreWhereInput | ArtistGenreWhereInput[]
    OR?: ArtistGenreWhereInput[]
    NOT?: ArtistGenreWhereInput | ArtistGenreWhereInput[]
    artistId?: StringFilter<"ArtistGenre"> | string
    genreId?: StringFilter<"ArtistGenre"> | string
    artist?: XOR<ArtistScalarRelationFilter, ArtistWhereInput>
    genre?: XOR<GenreScalarRelationFilter, GenreWhereInput>
  }

  export type ArtistGenreOrderByWithRelationInput = {
    artistId?: SortOrder
    genreId?: SortOrder
    artist?: ArtistOrderByWithRelationInput
    genre?: GenreOrderByWithRelationInput
  }

  export type ArtistGenreWhereUniqueInput = Prisma.AtLeast<{
    artistId_genreId?: ArtistGenreArtistIdGenreIdCompoundUniqueInput
    AND?: ArtistGenreWhereInput | ArtistGenreWhereInput[]
    OR?: ArtistGenreWhereInput[]
    NOT?: ArtistGenreWhereInput | ArtistGenreWhereInput[]
    artistId?: StringFilter<"ArtistGenre"> | string
    genreId?: StringFilter<"ArtistGenre"> | string
    artist?: XOR<ArtistScalarRelationFilter, ArtistWhereInput>
    genre?: XOR<GenreScalarRelationFilter, GenreWhereInput>
  }, "artistId_genreId">

  export type ArtistGenreOrderByWithAggregationInput = {
    artistId?: SortOrder
    genreId?: SortOrder
    _count?: ArtistGenreCountOrderByAggregateInput
    _max?: ArtistGenreMaxOrderByAggregateInput
    _min?: ArtistGenreMinOrderByAggregateInput
  }

  export type ArtistGenreScalarWhereWithAggregatesInput = {
    AND?: ArtistGenreScalarWhereWithAggregatesInput | ArtistGenreScalarWhereWithAggregatesInput[]
    OR?: ArtistGenreScalarWhereWithAggregatesInput[]
    NOT?: ArtistGenreScalarWhereWithAggregatesInput | ArtistGenreScalarWhereWithAggregatesInput[]
    artistId?: StringWithAggregatesFilter<"ArtistGenre"> | string
    genreId?: StringWithAggregatesFilter<"ArtistGenre"> | string
  }

  export type PlaylistWhereInput = {
    AND?: PlaylistWhereInput | PlaylistWhereInput[]
    OR?: PlaylistWhereInput[]
    NOT?: PlaylistWhereInput | PlaylistWhereInput[]
    id?: StringFilter<"Playlist"> | string
    title?: StringFilter<"Playlist"> | string
    description?: StringNullableFilter<"Playlist"> | string | null
    imageId?: StringNullableFilter<"Playlist"> | string | null
    isPublic?: BoolFilter<"Playlist"> | boolean
    isOfficial?: BoolFilter<"Playlist"> | boolean
    totalTracks?: IntFilter<"Playlist"> | number
    duration?: IntFilter<"Playlist"> | number
    createdAt?: DateTimeFilter<"Playlist"> | Date | string
    updatedAt?: DateTimeFilter<"Playlist"> | Date | string
    userId?: StringNullableFilter<"Playlist"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: PlaylistItemListRelationFilter
    likedBy?: UserLikedPlaylistListRelationFilter
  }

  export type PlaylistOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    imageId?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    isOfficial?: SortOrder
    totalTracks?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    items?: PlaylistItemOrderByRelationAggregateInput
    likedBy?: UserLikedPlaylistOrderByRelationAggregateInput
  }

  export type PlaylistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlaylistWhereInput | PlaylistWhereInput[]
    OR?: PlaylistWhereInput[]
    NOT?: PlaylistWhereInput | PlaylistWhereInput[]
    title?: StringFilter<"Playlist"> | string
    description?: StringNullableFilter<"Playlist"> | string | null
    imageId?: StringNullableFilter<"Playlist"> | string | null
    isPublic?: BoolFilter<"Playlist"> | boolean
    isOfficial?: BoolFilter<"Playlist"> | boolean
    totalTracks?: IntFilter<"Playlist"> | number
    duration?: IntFilter<"Playlist"> | number
    createdAt?: DateTimeFilter<"Playlist"> | Date | string
    updatedAt?: DateTimeFilter<"Playlist"> | Date | string
    userId?: StringNullableFilter<"Playlist"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: PlaylistItemListRelationFilter
    likedBy?: UserLikedPlaylistListRelationFilter
  }, "id">

  export type PlaylistOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    imageId?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    isOfficial?: SortOrder
    totalTracks?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: PlaylistCountOrderByAggregateInput
    _avg?: PlaylistAvgOrderByAggregateInput
    _max?: PlaylistMaxOrderByAggregateInput
    _min?: PlaylistMinOrderByAggregateInput
    _sum?: PlaylistSumOrderByAggregateInput
  }

  export type PlaylistScalarWhereWithAggregatesInput = {
    AND?: PlaylistScalarWhereWithAggregatesInput | PlaylistScalarWhereWithAggregatesInput[]
    OR?: PlaylistScalarWhereWithAggregatesInput[]
    NOT?: PlaylistScalarWhereWithAggregatesInput | PlaylistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Playlist"> | string
    title?: StringWithAggregatesFilter<"Playlist"> | string
    description?: StringNullableWithAggregatesFilter<"Playlist"> | string | null
    imageId?: StringNullableWithAggregatesFilter<"Playlist"> | string | null
    isPublic?: BoolWithAggregatesFilter<"Playlist"> | boolean
    isOfficial?: BoolWithAggregatesFilter<"Playlist"> | boolean
    totalTracks?: IntWithAggregatesFilter<"Playlist"> | number
    duration?: IntWithAggregatesFilter<"Playlist"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Playlist"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Playlist"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"Playlist"> | string | null
  }

  export type PlaylistItemWhereInput = {
    AND?: PlaylistItemWhereInput | PlaylistItemWhereInput[]
    OR?: PlaylistItemWhereInput[]
    NOT?: PlaylistItemWhereInput | PlaylistItemWhereInput[]
    id?: StringFilter<"PlaylistItem"> | string
    position?: IntFilter<"PlaylistItem"> | number
    addedAt?: DateTimeFilter<"PlaylistItem"> | Date | string
    playlistId?: StringFilter<"PlaylistItem"> | string
    songId?: StringFilter<"PlaylistItem"> | string
    playlist?: XOR<PlaylistScalarRelationFilter, PlaylistWhereInput>
    song?: XOR<SongScalarRelationFilter, SongWhereInput>
  }

  export type PlaylistItemOrderByWithRelationInput = {
    id?: SortOrder
    position?: SortOrder
    addedAt?: SortOrder
    playlistId?: SortOrder
    songId?: SortOrder
    playlist?: PlaylistOrderByWithRelationInput
    song?: SongOrderByWithRelationInput
  }

  export type PlaylistItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playlistId_songId?: PlaylistItemPlaylistIdSongIdCompoundUniqueInput
    AND?: PlaylistItemWhereInput | PlaylistItemWhereInput[]
    OR?: PlaylistItemWhereInput[]
    NOT?: PlaylistItemWhereInput | PlaylistItemWhereInput[]
    position?: IntFilter<"PlaylistItem"> | number
    addedAt?: DateTimeFilter<"PlaylistItem"> | Date | string
    playlistId?: StringFilter<"PlaylistItem"> | string
    songId?: StringFilter<"PlaylistItem"> | string
    playlist?: XOR<PlaylistScalarRelationFilter, PlaylistWhereInput>
    song?: XOR<SongScalarRelationFilter, SongWhereInput>
  }, "id" | "playlistId_songId">

  export type PlaylistItemOrderByWithAggregationInput = {
    id?: SortOrder
    position?: SortOrder
    addedAt?: SortOrder
    playlistId?: SortOrder
    songId?: SortOrder
    _count?: PlaylistItemCountOrderByAggregateInput
    _avg?: PlaylistItemAvgOrderByAggregateInput
    _max?: PlaylistItemMaxOrderByAggregateInput
    _min?: PlaylistItemMinOrderByAggregateInput
    _sum?: PlaylistItemSumOrderByAggregateInput
  }

  export type PlaylistItemScalarWhereWithAggregatesInput = {
    AND?: PlaylistItemScalarWhereWithAggregatesInput | PlaylistItemScalarWhereWithAggregatesInput[]
    OR?: PlaylistItemScalarWhereWithAggregatesInput[]
    NOT?: PlaylistItemScalarWhereWithAggregatesInput | PlaylistItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlaylistItem"> | string
    position?: IntWithAggregatesFilter<"PlaylistItem"> | number
    addedAt?: DateTimeWithAggregatesFilter<"PlaylistItem"> | Date | string
    playlistId?: StringWithAggregatesFilter<"PlaylistItem"> | string
    songId?: StringWithAggregatesFilter<"PlaylistItem"> | string
  }

  export type UserLikedSongWhereInput = {
    AND?: UserLikedSongWhereInput | UserLikedSongWhereInput[]
    OR?: UserLikedSongWhereInput[]
    NOT?: UserLikedSongWhereInput | UserLikedSongWhereInput[]
    userId?: StringFilter<"UserLikedSong"> | string
    songId?: StringFilter<"UserLikedSong"> | string
    likedAt?: DateTimeFilter<"UserLikedSong"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    song?: XOR<SongScalarRelationFilter, SongWhereInput>
  }

  export type UserLikedSongOrderByWithRelationInput = {
    userId?: SortOrder
    songId?: SortOrder
    likedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    song?: SongOrderByWithRelationInput
  }

  export type UserLikedSongWhereUniqueInput = Prisma.AtLeast<{
    userId_songId?: UserLikedSongUserIdSongIdCompoundUniqueInput
    AND?: UserLikedSongWhereInput | UserLikedSongWhereInput[]
    OR?: UserLikedSongWhereInput[]
    NOT?: UserLikedSongWhereInput | UserLikedSongWhereInput[]
    userId?: StringFilter<"UserLikedSong"> | string
    songId?: StringFilter<"UserLikedSong"> | string
    likedAt?: DateTimeFilter<"UserLikedSong"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    song?: XOR<SongScalarRelationFilter, SongWhereInput>
  }, "userId_songId">

  export type UserLikedSongOrderByWithAggregationInput = {
    userId?: SortOrder
    songId?: SortOrder
    likedAt?: SortOrder
    _count?: UserLikedSongCountOrderByAggregateInput
    _max?: UserLikedSongMaxOrderByAggregateInput
    _min?: UserLikedSongMinOrderByAggregateInput
  }

  export type UserLikedSongScalarWhereWithAggregatesInput = {
    AND?: UserLikedSongScalarWhereWithAggregatesInput | UserLikedSongScalarWhereWithAggregatesInput[]
    OR?: UserLikedSongScalarWhereWithAggregatesInput[]
    NOT?: UserLikedSongScalarWhereWithAggregatesInput | UserLikedSongScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserLikedSong"> | string
    songId?: StringWithAggregatesFilter<"UserLikedSong"> | string
    likedAt?: DateTimeWithAggregatesFilter<"UserLikedSong"> | Date | string
  }

  export type UserLikedAlbumWhereInput = {
    AND?: UserLikedAlbumWhereInput | UserLikedAlbumWhereInput[]
    OR?: UserLikedAlbumWhereInput[]
    NOT?: UserLikedAlbumWhereInput | UserLikedAlbumWhereInput[]
    userId?: StringFilter<"UserLikedAlbum"> | string
    albumId?: StringFilter<"UserLikedAlbum"> | string
    likedAt?: DateTimeFilter<"UserLikedAlbum"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    album?: XOR<AlbumScalarRelationFilter, AlbumWhereInput>
  }

  export type UserLikedAlbumOrderByWithRelationInput = {
    userId?: SortOrder
    albumId?: SortOrder
    likedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    album?: AlbumOrderByWithRelationInput
  }

  export type UserLikedAlbumWhereUniqueInput = Prisma.AtLeast<{
    userId_albumId?: UserLikedAlbumUserIdAlbumIdCompoundUniqueInput
    AND?: UserLikedAlbumWhereInput | UserLikedAlbumWhereInput[]
    OR?: UserLikedAlbumWhereInput[]
    NOT?: UserLikedAlbumWhereInput | UserLikedAlbumWhereInput[]
    userId?: StringFilter<"UserLikedAlbum"> | string
    albumId?: StringFilter<"UserLikedAlbum"> | string
    likedAt?: DateTimeFilter<"UserLikedAlbum"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    album?: XOR<AlbumScalarRelationFilter, AlbumWhereInput>
  }, "userId_albumId">

  export type UserLikedAlbumOrderByWithAggregationInput = {
    userId?: SortOrder
    albumId?: SortOrder
    likedAt?: SortOrder
    _count?: UserLikedAlbumCountOrderByAggregateInput
    _max?: UserLikedAlbumMaxOrderByAggregateInput
    _min?: UserLikedAlbumMinOrderByAggregateInput
  }

  export type UserLikedAlbumScalarWhereWithAggregatesInput = {
    AND?: UserLikedAlbumScalarWhereWithAggregatesInput | UserLikedAlbumScalarWhereWithAggregatesInput[]
    OR?: UserLikedAlbumScalarWhereWithAggregatesInput[]
    NOT?: UserLikedAlbumScalarWhereWithAggregatesInput | UserLikedAlbumScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserLikedAlbum"> | string
    albumId?: StringWithAggregatesFilter<"UserLikedAlbum"> | string
    likedAt?: DateTimeWithAggregatesFilter<"UserLikedAlbum"> | Date | string
  }

  export type UserLikedArtistWhereInput = {
    AND?: UserLikedArtistWhereInput | UserLikedArtistWhereInput[]
    OR?: UserLikedArtistWhereInput[]
    NOT?: UserLikedArtistWhereInput | UserLikedArtistWhereInput[]
    userId?: StringFilter<"UserLikedArtist"> | string
    artistId?: StringFilter<"UserLikedArtist"> | string
    likedAt?: DateTimeFilter<"UserLikedArtist"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    artist?: XOR<ArtistScalarRelationFilter, ArtistWhereInput>
  }

  export type UserLikedArtistOrderByWithRelationInput = {
    userId?: SortOrder
    artistId?: SortOrder
    likedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    artist?: ArtistOrderByWithRelationInput
  }

  export type UserLikedArtistWhereUniqueInput = Prisma.AtLeast<{
    userId_artistId?: UserLikedArtistUserIdArtistIdCompoundUniqueInput
    AND?: UserLikedArtistWhereInput | UserLikedArtistWhereInput[]
    OR?: UserLikedArtistWhereInput[]
    NOT?: UserLikedArtistWhereInput | UserLikedArtistWhereInput[]
    userId?: StringFilter<"UserLikedArtist"> | string
    artistId?: StringFilter<"UserLikedArtist"> | string
    likedAt?: DateTimeFilter<"UserLikedArtist"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    artist?: XOR<ArtistScalarRelationFilter, ArtistWhereInput>
  }, "userId_artistId">

  export type UserLikedArtistOrderByWithAggregationInput = {
    userId?: SortOrder
    artistId?: SortOrder
    likedAt?: SortOrder
    _count?: UserLikedArtistCountOrderByAggregateInput
    _max?: UserLikedArtistMaxOrderByAggregateInput
    _min?: UserLikedArtistMinOrderByAggregateInput
  }

  export type UserLikedArtistScalarWhereWithAggregatesInput = {
    AND?: UserLikedArtistScalarWhereWithAggregatesInput | UserLikedArtistScalarWhereWithAggregatesInput[]
    OR?: UserLikedArtistScalarWhereWithAggregatesInput[]
    NOT?: UserLikedArtistScalarWhereWithAggregatesInput | UserLikedArtistScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserLikedArtist"> | string
    artistId?: StringWithAggregatesFilter<"UserLikedArtist"> | string
    likedAt?: DateTimeWithAggregatesFilter<"UserLikedArtist"> | Date | string
  }

  export type UserLikedPlaylistWhereInput = {
    AND?: UserLikedPlaylistWhereInput | UserLikedPlaylistWhereInput[]
    OR?: UserLikedPlaylistWhereInput[]
    NOT?: UserLikedPlaylistWhereInput | UserLikedPlaylistWhereInput[]
    userId?: StringFilter<"UserLikedPlaylist"> | string
    playlistId?: StringFilter<"UserLikedPlaylist"> | string
    likedAt?: DateTimeFilter<"UserLikedPlaylist"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    playlist?: XOR<PlaylistScalarRelationFilter, PlaylistWhereInput>
  }

  export type UserLikedPlaylistOrderByWithRelationInput = {
    userId?: SortOrder
    playlistId?: SortOrder
    likedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    playlist?: PlaylistOrderByWithRelationInput
  }

  export type UserLikedPlaylistWhereUniqueInput = Prisma.AtLeast<{
    userId_playlistId?: UserLikedPlaylistUserIdPlaylistIdCompoundUniqueInput
    AND?: UserLikedPlaylistWhereInput | UserLikedPlaylistWhereInput[]
    OR?: UserLikedPlaylistWhereInput[]
    NOT?: UserLikedPlaylistWhereInput | UserLikedPlaylistWhereInput[]
    userId?: StringFilter<"UserLikedPlaylist"> | string
    playlistId?: StringFilter<"UserLikedPlaylist"> | string
    likedAt?: DateTimeFilter<"UserLikedPlaylist"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    playlist?: XOR<PlaylistScalarRelationFilter, PlaylistWhereInput>
  }, "userId_playlistId">

  export type UserLikedPlaylistOrderByWithAggregationInput = {
    userId?: SortOrder
    playlistId?: SortOrder
    likedAt?: SortOrder
    _count?: UserLikedPlaylistCountOrderByAggregateInput
    _max?: UserLikedPlaylistMaxOrderByAggregateInput
    _min?: UserLikedPlaylistMinOrderByAggregateInput
  }

  export type UserLikedPlaylistScalarWhereWithAggregatesInput = {
    AND?: UserLikedPlaylistScalarWhereWithAggregatesInput | UserLikedPlaylistScalarWhereWithAggregatesInput[]
    OR?: UserLikedPlaylistScalarWhereWithAggregatesInput[]
    NOT?: UserLikedPlaylistScalarWhereWithAggregatesInput | UserLikedPlaylistScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserLikedPlaylist"> | string
    playlistId?: StringWithAggregatesFilter<"UserLikedPlaylist"> | string
    likedAt?: DateTimeWithAggregatesFilter<"UserLikedPlaylist"> | Date | string
  }

  export type UserFollowWhereInput = {
    AND?: UserFollowWhereInput | UserFollowWhereInput[]
    OR?: UserFollowWhereInput[]
    NOT?: UserFollowWhereInput | UserFollowWhereInput[]
    followerId?: StringFilter<"UserFollow"> | string
    followingId?: StringFilter<"UserFollow"> | string
    followedAt?: DateTimeFilter<"UserFollow"> | Date | string
    follower?: XOR<UserScalarRelationFilter, UserWhereInput>
    following?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserFollowOrderByWithRelationInput = {
    followerId?: SortOrder
    followingId?: SortOrder
    followedAt?: SortOrder
    follower?: UserOrderByWithRelationInput
    following?: UserOrderByWithRelationInput
  }

  export type UserFollowWhereUniqueInput = Prisma.AtLeast<{
    followerId_followingId?: UserFollowFollowerIdFollowingIdCompoundUniqueInput
    AND?: UserFollowWhereInput | UserFollowWhereInput[]
    OR?: UserFollowWhereInput[]
    NOT?: UserFollowWhereInput | UserFollowWhereInput[]
    followerId?: StringFilter<"UserFollow"> | string
    followingId?: StringFilter<"UserFollow"> | string
    followedAt?: DateTimeFilter<"UserFollow"> | Date | string
    follower?: XOR<UserScalarRelationFilter, UserWhereInput>
    following?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "followerId_followingId">

  export type UserFollowOrderByWithAggregationInput = {
    followerId?: SortOrder
    followingId?: SortOrder
    followedAt?: SortOrder
    _count?: UserFollowCountOrderByAggregateInput
    _max?: UserFollowMaxOrderByAggregateInput
    _min?: UserFollowMinOrderByAggregateInput
  }

  export type UserFollowScalarWhereWithAggregatesInput = {
    AND?: UserFollowScalarWhereWithAggregatesInput | UserFollowScalarWhereWithAggregatesInput[]
    OR?: UserFollowScalarWhereWithAggregatesInput[]
    NOT?: UserFollowScalarWhereWithAggregatesInput | UserFollowScalarWhereWithAggregatesInput[]
    followerId?: StringWithAggregatesFilter<"UserFollow"> | string
    followingId?: StringWithAggregatesFilter<"UserFollow"> | string
    followedAt?: DateTimeWithAggregatesFilter<"UserFollow"> | Date | string
  }

  export type PlayHistoryWhereInput = {
    AND?: PlayHistoryWhereInput | PlayHistoryWhereInput[]
    OR?: PlayHistoryWhereInput[]
    NOT?: PlayHistoryWhereInput | PlayHistoryWhereInput[]
    id?: StringFilter<"PlayHistory"> | string
    playedAt?: DateTimeFilter<"PlayHistory"> | Date | string
    duration?: IntFilter<"PlayHistory"> | number
    deviceType?: StringNullableFilter<"PlayHistory"> | string | null
    userId?: StringFilter<"PlayHistory"> | string
    songId?: StringFilter<"PlayHistory"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    song?: XOR<SongScalarRelationFilter, SongWhereInput>
  }

  export type PlayHistoryOrderByWithRelationInput = {
    id?: SortOrder
    playedAt?: SortOrder
    duration?: SortOrder
    deviceType?: SortOrderInput | SortOrder
    userId?: SortOrder
    songId?: SortOrder
    user?: UserOrderByWithRelationInput
    song?: SongOrderByWithRelationInput
  }

  export type PlayHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlayHistoryWhereInput | PlayHistoryWhereInput[]
    OR?: PlayHistoryWhereInput[]
    NOT?: PlayHistoryWhereInput | PlayHistoryWhereInput[]
    playedAt?: DateTimeFilter<"PlayHistory"> | Date | string
    duration?: IntFilter<"PlayHistory"> | number
    deviceType?: StringNullableFilter<"PlayHistory"> | string | null
    userId?: StringFilter<"PlayHistory"> | string
    songId?: StringFilter<"PlayHistory"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    song?: XOR<SongScalarRelationFilter, SongWhereInput>
  }, "id">

  export type PlayHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    playedAt?: SortOrder
    duration?: SortOrder
    deviceType?: SortOrderInput | SortOrder
    userId?: SortOrder
    songId?: SortOrder
    _count?: PlayHistoryCountOrderByAggregateInput
    _avg?: PlayHistoryAvgOrderByAggregateInput
    _max?: PlayHistoryMaxOrderByAggregateInput
    _min?: PlayHistoryMinOrderByAggregateInput
    _sum?: PlayHistorySumOrderByAggregateInput
  }

  export type PlayHistoryScalarWhereWithAggregatesInput = {
    AND?: PlayHistoryScalarWhereWithAggregatesInput | PlayHistoryScalarWhereWithAggregatesInput[]
    OR?: PlayHistoryScalarWhereWithAggregatesInput[]
    NOT?: PlayHistoryScalarWhereWithAggregatesInput | PlayHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayHistory"> | string
    playedAt?: DateTimeWithAggregatesFilter<"PlayHistory"> | Date | string
    duration?: IntWithAggregatesFilter<"PlayHistory"> | number
    deviceType?: StringNullableWithAggregatesFilter<"PlayHistory"> | string | null
    userId?: StringWithAggregatesFilter<"PlayHistory"> | string
    songId?: StringWithAggregatesFilter<"PlayHistory"> | string
  }

  export type SearchHistoryWhereInput = {
    AND?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    OR?: SearchHistoryWhereInput[]
    NOT?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    id?: StringFilter<"SearchHistory"> | string
    query?: StringFilter<"SearchHistory"> | string
    resultType?: StringNullableFilter<"SearchHistory"> | string | null
    resultId?: StringNullableFilter<"SearchHistory"> | string | null
    searchedAt?: DateTimeFilter<"SearchHistory"> | Date | string
    userId?: StringFilter<"SearchHistory"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SearchHistoryOrderByWithRelationInput = {
    id?: SortOrder
    query?: SortOrder
    resultType?: SortOrderInput | SortOrder
    resultId?: SortOrderInput | SortOrder
    searchedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SearchHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    OR?: SearchHistoryWhereInput[]
    NOT?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    query?: StringFilter<"SearchHistory"> | string
    resultType?: StringNullableFilter<"SearchHistory"> | string | null
    resultId?: StringNullableFilter<"SearchHistory"> | string | null
    searchedAt?: DateTimeFilter<"SearchHistory"> | Date | string
    userId?: StringFilter<"SearchHistory"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SearchHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    query?: SortOrder
    resultType?: SortOrderInput | SortOrder
    resultId?: SortOrderInput | SortOrder
    searchedAt?: SortOrder
    userId?: SortOrder
    _count?: SearchHistoryCountOrderByAggregateInput
    _max?: SearchHistoryMaxOrderByAggregateInput
    _min?: SearchHistoryMinOrderByAggregateInput
  }

  export type SearchHistoryScalarWhereWithAggregatesInput = {
    AND?: SearchHistoryScalarWhereWithAggregatesInput | SearchHistoryScalarWhereWithAggregatesInput[]
    OR?: SearchHistoryScalarWhereWithAggregatesInput[]
    NOT?: SearchHistoryScalarWhereWithAggregatesInput | SearchHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SearchHistory"> | string
    query?: StringWithAggregatesFilter<"SearchHistory"> | string
    resultType?: StringNullableWithAggregatesFilter<"SearchHistory"> | string | null
    resultId?: StringNullableWithAggregatesFilter<"SearchHistory"> | string | null
    searchedAt?: DateTimeWithAggregatesFilter<"SearchHistory"> | Date | string
    userId?: StringWithAggregatesFilter<"SearchHistory"> | string
  }

  export type UserRecommendationWhereInput = {
    AND?: UserRecommendationWhereInput | UserRecommendationWhereInput[]
    OR?: UserRecommendationWhereInput[]
    NOT?: UserRecommendationWhereInput | UserRecommendationWhereInput[]
    id?: StringFilter<"UserRecommendation"> | string
    type?: StringFilter<"UserRecommendation"> | string
    targetId?: StringFilter<"UserRecommendation"> | string
    score?: FloatFilter<"UserRecommendation"> | number
    reason?: StringNullableFilter<"UserRecommendation"> | string | null
    createdAt?: DateTimeFilter<"UserRecommendation"> | Date | string
    userId?: StringFilter<"UserRecommendation"> | string
  }

  export type UserRecommendationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    targetId?: SortOrder
    score?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type UserRecommendationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserRecommendationWhereInput | UserRecommendationWhereInput[]
    OR?: UserRecommendationWhereInput[]
    NOT?: UserRecommendationWhereInput | UserRecommendationWhereInput[]
    type?: StringFilter<"UserRecommendation"> | string
    targetId?: StringFilter<"UserRecommendation"> | string
    score?: FloatFilter<"UserRecommendation"> | number
    reason?: StringNullableFilter<"UserRecommendation"> | string | null
    createdAt?: DateTimeFilter<"UserRecommendation"> | Date | string
    userId?: StringFilter<"UserRecommendation"> | string
  }, "id">

  export type UserRecommendationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    targetId?: SortOrder
    score?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    _count?: UserRecommendationCountOrderByAggregateInput
    _avg?: UserRecommendationAvgOrderByAggregateInput
    _max?: UserRecommendationMaxOrderByAggregateInput
    _min?: UserRecommendationMinOrderByAggregateInput
    _sum?: UserRecommendationSumOrderByAggregateInput
  }

  export type UserRecommendationScalarWhereWithAggregatesInput = {
    AND?: UserRecommendationScalarWhereWithAggregatesInput | UserRecommendationScalarWhereWithAggregatesInput[]
    OR?: UserRecommendationScalarWhereWithAggregatesInput[]
    NOT?: UserRecommendationScalarWhereWithAggregatesInput | UserRecommendationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserRecommendation"> | string
    type?: StringWithAggregatesFilter<"UserRecommendation"> | string
    targetId?: StringWithAggregatesFilter<"UserRecommendation"> | string
    score?: FloatWithAggregatesFilter<"UserRecommendation"> | number
    reason?: StringNullableWithAggregatesFilter<"UserRecommendation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserRecommendation"> | Date | string
    userId?: StringWithAggregatesFilter<"UserRecommendation"> | string
  }

  export type UserQueueWhereInput = {
    AND?: UserQueueWhereInput | UserQueueWhereInput[]
    OR?: UserQueueWhereInput[]
    NOT?: UserQueueWhereInput | UserQueueWhereInput[]
    id?: StringFilter<"UserQueue"> | string
    position?: IntFilter<"UserQueue"> | number
    createdAt?: DateTimeFilter<"UserQueue"> | Date | string
    userId?: StringFilter<"UserQueue"> | string
    songId?: StringFilter<"UserQueue"> | string
  }

  export type UserQueueOrderByWithRelationInput = {
    id?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    songId?: SortOrder
  }

  export type UserQueueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_position?: UserQueueUserIdPositionCompoundUniqueInput
    AND?: UserQueueWhereInput | UserQueueWhereInput[]
    OR?: UserQueueWhereInput[]
    NOT?: UserQueueWhereInput | UserQueueWhereInput[]
    position?: IntFilter<"UserQueue"> | number
    createdAt?: DateTimeFilter<"UserQueue"> | Date | string
    userId?: StringFilter<"UserQueue"> | string
    songId?: StringFilter<"UserQueue"> | string
  }, "id" | "userId_position">

  export type UserQueueOrderByWithAggregationInput = {
    id?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    songId?: SortOrder
    _count?: UserQueueCountOrderByAggregateInput
    _avg?: UserQueueAvgOrderByAggregateInput
    _max?: UserQueueMaxOrderByAggregateInput
    _min?: UserQueueMinOrderByAggregateInput
    _sum?: UserQueueSumOrderByAggregateInput
  }

  export type UserQueueScalarWhereWithAggregatesInput = {
    AND?: UserQueueScalarWhereWithAggregatesInput | UserQueueScalarWhereWithAggregatesInput[]
    OR?: UserQueueScalarWhereWithAggregatesInput[]
    NOT?: UserQueueScalarWhereWithAggregatesInput | UserQueueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserQueue"> | string
    position?: IntWithAggregatesFilter<"UserQueue"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserQueue"> | Date | string
    userId?: StringWithAggregatesFilter<"UserQueue"> | string
    songId?: StringWithAggregatesFilter<"UserQueue"> | string
  }

  export type ChartWhereInput = {
    AND?: ChartWhereInput | ChartWhereInput[]
    OR?: ChartWhereInput[]
    NOT?: ChartWhereInput | ChartWhereInput[]
    id?: StringFilter<"Chart"> | string
    name?: StringFilter<"Chart"> | string
    type?: EnumChartTypeFilter<"Chart"> | $Enums.ChartType
    period?: StringFilter<"Chart"> | string
    startDate?: DateTimeFilter<"Chart"> | Date | string
    endDate?: DateTimeFilter<"Chart"> | Date | string
    createdAt?: DateTimeFilter<"Chart"> | Date | string
    items?: ChartItemListRelationFilter
  }

  export type ChartOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    items?: ChartItemOrderByRelationAggregateInput
  }

  export type ChartWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChartWhereInput | ChartWhereInput[]
    OR?: ChartWhereInput[]
    NOT?: ChartWhereInput | ChartWhereInput[]
    name?: StringFilter<"Chart"> | string
    type?: EnumChartTypeFilter<"Chart"> | $Enums.ChartType
    period?: StringFilter<"Chart"> | string
    startDate?: DateTimeFilter<"Chart"> | Date | string
    endDate?: DateTimeFilter<"Chart"> | Date | string
    createdAt?: DateTimeFilter<"Chart"> | Date | string
    items?: ChartItemListRelationFilter
  }, "id">

  export type ChartOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    _count?: ChartCountOrderByAggregateInput
    _max?: ChartMaxOrderByAggregateInput
    _min?: ChartMinOrderByAggregateInput
  }

  export type ChartScalarWhereWithAggregatesInput = {
    AND?: ChartScalarWhereWithAggregatesInput | ChartScalarWhereWithAggregatesInput[]
    OR?: ChartScalarWhereWithAggregatesInput[]
    NOT?: ChartScalarWhereWithAggregatesInput | ChartScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chart"> | string
    name?: StringWithAggregatesFilter<"Chart"> | string
    type?: EnumChartTypeWithAggregatesFilter<"Chart"> | $Enums.ChartType
    period?: StringWithAggregatesFilter<"Chart"> | string
    startDate?: DateTimeWithAggregatesFilter<"Chart"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Chart"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Chart"> | Date | string
  }

  export type ChartItemWhereInput = {
    AND?: ChartItemWhereInput | ChartItemWhereInput[]
    OR?: ChartItemWhereInput[]
    NOT?: ChartItemWhereInput | ChartItemWhereInput[]
    chartId?: StringFilter<"ChartItem"> | string
    position?: IntFilter<"ChartItem"> | number
    itemType?: StringFilter<"ChartItem"> | string
    itemId?: StringFilter<"ChartItem"> | string
    plays?: IntFilter<"ChartItem"> | number
    chart?: XOR<ChartScalarRelationFilter, ChartWhereInput>
  }

  export type ChartItemOrderByWithRelationInput = {
    chartId?: SortOrder
    position?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    plays?: SortOrder
    chart?: ChartOrderByWithRelationInput
  }

  export type ChartItemWhereUniqueInput = Prisma.AtLeast<{
    chartId_position?: ChartItemChartIdPositionCompoundUniqueInput
    AND?: ChartItemWhereInput | ChartItemWhereInput[]
    OR?: ChartItemWhereInput[]
    NOT?: ChartItemWhereInput | ChartItemWhereInput[]
    chartId?: StringFilter<"ChartItem"> | string
    position?: IntFilter<"ChartItem"> | number
    itemType?: StringFilter<"ChartItem"> | string
    itemId?: StringFilter<"ChartItem"> | string
    plays?: IntFilter<"ChartItem"> | number
    chart?: XOR<ChartScalarRelationFilter, ChartWhereInput>
  }, "chartId_position">

  export type ChartItemOrderByWithAggregationInput = {
    chartId?: SortOrder
    position?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    plays?: SortOrder
    _count?: ChartItemCountOrderByAggregateInput
    _avg?: ChartItemAvgOrderByAggregateInput
    _max?: ChartItemMaxOrderByAggregateInput
    _min?: ChartItemMinOrderByAggregateInput
    _sum?: ChartItemSumOrderByAggregateInput
  }

  export type ChartItemScalarWhereWithAggregatesInput = {
    AND?: ChartItemScalarWhereWithAggregatesInput | ChartItemScalarWhereWithAggregatesInput[]
    OR?: ChartItemScalarWhereWithAggregatesInput[]
    NOT?: ChartItemScalarWhereWithAggregatesInput | ChartItemScalarWhereWithAggregatesInput[]
    chartId?: StringWithAggregatesFilter<"ChartItem"> | string
    position?: IntWithAggregatesFilter<"ChartItem"> | number
    itemType?: StringWithAggregatesFilter<"ChartItem"> | string
    itemId?: StringWithAggregatesFilter<"ChartItem"> | string
    plays?: IntWithAggregatesFilter<"ChartItem"> | number
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username?: string | null
    name?: string | null
    password?: string | null
    imageId?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bio?: string | null
    country?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    likedSongs?: UserLikedSongCreateNestedManyWithoutUserInput
    likedAlbums?: UserLikedAlbumCreateNestedManyWithoutUserInput
    likedPlaylists?: UserLikedPlaylistCreateNestedManyWithoutUserInput
    likedArtists?: UserLikedArtistCreateNestedManyWithoutUserInput
    playHistory?: PlayHistoryCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowerInput
    following?: UserFollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    username?: string | null
    name?: string | null
    password?: string | null
    imageId?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bio?: string | null
    country?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    likedSongs?: UserLikedSongUncheckedCreateNestedManyWithoutUserInput
    likedAlbums?: UserLikedAlbumUncheckedCreateNestedManyWithoutUserInput
    likedPlaylists?: UserLikedPlaylistUncheckedCreateNestedManyWithoutUserInput
    likedArtists?: UserLikedArtistUncheckedCreateNestedManyWithoutUserInput
    playHistory?: PlayHistoryUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    likedSongs?: UserLikedSongUpdateManyWithoutUserNestedInput
    likedAlbums?: UserLikedAlbumUpdateManyWithoutUserNestedInput
    likedPlaylists?: UserLikedPlaylistUpdateManyWithoutUserNestedInput
    likedArtists?: UserLikedArtistUpdateManyWithoutUserNestedInput
    playHistory?: PlayHistoryUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowerNestedInput
    following?: UserFollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    likedSongs?: UserLikedSongUncheckedUpdateManyWithoutUserNestedInput
    likedAlbums?: UserLikedAlbumUncheckedUpdateManyWithoutUserNestedInput
    likedPlaylists?: UserLikedPlaylistUncheckedUpdateManyWithoutUserNestedInput
    likedArtists?: UserLikedArtistUncheckedUpdateManyWithoutUserNestedInput
    playHistory?: PlayHistoryUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    username?: string | null
    name?: string | null
    password?: string | null
    imageId?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bio?: string | null
    country?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionCreateInput = {
    id?: string
    type?: $Enums.SubscriptionType
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    endDate?: Date | string | null
    autoRenew?: boolean
    paymentMethod?: string | null
    user: UserCreateNestedOneWithoutSubscriptionInput
  }

  export type UserSubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    type?: $Enums.SubscriptionType
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    endDate?: Date | string | null
    autoRenew?: boolean
    paymentMethod?: string | null
  }

  export type UserSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type UserSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSubscriptionCreateManyInput = {
    id?: string
    userId: string
    type?: $Enums.SubscriptionType
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    endDate?: Date | string | null
    autoRenew?: boolean
    paymentMethod?: string | null
  }

  export type UserSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArtistCreateInput = {
    id?: string
    name: string
    slug: string
    bio?: string | null
    imageId: string
    verified?: boolean
    monthlyListeners?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    albums?: AlbumCreateNestedManyWithoutArtistInput
    songs?: SongArtistCreateNestedManyWithoutArtistInput
    genres?: ArtistGenreCreateNestedManyWithoutArtistInput
    likedBy?: UserLikedArtistCreateNestedManyWithoutArtistInput
    credits?: SongCreditCreateNestedManyWithoutArtistInput
  }

  export type ArtistUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    bio?: string | null
    imageId: string
    verified?: boolean
    monthlyListeners?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    albums?: AlbumUncheckedCreateNestedManyWithoutArtistInput
    songs?: SongArtistUncheckedCreateNestedManyWithoutArtistInput
    genres?: ArtistGenreUncheckedCreateNestedManyWithoutArtistInput
    likedBy?: UserLikedArtistUncheckedCreateNestedManyWithoutArtistInput
    credits?: SongCreditUncheckedCreateNestedManyWithoutArtistInput
  }

  export type ArtistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albums?: AlbumUpdateManyWithoutArtistNestedInput
    songs?: SongArtistUpdateManyWithoutArtistNestedInput
    genres?: ArtistGenreUpdateManyWithoutArtistNestedInput
    likedBy?: UserLikedArtistUpdateManyWithoutArtistNestedInput
    credits?: SongCreditUpdateManyWithoutArtistNestedInput
  }

  export type ArtistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albums?: AlbumUncheckedUpdateManyWithoutArtistNestedInput
    songs?: SongArtistUncheckedUpdateManyWithoutArtistNestedInput
    genres?: ArtistGenreUncheckedUpdateManyWithoutArtistNestedInput
    likedBy?: UserLikedArtistUncheckedUpdateManyWithoutArtistNestedInput
    credits?: SongCreditUncheckedUpdateManyWithoutArtistNestedInput
  }

  export type ArtistCreateManyInput = {
    id?: string
    name: string
    slug: string
    bio?: string | null
    imageId: string
    verified?: boolean
    monthlyListeners?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArtistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlbumCreateInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    imageId: string
    albumType?: $Enums.AlbumType
    releaseDate?: Date | string
    totalTracks?: number
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    artist: ArtistCreateNestedOneWithoutAlbumsInput
    songs?: SongCreateNestedManyWithoutAlbumInput
    genres?: AlbumGenreCreateNestedManyWithoutAlbumInput
    likedBy?: UserLikedAlbumCreateNestedManyWithoutAlbumInput
  }

  export type AlbumUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    imageId: string
    albumType?: $Enums.AlbumType
    releaseDate?: Date | string
    totalTracks?: number
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    artistId: string
    songs?: SongUncheckedCreateNestedManyWithoutAlbumInput
    genres?: AlbumGenreUncheckedCreateNestedManyWithoutAlbumInput
    likedBy?: UserLikedAlbumUncheckedCreateNestedManyWithoutAlbumInput
  }

  export type AlbumUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: StringFieldUpdateOperationsInput | string
    albumType?: EnumAlbumTypeFieldUpdateOperationsInput | $Enums.AlbumType
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalTracks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUpdateOneRequiredWithoutAlbumsNestedInput
    songs?: SongUpdateManyWithoutAlbumNestedInput
    genres?: AlbumGenreUpdateManyWithoutAlbumNestedInput
    likedBy?: UserLikedAlbumUpdateManyWithoutAlbumNestedInput
  }

  export type AlbumUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: StringFieldUpdateOperationsInput | string
    albumType?: EnumAlbumTypeFieldUpdateOperationsInput | $Enums.AlbumType
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalTracks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artistId?: StringFieldUpdateOperationsInput | string
    songs?: SongUncheckedUpdateManyWithoutAlbumNestedInput
    genres?: AlbumGenreUncheckedUpdateManyWithoutAlbumNestedInput
    likedBy?: UserLikedAlbumUncheckedUpdateManyWithoutAlbumNestedInput
  }

  export type AlbumCreateManyInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    imageId: string
    albumType?: $Enums.AlbumType
    releaseDate?: Date | string
    totalTracks?: number
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    artistId: string
  }

  export type AlbumUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: StringFieldUpdateOperationsInput | string
    albumType?: EnumAlbumTypeFieldUpdateOperationsInput | $Enums.AlbumType
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalTracks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlbumUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: StringFieldUpdateOperationsInput | string
    albumType?: EnumAlbumTypeFieldUpdateOperationsInput | $Enums.AlbumType
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalTracks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artistId?: StringFieldUpdateOperationsInput | string
  }

  export type SongCreateInput = {
    id?: string
    title: string
    slug: string
    audioId: string
    duration: number
    trackNumber: number
    lyrics?: string | null
    isExplicit?: boolean
    playCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    album: AlbumCreateNestedOneWithoutSongsInput
    artists?: SongArtistCreateNestedManyWithoutSongInput
    credits?: SongCreditCreateNestedManyWithoutSongInput
    genres?: SongGenreCreateNestedManyWithoutSongInput
    likedBy?: UserLikedSongCreateNestedManyWithoutSongInput
    playlistItems?: PlaylistItemCreateNestedManyWithoutSongInput
    playHistory?: PlayHistoryCreateNestedManyWithoutSongInput
  }

  export type SongUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    audioId: string
    duration: number
    trackNumber: number
    lyrics?: string | null
    isExplicit?: boolean
    playCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    albumId: string
    artists?: SongArtistUncheckedCreateNestedManyWithoutSongInput
    credits?: SongCreditUncheckedCreateNestedManyWithoutSongInput
    genres?: SongGenreUncheckedCreateNestedManyWithoutSongInput
    likedBy?: UserLikedSongUncheckedCreateNestedManyWithoutSongInput
    playlistItems?: PlaylistItemUncheckedCreateNestedManyWithoutSongInput
    playHistory?: PlayHistoryUncheckedCreateNestedManyWithoutSongInput
  }

  export type SongUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    trackNumber?: IntFieldUpdateOperationsInput | number
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    album?: AlbumUpdateOneRequiredWithoutSongsNestedInput
    artists?: SongArtistUpdateManyWithoutSongNestedInput
    credits?: SongCreditUpdateManyWithoutSongNestedInput
    genres?: SongGenreUpdateManyWithoutSongNestedInput
    likedBy?: UserLikedSongUpdateManyWithoutSongNestedInput
    playlistItems?: PlaylistItemUpdateManyWithoutSongNestedInput
    playHistory?: PlayHistoryUpdateManyWithoutSongNestedInput
  }

  export type SongUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    trackNumber?: IntFieldUpdateOperationsInput | number
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albumId?: StringFieldUpdateOperationsInput | string
    artists?: SongArtistUncheckedUpdateManyWithoutSongNestedInput
    credits?: SongCreditUncheckedUpdateManyWithoutSongNestedInput
    genres?: SongGenreUncheckedUpdateManyWithoutSongNestedInput
    likedBy?: UserLikedSongUncheckedUpdateManyWithoutSongNestedInput
    playlistItems?: PlaylistItemUncheckedUpdateManyWithoutSongNestedInput
    playHistory?: PlayHistoryUncheckedUpdateManyWithoutSongNestedInput
  }

  export type SongCreateManyInput = {
    id?: string
    title: string
    slug: string
    audioId: string
    duration: number
    trackNumber: number
    lyrics?: string | null
    isExplicit?: boolean
    playCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    albumId: string
  }

  export type SongUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    trackNumber?: IntFieldUpdateOperationsInput | number
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SongUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    trackNumber?: IntFieldUpdateOperationsInput | number
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albumId?: StringFieldUpdateOperationsInput | string
  }

  export type GenreCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    color?: string | null
    songs?: SongGenreCreateNestedManyWithoutGenreInput
    albums?: AlbumGenreCreateNestedManyWithoutGenreInput
    artists?: ArtistGenreCreateNestedManyWithoutGenreInput
  }

  export type GenreUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    color?: string | null
    songs?: SongGenreUncheckedCreateNestedManyWithoutGenreInput
    albums?: AlbumGenreUncheckedCreateNestedManyWithoutGenreInput
    artists?: ArtistGenreUncheckedCreateNestedManyWithoutGenreInput
  }

  export type GenreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    songs?: SongGenreUpdateManyWithoutGenreNestedInput
    albums?: AlbumGenreUpdateManyWithoutGenreNestedInput
    artists?: ArtistGenreUpdateManyWithoutGenreNestedInput
  }

  export type GenreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    songs?: SongGenreUncheckedUpdateManyWithoutGenreNestedInput
    albums?: AlbumGenreUncheckedUpdateManyWithoutGenreNestedInput
    artists?: ArtistGenreUncheckedUpdateManyWithoutGenreNestedInput
  }

  export type GenreCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    color?: string | null
  }

  export type GenreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GenreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SongArtistCreateInput = {
    id?: string
    role?: $Enums.ArtistRole
    order?: number
    song: SongCreateNestedOneWithoutArtistsInput
    artist: ArtistCreateNestedOneWithoutSongsInput
  }

  export type SongArtistUncheckedCreateInput = {
    id?: string
    songId: string
    artistId: string
    role?: $Enums.ArtistRole
    order?: number
  }

  export type SongArtistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumArtistRoleFieldUpdateOperationsInput | $Enums.ArtistRole
    order?: IntFieldUpdateOperationsInput | number
    song?: SongUpdateOneRequiredWithoutArtistsNestedInput
    artist?: ArtistUpdateOneRequiredWithoutSongsNestedInput
  }

  export type SongArtistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    role?: EnumArtistRoleFieldUpdateOperationsInput | $Enums.ArtistRole
    order?: IntFieldUpdateOperationsInput | number
  }

  export type SongArtistCreateManyInput = {
    id?: string
    songId: string
    artistId: string
    role?: $Enums.ArtistRole
    order?: number
  }

  export type SongArtistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumArtistRoleFieldUpdateOperationsInput | $Enums.ArtistRole
    order?: IntFieldUpdateOperationsInput | number
  }

  export type SongArtistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    role?: EnumArtistRoleFieldUpdateOperationsInput | $Enums.ArtistRole
    order?: IntFieldUpdateOperationsInput | number
  }

  export type SongCreditCreateInput = {
    id?: string
    name: string
    role: $Enums.CreditRole
    details?: string | null
    order?: number
    song: SongCreateNestedOneWithoutCreditsInput
    artist?: ArtistCreateNestedOneWithoutCreditsInput
  }

  export type SongCreditUncheckedCreateInput = {
    id?: string
    songId: string
    artistId?: string | null
    name: string
    role: $Enums.CreditRole
    details?: string | null
    order?: number
  }

  export type SongCreditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumCreditRoleFieldUpdateOperationsInput | $Enums.CreditRole
    details?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    song?: SongUpdateOneRequiredWithoutCreditsNestedInput
    artist?: ArtistUpdateOneWithoutCreditsNestedInput
  }

  export type SongCreditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
    artistId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumCreditRoleFieldUpdateOperationsInput | $Enums.CreditRole
    details?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type SongCreditCreateManyInput = {
    id?: string
    songId: string
    artistId?: string | null
    name: string
    role: $Enums.CreditRole
    details?: string | null
    order?: number
  }

  export type SongCreditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumCreditRoleFieldUpdateOperationsInput | $Enums.CreditRole
    details?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type SongCreditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
    artistId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumCreditRoleFieldUpdateOperationsInput | $Enums.CreditRole
    details?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type SongGenreCreateInput = {
    song: SongCreateNestedOneWithoutGenresInput
    genre: GenreCreateNestedOneWithoutSongsInput
  }

  export type SongGenreUncheckedCreateInput = {
    songId: string
    genreId: string
  }

  export type SongGenreUpdateInput = {
    song?: SongUpdateOneRequiredWithoutGenresNestedInput
    genre?: GenreUpdateOneRequiredWithoutSongsNestedInput
  }

  export type SongGenreUncheckedUpdateInput = {
    songId?: StringFieldUpdateOperationsInput | string
    genreId?: StringFieldUpdateOperationsInput | string
  }

  export type SongGenreCreateManyInput = {
    songId: string
    genreId: string
  }

  export type SongGenreUpdateManyMutationInput = {

  }

  export type SongGenreUncheckedUpdateManyInput = {
    songId?: StringFieldUpdateOperationsInput | string
    genreId?: StringFieldUpdateOperationsInput | string
  }

  export type AlbumGenreCreateInput = {
    album: AlbumCreateNestedOneWithoutGenresInput
    genre: GenreCreateNestedOneWithoutAlbumsInput
  }

  export type AlbumGenreUncheckedCreateInput = {
    albumId: string
    genreId: string
  }

  export type AlbumGenreUpdateInput = {
    album?: AlbumUpdateOneRequiredWithoutGenresNestedInput
    genre?: GenreUpdateOneRequiredWithoutAlbumsNestedInput
  }

  export type AlbumGenreUncheckedUpdateInput = {
    albumId?: StringFieldUpdateOperationsInput | string
    genreId?: StringFieldUpdateOperationsInput | string
  }

  export type AlbumGenreCreateManyInput = {
    albumId: string
    genreId: string
  }

  export type AlbumGenreUpdateManyMutationInput = {

  }

  export type AlbumGenreUncheckedUpdateManyInput = {
    albumId?: StringFieldUpdateOperationsInput | string
    genreId?: StringFieldUpdateOperationsInput | string
  }

  export type ArtistGenreCreateInput = {
    artist: ArtistCreateNestedOneWithoutGenresInput
    genre: GenreCreateNestedOneWithoutArtistsInput
  }

  export type ArtistGenreUncheckedCreateInput = {
    artistId: string
    genreId: string
  }

  export type ArtistGenreUpdateInput = {
    artist?: ArtistUpdateOneRequiredWithoutGenresNestedInput
    genre?: GenreUpdateOneRequiredWithoutArtistsNestedInput
  }

  export type ArtistGenreUncheckedUpdateInput = {
    artistId?: StringFieldUpdateOperationsInput | string
    genreId?: StringFieldUpdateOperationsInput | string
  }

  export type ArtistGenreCreateManyInput = {
    artistId: string
    genreId: string
  }

  export type ArtistGenreUpdateManyMutationInput = {

  }

  export type ArtistGenreUncheckedUpdateManyInput = {
    artistId?: StringFieldUpdateOperationsInput | string
    genreId?: StringFieldUpdateOperationsInput | string
  }

  export type PlaylistCreateInput = {
    id?: string
    title: string
    description?: string | null
    imageId?: string | null
    isPublic?: boolean
    isOfficial?: boolean
    totalTracks?: number
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutPlaylistsInput
    items?: PlaylistItemCreateNestedManyWithoutPlaylistInput
    likedBy?: UserLikedPlaylistCreateNestedManyWithoutPlaylistInput
  }

  export type PlaylistUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    imageId?: string | null
    isPublic?: boolean
    isOfficial?: boolean
    totalTracks?: number
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    items?: PlaylistItemUncheckedCreateNestedManyWithoutPlaylistInput
    likedBy?: UserLikedPlaylistUncheckedCreateNestedManyWithoutPlaylistInput
  }

  export type PlaylistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isOfficial?: BoolFieldUpdateOperationsInput | boolean
    totalTracks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutPlaylistsNestedInput
    items?: PlaylistItemUpdateManyWithoutPlaylistNestedInput
    likedBy?: UserLikedPlaylistUpdateManyWithoutPlaylistNestedInput
  }

  export type PlaylistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isOfficial?: BoolFieldUpdateOperationsInput | boolean
    totalTracks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    items?: PlaylistItemUncheckedUpdateManyWithoutPlaylistNestedInput
    likedBy?: UserLikedPlaylistUncheckedUpdateManyWithoutPlaylistNestedInput
  }

  export type PlaylistCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    imageId?: string | null
    isPublic?: boolean
    isOfficial?: boolean
    totalTracks?: number
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type PlaylistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isOfficial?: BoolFieldUpdateOperationsInput | boolean
    totalTracks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaylistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isOfficial?: BoolFieldUpdateOperationsInput | boolean
    totalTracks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlaylistItemCreateInput = {
    id?: string
    position: number
    addedAt?: Date | string
    playlist: PlaylistCreateNestedOneWithoutItemsInput
    song: SongCreateNestedOneWithoutPlaylistItemsInput
  }

  export type PlaylistItemUncheckedCreateInput = {
    id?: string
    position: number
    addedAt?: Date | string
    playlistId: string
    songId: string
  }

  export type PlaylistItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playlist?: PlaylistUpdateOneRequiredWithoutItemsNestedInput
    song?: SongUpdateOneRequiredWithoutPlaylistItemsNestedInput
  }

  export type PlaylistItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playlistId?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
  }

  export type PlaylistItemCreateManyInput = {
    id?: string
    position: number
    addedAt?: Date | string
    playlistId: string
    songId: string
  }

  export type PlaylistItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaylistItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playlistId?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
  }

  export type UserLikedSongCreateInput = {
    likedAt?: Date | string
    user: UserCreateNestedOneWithoutLikedSongsInput
    song: SongCreateNestedOneWithoutLikedByInput
  }

  export type UserLikedSongUncheckedCreateInput = {
    userId: string
    songId: string
    likedAt?: Date | string
  }

  export type UserLikedSongUpdateInput = {
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikedSongsNestedInput
    song?: SongUpdateOneRequiredWithoutLikedByNestedInput
  }

  export type UserLikedSongUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLikedSongCreateManyInput = {
    userId: string
    songId: string
    likedAt?: Date | string
  }

  export type UserLikedSongUpdateManyMutationInput = {
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLikedSongUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLikedAlbumCreateInput = {
    likedAt?: Date | string
    user: UserCreateNestedOneWithoutLikedAlbumsInput
    album: AlbumCreateNestedOneWithoutLikedByInput
  }

  export type UserLikedAlbumUncheckedCreateInput = {
    userId: string
    albumId: string
    likedAt?: Date | string
  }

  export type UserLikedAlbumUpdateInput = {
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikedAlbumsNestedInput
    album?: AlbumUpdateOneRequiredWithoutLikedByNestedInput
  }

  export type UserLikedAlbumUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    albumId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLikedAlbumCreateManyInput = {
    userId: string
    albumId: string
    likedAt?: Date | string
  }

  export type UserLikedAlbumUpdateManyMutationInput = {
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLikedAlbumUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    albumId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLikedArtistCreateInput = {
    likedAt?: Date | string
    user: UserCreateNestedOneWithoutLikedArtistsInput
    artist: ArtistCreateNestedOneWithoutLikedByInput
  }

  export type UserLikedArtistUncheckedCreateInput = {
    userId: string
    artistId: string
    likedAt?: Date | string
  }

  export type UserLikedArtistUpdateInput = {
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikedArtistsNestedInput
    artist?: ArtistUpdateOneRequiredWithoutLikedByNestedInput
  }

  export type UserLikedArtistUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLikedArtistCreateManyInput = {
    userId: string
    artistId: string
    likedAt?: Date | string
  }

  export type UserLikedArtistUpdateManyMutationInput = {
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLikedArtistUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLikedPlaylistCreateInput = {
    likedAt?: Date | string
    user: UserCreateNestedOneWithoutLikedPlaylistsInput
    playlist: PlaylistCreateNestedOneWithoutLikedByInput
  }

  export type UserLikedPlaylistUncheckedCreateInput = {
    userId: string
    playlistId: string
    likedAt?: Date | string
  }

  export type UserLikedPlaylistUpdateInput = {
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikedPlaylistsNestedInput
    playlist?: PlaylistUpdateOneRequiredWithoutLikedByNestedInput
  }

  export type UserLikedPlaylistUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    playlistId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLikedPlaylistCreateManyInput = {
    userId: string
    playlistId: string
    likedAt?: Date | string
  }

  export type UserLikedPlaylistUpdateManyMutationInput = {
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLikedPlaylistUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    playlistId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowCreateInput = {
    followedAt?: Date | string
    follower: UserCreateNestedOneWithoutFollowersInput
    following: UserCreateNestedOneWithoutFollowingInput
  }

  export type UserFollowUncheckedCreateInput = {
    followerId: string
    followingId: string
    followedAt?: Date | string
  }

  export type UserFollowUpdateInput = {
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: UserUpdateOneRequiredWithoutFollowersNestedInput
    following?: UserUpdateOneRequiredWithoutFollowingNestedInput
  }

  export type UserFollowUncheckedUpdateInput = {
    followerId?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowCreateManyInput = {
    followerId: string
    followingId: string
    followedAt?: Date | string
  }

  export type UserFollowUpdateManyMutationInput = {
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowUncheckedUpdateManyInput = {
    followerId?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayHistoryCreateInput = {
    id?: string
    playedAt?: Date | string
    duration: number
    deviceType?: string | null
    user: UserCreateNestedOneWithoutPlayHistoryInput
    song: SongCreateNestedOneWithoutPlayHistoryInput
  }

  export type PlayHistoryUncheckedCreateInput = {
    id?: string
    playedAt?: Date | string
    duration: number
    deviceType?: string | null
    userId: string
    songId: string
  }

  export type PlayHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutPlayHistoryNestedInput
    song?: SongUpdateOneRequiredWithoutPlayHistoryNestedInput
  }

  export type PlayHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
  }

  export type PlayHistoryCreateManyInput = {
    id?: string
    playedAt?: Date | string
    duration: number
    deviceType?: string | null
    userId: string
    songId: string
  }

  export type PlayHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlayHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
  }

  export type SearchHistoryCreateInput = {
    id?: string
    query: string
    resultType?: string | null
    resultId?: string | null
    searchedAt?: Date | string
    user: UserCreateNestedOneWithoutSearchHistoryInput
  }

  export type SearchHistoryUncheckedCreateInput = {
    id?: string
    query: string
    resultType?: string | null
    resultId?: string | null
    searchedAt?: Date | string
    userId: string
  }

  export type SearchHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    resultType?: NullableStringFieldUpdateOperationsInput | string | null
    resultId?: NullableStringFieldUpdateOperationsInput | string | null
    searchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSearchHistoryNestedInput
  }

  export type SearchHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    resultType?: NullableStringFieldUpdateOperationsInput | string | null
    resultId?: NullableStringFieldUpdateOperationsInput | string | null
    searchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SearchHistoryCreateManyInput = {
    id?: string
    query: string
    resultType?: string | null
    resultId?: string | null
    searchedAt?: Date | string
    userId: string
  }

  export type SearchHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    resultType?: NullableStringFieldUpdateOperationsInput | string | null
    resultId?: NullableStringFieldUpdateOperationsInput | string | null
    searchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    resultType?: NullableStringFieldUpdateOperationsInput | string | null
    resultId?: NullableStringFieldUpdateOperationsInput | string | null
    searchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRecommendationCreateInput = {
    id?: string
    type: string
    targetId: string
    score: number
    reason?: string | null
    createdAt?: Date | string
    userId: string
  }

  export type UserRecommendationUncheckedCreateInput = {
    id?: string
    type: string
    targetId: string
    score: number
    reason?: string | null
    createdAt?: Date | string
    userId: string
  }

  export type UserRecommendationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRecommendationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRecommendationCreateManyInput = {
    id?: string
    type: string
    targetId: string
    score: number
    reason?: string | null
    createdAt?: Date | string
    userId: string
  }

  export type UserRecommendationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRecommendationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserQueueCreateInput = {
    id?: string
    position: number
    createdAt?: Date | string
    userId: string
    songId: string
  }

  export type UserQueueUncheckedCreateInput = {
    id?: string
    position: number
    createdAt?: Date | string
    userId: string
    songId: string
  }

  export type UserQueueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
  }

  export type UserQueueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
  }

  export type UserQueueCreateManyInput = {
    id?: string
    position: number
    createdAt?: Date | string
    userId: string
    songId: string
  }

  export type UserQueueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
  }

  export type UserQueueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
  }

  export type ChartCreateInput = {
    id?: string
    name: string
    type: $Enums.ChartType
    period: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    items?: ChartItemCreateNestedManyWithoutChartInput
  }

  export type ChartUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.ChartType
    period: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    items?: ChartItemUncheckedCreateNestedManyWithoutChartInput
  }

  export type ChartUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumChartTypeFieldUpdateOperationsInput | $Enums.ChartType
    period?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ChartItemUpdateManyWithoutChartNestedInput
  }

  export type ChartUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumChartTypeFieldUpdateOperationsInput | $Enums.ChartType
    period?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ChartItemUncheckedUpdateManyWithoutChartNestedInput
  }

  export type ChartCreateManyInput = {
    id?: string
    name: string
    type: $Enums.ChartType
    period: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
  }

  export type ChartUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumChartTypeFieldUpdateOperationsInput | $Enums.ChartType
    period?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumChartTypeFieldUpdateOperationsInput | $Enums.ChartType
    period?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartItemCreateInput = {
    position: number
    itemType: string
    itemId: string
    plays?: number
    chart: ChartCreateNestedOneWithoutItemsInput
  }

  export type ChartItemUncheckedCreateInput = {
    chartId: string
    position: number
    itemType: string
    itemId: string
    plays?: number
  }

  export type ChartItemUpdateInput = {
    position?: IntFieldUpdateOperationsInput | number
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    plays?: IntFieldUpdateOperationsInput | number
    chart?: ChartUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ChartItemUncheckedUpdateInput = {
    chartId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    plays?: IntFieldUpdateOperationsInput | number
  }

  export type ChartItemCreateManyInput = {
    chartId: string
    position: number
    itemType: string
    itemId: string
    plays?: number
  }

  export type ChartItemUpdateManyMutationInput = {
    position?: IntFieldUpdateOperationsInput | number
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    plays?: IntFieldUpdateOperationsInput | number
  }

  export type ChartItemUncheckedUpdateManyInput = {
    chartId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    plays?: IntFieldUpdateOperationsInput | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type UserSubscriptionNullableScalarRelationFilter = {
    is?: UserSubscriptionWhereInput | null
    isNot?: UserSubscriptionWhereInput | null
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type PlaylistListRelationFilter = {
    every?: PlaylistWhereInput
    some?: PlaylistWhereInput
    none?: PlaylistWhereInput
  }

  export type UserLikedSongListRelationFilter = {
    every?: UserLikedSongWhereInput
    some?: UserLikedSongWhereInput
    none?: UserLikedSongWhereInput
  }

  export type UserLikedAlbumListRelationFilter = {
    every?: UserLikedAlbumWhereInput
    some?: UserLikedAlbumWhereInput
    none?: UserLikedAlbumWhereInput
  }

  export type UserLikedPlaylistListRelationFilter = {
    every?: UserLikedPlaylistWhereInput
    some?: UserLikedPlaylistWhereInput
    none?: UserLikedPlaylistWhereInput
  }

  export type UserLikedArtistListRelationFilter = {
    every?: UserLikedArtistWhereInput
    some?: UserLikedArtistWhereInput
    none?: UserLikedArtistWhereInput
  }

  export type PlayHistoryListRelationFilter = {
    every?: PlayHistoryWhereInput
    some?: PlayHistoryWhereInput
    none?: PlayHistoryWhereInput
  }

  export type SearchHistoryListRelationFilter = {
    every?: SearchHistoryWhereInput
    some?: SearchHistoryWhereInput
    none?: SearchHistoryWhereInput
  }

  export type UserFollowListRelationFilter = {
    every?: UserFollowWhereInput
    some?: UserFollowWhereInput
    none?: UserFollowWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlaylistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLikedSongOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLikedAlbumOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLikedPlaylistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLikedArtistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SearchHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserFollowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    name?: SortOrder
    password?: SortOrder
    imageId?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bio?: SortOrder
    country?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    name?: SortOrder
    password?: SortOrder
    imageId?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bio?: SortOrder
    country?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    name?: SortOrder
    password?: SortOrder
    imageId?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bio?: SortOrder
    country?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type EnumSubscriptionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTypeFilter<$PrismaModel> | $Enums.SubscriptionType
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    autoRenew?: SortOrder
    paymentMethod?: SortOrder
  }

  export type UserSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    autoRenew?: SortOrder
    paymentMethod?: SortOrder
  }

  export type UserSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    autoRenew?: SortOrder
    paymentMethod?: SortOrder
  }

  export type EnumSubscriptionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTypeFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTypeFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type AlbumListRelationFilter = {
    every?: AlbumWhereInput
    some?: AlbumWhereInput
    none?: AlbumWhereInput
  }

  export type SongArtistListRelationFilter = {
    every?: SongArtistWhereInput
    some?: SongArtistWhereInput
    none?: SongArtistWhereInput
  }

  export type ArtistGenreListRelationFilter = {
    every?: ArtistGenreWhereInput
    some?: ArtistGenreWhereInput
    none?: ArtistGenreWhereInput
  }

  export type SongCreditListRelationFilter = {
    every?: SongCreditWhereInput
    some?: SongCreditWhereInput
    none?: SongCreditWhereInput
  }

  export type AlbumOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SongArtistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArtistGenreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SongCreditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArtistCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    bio?: SortOrder
    imageId?: SortOrder
    verified?: SortOrder
    monthlyListeners?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArtistAvgOrderByAggregateInput = {
    monthlyListeners?: SortOrder
  }

  export type ArtistMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    bio?: SortOrder
    imageId?: SortOrder
    verified?: SortOrder
    monthlyListeners?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArtistMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    bio?: SortOrder
    imageId?: SortOrder
    verified?: SortOrder
    monthlyListeners?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArtistSumOrderByAggregateInput = {
    monthlyListeners?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumAlbumTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AlbumType | EnumAlbumTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlbumType[] | ListEnumAlbumTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlbumType[] | ListEnumAlbumTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlbumTypeFilter<$PrismaModel> | $Enums.AlbumType
  }

  export type ArtistScalarRelationFilter = {
    is?: ArtistWhereInput
    isNot?: ArtistWhereInput
  }

  export type SongListRelationFilter = {
    every?: SongWhereInput
    some?: SongWhereInput
    none?: SongWhereInput
  }

  export type AlbumGenreListRelationFilter = {
    every?: AlbumGenreWhereInput
    some?: AlbumGenreWhereInput
    none?: AlbumGenreWhereInput
  }

  export type SongOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlbumGenreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlbumCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    imageId?: SortOrder
    albumType?: SortOrder
    releaseDate?: SortOrder
    totalTracks?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    artistId?: SortOrder
  }

  export type AlbumAvgOrderByAggregateInput = {
    totalTracks?: SortOrder
    duration?: SortOrder
  }

  export type AlbumMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    imageId?: SortOrder
    albumType?: SortOrder
    releaseDate?: SortOrder
    totalTracks?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    artistId?: SortOrder
  }

  export type AlbumMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    imageId?: SortOrder
    albumType?: SortOrder
    releaseDate?: SortOrder
    totalTracks?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    artistId?: SortOrder
  }

  export type AlbumSumOrderByAggregateInput = {
    totalTracks?: SortOrder
    duration?: SortOrder
  }

  export type EnumAlbumTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlbumType | EnumAlbumTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlbumType[] | ListEnumAlbumTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlbumType[] | ListEnumAlbumTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlbumTypeWithAggregatesFilter<$PrismaModel> | $Enums.AlbumType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlbumTypeFilter<$PrismaModel>
    _max?: NestedEnumAlbumTypeFilter<$PrismaModel>
  }

  export type AlbumScalarRelationFilter = {
    is?: AlbumWhereInput
    isNot?: AlbumWhereInput
  }

  export type SongGenreListRelationFilter = {
    every?: SongGenreWhereInput
    some?: SongGenreWhereInput
    none?: SongGenreWhereInput
  }

  export type PlaylistItemListRelationFilter = {
    every?: PlaylistItemWhereInput
    some?: PlaylistItemWhereInput
    none?: PlaylistItemWhereInput
  }

  export type SongGenreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlaylistItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SongCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    audioId?: SortOrder
    duration?: SortOrder
    trackNumber?: SortOrder
    lyrics?: SortOrder
    isExplicit?: SortOrder
    playCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    albumId?: SortOrder
  }

  export type SongAvgOrderByAggregateInput = {
    duration?: SortOrder
    trackNumber?: SortOrder
    playCount?: SortOrder
  }

  export type SongMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    audioId?: SortOrder
    duration?: SortOrder
    trackNumber?: SortOrder
    lyrics?: SortOrder
    isExplicit?: SortOrder
    playCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    albumId?: SortOrder
  }

  export type SongMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    audioId?: SortOrder
    duration?: SortOrder
    trackNumber?: SortOrder
    lyrics?: SortOrder
    isExplicit?: SortOrder
    playCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    albumId?: SortOrder
  }

  export type SongSumOrderByAggregateInput = {
    duration?: SortOrder
    trackNumber?: SortOrder
    playCount?: SortOrder
  }

  export type GenreCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    color?: SortOrder
  }

  export type GenreMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    color?: SortOrder
  }

  export type GenreMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    color?: SortOrder
  }

  export type EnumArtistRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ArtistRole | EnumArtistRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ArtistRole[] | ListEnumArtistRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArtistRole[] | ListEnumArtistRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumArtistRoleFilter<$PrismaModel> | $Enums.ArtistRole
  }

  export type SongScalarRelationFilter = {
    is?: SongWhereInput
    isNot?: SongWhereInput
  }

  export type SongArtistSongIdArtistIdRoleCompoundUniqueInput = {
    songId: string
    artistId: string
    role: $Enums.ArtistRole
  }

  export type SongArtistCountOrderByAggregateInput = {
    id?: SortOrder
    songId?: SortOrder
    artistId?: SortOrder
    role?: SortOrder
    order?: SortOrder
  }

  export type SongArtistAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type SongArtistMaxOrderByAggregateInput = {
    id?: SortOrder
    songId?: SortOrder
    artistId?: SortOrder
    role?: SortOrder
    order?: SortOrder
  }

  export type SongArtistMinOrderByAggregateInput = {
    id?: SortOrder
    songId?: SortOrder
    artistId?: SortOrder
    role?: SortOrder
    order?: SortOrder
  }

  export type SongArtistSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumArtistRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArtistRole | EnumArtistRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ArtistRole[] | ListEnumArtistRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArtistRole[] | ListEnumArtistRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumArtistRoleWithAggregatesFilter<$PrismaModel> | $Enums.ArtistRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArtistRoleFilter<$PrismaModel>
    _max?: NestedEnumArtistRoleFilter<$PrismaModel>
  }

  export type EnumCreditRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditRole | EnumCreditRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CreditRole[] | ListEnumCreditRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditRole[] | ListEnumCreditRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditRoleFilter<$PrismaModel> | $Enums.CreditRole
  }

  export type ArtistNullableScalarRelationFilter = {
    is?: ArtistWhereInput | null
    isNot?: ArtistWhereInput | null
  }

  export type SongCreditCountOrderByAggregateInput = {
    id?: SortOrder
    songId?: SortOrder
    artistId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    details?: SortOrder
    order?: SortOrder
  }

  export type SongCreditAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type SongCreditMaxOrderByAggregateInput = {
    id?: SortOrder
    songId?: SortOrder
    artistId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    details?: SortOrder
    order?: SortOrder
  }

  export type SongCreditMinOrderByAggregateInput = {
    id?: SortOrder
    songId?: SortOrder
    artistId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    details?: SortOrder
    order?: SortOrder
  }

  export type SongCreditSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumCreditRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditRole | EnumCreditRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CreditRole[] | ListEnumCreditRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditRole[] | ListEnumCreditRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditRoleWithAggregatesFilter<$PrismaModel> | $Enums.CreditRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreditRoleFilter<$PrismaModel>
    _max?: NestedEnumCreditRoleFilter<$PrismaModel>
  }

  export type GenreScalarRelationFilter = {
    is?: GenreWhereInput
    isNot?: GenreWhereInput
  }

  export type SongGenreSongIdGenreIdCompoundUniqueInput = {
    songId: string
    genreId: string
  }

  export type SongGenreCountOrderByAggregateInput = {
    songId?: SortOrder
    genreId?: SortOrder
  }

  export type SongGenreMaxOrderByAggregateInput = {
    songId?: SortOrder
    genreId?: SortOrder
  }

  export type SongGenreMinOrderByAggregateInput = {
    songId?: SortOrder
    genreId?: SortOrder
  }

  export type AlbumGenreAlbumIdGenreIdCompoundUniqueInput = {
    albumId: string
    genreId: string
  }

  export type AlbumGenreCountOrderByAggregateInput = {
    albumId?: SortOrder
    genreId?: SortOrder
  }

  export type AlbumGenreMaxOrderByAggregateInput = {
    albumId?: SortOrder
    genreId?: SortOrder
  }

  export type AlbumGenreMinOrderByAggregateInput = {
    albumId?: SortOrder
    genreId?: SortOrder
  }

  export type ArtistGenreArtistIdGenreIdCompoundUniqueInput = {
    artistId: string
    genreId: string
  }

  export type ArtistGenreCountOrderByAggregateInput = {
    artistId?: SortOrder
    genreId?: SortOrder
  }

  export type ArtistGenreMaxOrderByAggregateInput = {
    artistId?: SortOrder
    genreId?: SortOrder
  }

  export type ArtistGenreMinOrderByAggregateInput = {
    artistId?: SortOrder
    genreId?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type PlaylistCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageId?: SortOrder
    isPublic?: SortOrder
    isOfficial?: SortOrder
    totalTracks?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type PlaylistAvgOrderByAggregateInput = {
    totalTracks?: SortOrder
    duration?: SortOrder
  }

  export type PlaylistMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageId?: SortOrder
    isPublic?: SortOrder
    isOfficial?: SortOrder
    totalTracks?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type PlaylistMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageId?: SortOrder
    isPublic?: SortOrder
    isOfficial?: SortOrder
    totalTracks?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type PlaylistSumOrderByAggregateInput = {
    totalTracks?: SortOrder
    duration?: SortOrder
  }

  export type PlaylistScalarRelationFilter = {
    is?: PlaylistWhereInput
    isNot?: PlaylistWhereInput
  }

  export type PlaylistItemPlaylistIdSongIdCompoundUniqueInput = {
    playlistId: string
    songId: string
  }

  export type PlaylistItemCountOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    addedAt?: SortOrder
    playlistId?: SortOrder
    songId?: SortOrder
  }

  export type PlaylistItemAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type PlaylistItemMaxOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    addedAt?: SortOrder
    playlistId?: SortOrder
    songId?: SortOrder
  }

  export type PlaylistItemMinOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    addedAt?: SortOrder
    playlistId?: SortOrder
    songId?: SortOrder
  }

  export type PlaylistItemSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type UserLikedSongUserIdSongIdCompoundUniqueInput = {
    userId: string
    songId: string
  }

  export type UserLikedSongCountOrderByAggregateInput = {
    userId?: SortOrder
    songId?: SortOrder
    likedAt?: SortOrder
  }

  export type UserLikedSongMaxOrderByAggregateInput = {
    userId?: SortOrder
    songId?: SortOrder
    likedAt?: SortOrder
  }

  export type UserLikedSongMinOrderByAggregateInput = {
    userId?: SortOrder
    songId?: SortOrder
    likedAt?: SortOrder
  }

  export type UserLikedAlbumUserIdAlbumIdCompoundUniqueInput = {
    userId: string
    albumId: string
  }

  export type UserLikedAlbumCountOrderByAggregateInput = {
    userId?: SortOrder
    albumId?: SortOrder
    likedAt?: SortOrder
  }

  export type UserLikedAlbumMaxOrderByAggregateInput = {
    userId?: SortOrder
    albumId?: SortOrder
    likedAt?: SortOrder
  }

  export type UserLikedAlbumMinOrderByAggregateInput = {
    userId?: SortOrder
    albumId?: SortOrder
    likedAt?: SortOrder
  }

  export type UserLikedArtistUserIdArtistIdCompoundUniqueInput = {
    userId: string
    artistId: string
  }

  export type UserLikedArtistCountOrderByAggregateInput = {
    userId?: SortOrder
    artistId?: SortOrder
    likedAt?: SortOrder
  }

  export type UserLikedArtistMaxOrderByAggregateInput = {
    userId?: SortOrder
    artistId?: SortOrder
    likedAt?: SortOrder
  }

  export type UserLikedArtistMinOrderByAggregateInput = {
    userId?: SortOrder
    artistId?: SortOrder
    likedAt?: SortOrder
  }

  export type UserLikedPlaylistUserIdPlaylistIdCompoundUniqueInput = {
    userId: string
    playlistId: string
  }

  export type UserLikedPlaylistCountOrderByAggregateInput = {
    userId?: SortOrder
    playlistId?: SortOrder
    likedAt?: SortOrder
  }

  export type UserLikedPlaylistMaxOrderByAggregateInput = {
    userId?: SortOrder
    playlistId?: SortOrder
    likedAt?: SortOrder
  }

  export type UserLikedPlaylistMinOrderByAggregateInput = {
    userId?: SortOrder
    playlistId?: SortOrder
    likedAt?: SortOrder
  }

  export type UserFollowFollowerIdFollowingIdCompoundUniqueInput = {
    followerId: string
    followingId: string
  }

  export type UserFollowCountOrderByAggregateInput = {
    followerId?: SortOrder
    followingId?: SortOrder
    followedAt?: SortOrder
  }

  export type UserFollowMaxOrderByAggregateInput = {
    followerId?: SortOrder
    followingId?: SortOrder
    followedAt?: SortOrder
  }

  export type UserFollowMinOrderByAggregateInput = {
    followerId?: SortOrder
    followingId?: SortOrder
    followedAt?: SortOrder
  }

  export type PlayHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    playedAt?: SortOrder
    duration?: SortOrder
    deviceType?: SortOrder
    userId?: SortOrder
    songId?: SortOrder
  }

  export type PlayHistoryAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type PlayHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    playedAt?: SortOrder
    duration?: SortOrder
    deviceType?: SortOrder
    userId?: SortOrder
    songId?: SortOrder
  }

  export type PlayHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    playedAt?: SortOrder
    duration?: SortOrder
    deviceType?: SortOrder
    userId?: SortOrder
    songId?: SortOrder
  }

  export type PlayHistorySumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type SearchHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    resultType?: SortOrder
    resultId?: SortOrder
    searchedAt?: SortOrder
    userId?: SortOrder
  }

  export type SearchHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    resultType?: SortOrder
    resultId?: SortOrder
    searchedAt?: SortOrder
    userId?: SortOrder
  }

  export type SearchHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    resultType?: SortOrder
    resultId?: SortOrder
    searchedAt?: SortOrder
    userId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type UserRecommendationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    targetId?: SortOrder
    score?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type UserRecommendationAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type UserRecommendationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    targetId?: SortOrder
    score?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type UserRecommendationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    targetId?: SortOrder
    score?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type UserRecommendationSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type UserQueueUserIdPositionCompoundUniqueInput = {
    userId: string
    position: number
  }

  export type UserQueueCountOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    songId?: SortOrder
  }

  export type UserQueueAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type UserQueueMaxOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    songId?: SortOrder
  }

  export type UserQueueMinOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    songId?: SortOrder
  }

  export type UserQueueSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type EnumChartTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChartType | EnumChartTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChartType[] | ListEnumChartTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChartType[] | ListEnumChartTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChartTypeFilter<$PrismaModel> | $Enums.ChartType
  }

  export type ChartItemListRelationFilter = {
    every?: ChartItemWhereInput
    some?: ChartItemWhereInput
    none?: ChartItemWhereInput
  }

  export type ChartItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChartCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
  }

  export type ChartMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
  }

  export type ChartMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumChartTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChartType | EnumChartTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChartType[] | ListEnumChartTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChartType[] | ListEnumChartTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChartTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChartType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChartTypeFilter<$PrismaModel>
    _max?: NestedEnumChartTypeFilter<$PrismaModel>
  }

  export type ChartScalarRelationFilter = {
    is?: ChartWhereInput
    isNot?: ChartWhereInput
  }

  export type ChartItemChartIdPositionCompoundUniqueInput = {
    chartId: string
    position: number
  }

  export type ChartItemCountOrderByAggregateInput = {
    chartId?: SortOrder
    position?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    plays?: SortOrder
  }

  export type ChartItemAvgOrderByAggregateInput = {
    position?: SortOrder
    plays?: SortOrder
  }

  export type ChartItemMaxOrderByAggregateInput = {
    chartId?: SortOrder
    position?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    plays?: SortOrder
  }

  export type ChartItemMinOrderByAggregateInput = {
    chartId?: SortOrder
    position?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    plays?: SortOrder
  }

  export type ChartItemSumOrderByAggregateInput = {
    position?: SortOrder
    plays?: SortOrder
  }

  export type UserSubscriptionCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput
    connect?: UserSubscriptionWhereUniqueInput
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type PlaylistCreateNestedManyWithoutUserInput = {
    create?: XOR<PlaylistCreateWithoutUserInput, PlaylistUncheckedCreateWithoutUserInput> | PlaylistCreateWithoutUserInput[] | PlaylistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaylistCreateOrConnectWithoutUserInput | PlaylistCreateOrConnectWithoutUserInput[]
    createMany?: PlaylistCreateManyUserInputEnvelope
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
  }

  export type UserLikedSongCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLikedSongCreateWithoutUserInput, UserLikedSongUncheckedCreateWithoutUserInput> | UserLikedSongCreateWithoutUserInput[] | UserLikedSongUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLikedSongCreateOrConnectWithoutUserInput | UserLikedSongCreateOrConnectWithoutUserInput[]
    createMany?: UserLikedSongCreateManyUserInputEnvelope
    connect?: UserLikedSongWhereUniqueInput | UserLikedSongWhereUniqueInput[]
  }

  export type UserLikedAlbumCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLikedAlbumCreateWithoutUserInput, UserLikedAlbumUncheckedCreateWithoutUserInput> | UserLikedAlbumCreateWithoutUserInput[] | UserLikedAlbumUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLikedAlbumCreateOrConnectWithoutUserInput | UserLikedAlbumCreateOrConnectWithoutUserInput[]
    createMany?: UserLikedAlbumCreateManyUserInputEnvelope
    connect?: UserLikedAlbumWhereUniqueInput | UserLikedAlbumWhereUniqueInput[]
  }

  export type UserLikedPlaylistCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLikedPlaylistCreateWithoutUserInput, UserLikedPlaylistUncheckedCreateWithoutUserInput> | UserLikedPlaylistCreateWithoutUserInput[] | UserLikedPlaylistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLikedPlaylistCreateOrConnectWithoutUserInput | UserLikedPlaylistCreateOrConnectWithoutUserInput[]
    createMany?: UserLikedPlaylistCreateManyUserInputEnvelope
    connect?: UserLikedPlaylistWhereUniqueInput | UserLikedPlaylistWhereUniqueInput[]
  }

  export type UserLikedArtistCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLikedArtistCreateWithoutUserInput, UserLikedArtistUncheckedCreateWithoutUserInput> | UserLikedArtistCreateWithoutUserInput[] | UserLikedArtistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLikedArtistCreateOrConnectWithoutUserInput | UserLikedArtistCreateOrConnectWithoutUserInput[]
    createMany?: UserLikedArtistCreateManyUserInputEnvelope
    connect?: UserLikedArtistWhereUniqueInput | UserLikedArtistWhereUniqueInput[]
  }

  export type PlayHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<PlayHistoryCreateWithoutUserInput, PlayHistoryUncheckedCreateWithoutUserInput> | PlayHistoryCreateWithoutUserInput[] | PlayHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayHistoryCreateOrConnectWithoutUserInput | PlayHistoryCreateOrConnectWithoutUserInput[]
    createMany?: PlayHistoryCreateManyUserInputEnvelope
    connect?: PlayHistoryWhereUniqueInput | PlayHistoryWhereUniqueInput[]
  }

  export type SearchHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput> | SearchHistoryCreateWithoutUserInput[] | SearchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutUserInput | SearchHistoryCreateOrConnectWithoutUserInput[]
    createMany?: SearchHistoryCreateManyUserInputEnvelope
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
  }

  export type UserFollowCreateNestedManyWithoutFollowerInput = {
    create?: XOR<UserFollowCreateWithoutFollowerInput, UserFollowUncheckedCreateWithoutFollowerInput> | UserFollowCreateWithoutFollowerInput[] | UserFollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutFollowerInput | UserFollowCreateOrConnectWithoutFollowerInput[]
    createMany?: UserFollowCreateManyFollowerInputEnvelope
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
  }

  export type UserFollowCreateNestedManyWithoutFollowingInput = {
    create?: XOR<UserFollowCreateWithoutFollowingInput, UserFollowUncheckedCreateWithoutFollowingInput> | UserFollowCreateWithoutFollowingInput[] | UserFollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutFollowingInput | UserFollowCreateOrConnectWithoutFollowingInput[]
    createMany?: UserFollowCreateManyFollowingInputEnvelope
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
  }

  export type UserSubscriptionUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput
    connect?: UserSubscriptionWhereUniqueInput
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type PlaylistUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PlaylistCreateWithoutUserInput, PlaylistUncheckedCreateWithoutUserInput> | PlaylistCreateWithoutUserInput[] | PlaylistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaylistCreateOrConnectWithoutUserInput | PlaylistCreateOrConnectWithoutUserInput[]
    createMany?: PlaylistCreateManyUserInputEnvelope
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
  }

  export type UserLikedSongUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLikedSongCreateWithoutUserInput, UserLikedSongUncheckedCreateWithoutUserInput> | UserLikedSongCreateWithoutUserInput[] | UserLikedSongUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLikedSongCreateOrConnectWithoutUserInput | UserLikedSongCreateOrConnectWithoutUserInput[]
    createMany?: UserLikedSongCreateManyUserInputEnvelope
    connect?: UserLikedSongWhereUniqueInput | UserLikedSongWhereUniqueInput[]
  }

  export type UserLikedAlbumUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLikedAlbumCreateWithoutUserInput, UserLikedAlbumUncheckedCreateWithoutUserInput> | UserLikedAlbumCreateWithoutUserInput[] | UserLikedAlbumUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLikedAlbumCreateOrConnectWithoutUserInput | UserLikedAlbumCreateOrConnectWithoutUserInput[]
    createMany?: UserLikedAlbumCreateManyUserInputEnvelope
    connect?: UserLikedAlbumWhereUniqueInput | UserLikedAlbumWhereUniqueInput[]
  }

  export type UserLikedPlaylistUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLikedPlaylistCreateWithoutUserInput, UserLikedPlaylistUncheckedCreateWithoutUserInput> | UserLikedPlaylistCreateWithoutUserInput[] | UserLikedPlaylistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLikedPlaylistCreateOrConnectWithoutUserInput | UserLikedPlaylistCreateOrConnectWithoutUserInput[]
    createMany?: UserLikedPlaylistCreateManyUserInputEnvelope
    connect?: UserLikedPlaylistWhereUniqueInput | UserLikedPlaylistWhereUniqueInput[]
  }

  export type UserLikedArtistUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLikedArtistCreateWithoutUserInput, UserLikedArtistUncheckedCreateWithoutUserInput> | UserLikedArtistCreateWithoutUserInput[] | UserLikedArtistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLikedArtistCreateOrConnectWithoutUserInput | UserLikedArtistCreateOrConnectWithoutUserInput[]
    createMany?: UserLikedArtistCreateManyUserInputEnvelope
    connect?: UserLikedArtistWhereUniqueInput | UserLikedArtistWhereUniqueInput[]
  }

  export type PlayHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PlayHistoryCreateWithoutUserInput, PlayHistoryUncheckedCreateWithoutUserInput> | PlayHistoryCreateWithoutUserInput[] | PlayHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayHistoryCreateOrConnectWithoutUserInput | PlayHistoryCreateOrConnectWithoutUserInput[]
    createMany?: PlayHistoryCreateManyUserInputEnvelope
    connect?: PlayHistoryWhereUniqueInput | PlayHistoryWhereUniqueInput[]
  }

  export type SearchHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput> | SearchHistoryCreateWithoutUserInput[] | SearchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutUserInput | SearchHistoryCreateOrConnectWithoutUserInput[]
    createMany?: SearchHistoryCreateManyUserInputEnvelope
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
  }

  export type UserFollowUncheckedCreateNestedManyWithoutFollowerInput = {
    create?: XOR<UserFollowCreateWithoutFollowerInput, UserFollowUncheckedCreateWithoutFollowerInput> | UserFollowCreateWithoutFollowerInput[] | UserFollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutFollowerInput | UserFollowCreateOrConnectWithoutFollowerInput[]
    createMany?: UserFollowCreateManyFollowerInputEnvelope
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
  }

  export type UserFollowUncheckedCreateNestedManyWithoutFollowingInput = {
    create?: XOR<UserFollowCreateWithoutFollowingInput, UserFollowUncheckedCreateWithoutFollowingInput> | UserFollowCreateWithoutFollowingInput[] | UserFollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutFollowingInput | UserFollowCreateOrConnectWithoutFollowingInput[]
    createMany?: UserFollowCreateManyFollowingInputEnvelope
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type UserSubscriptionUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput
    upsert?: UserSubscriptionUpsertWithoutUserInput
    disconnect?: UserSubscriptionWhereInput | boolean
    delete?: UserSubscriptionWhereInput | boolean
    connect?: UserSubscriptionWhereUniqueInput
    update?: XOR<XOR<UserSubscriptionUpdateToOneWithWhereWithoutUserInput, UserSubscriptionUpdateWithoutUserInput>, UserSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type PlaylistUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlaylistCreateWithoutUserInput, PlaylistUncheckedCreateWithoutUserInput> | PlaylistCreateWithoutUserInput[] | PlaylistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaylistCreateOrConnectWithoutUserInput | PlaylistCreateOrConnectWithoutUserInput[]
    upsert?: PlaylistUpsertWithWhereUniqueWithoutUserInput | PlaylistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlaylistCreateManyUserInputEnvelope
    set?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    disconnect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    delete?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    update?: PlaylistUpdateWithWhereUniqueWithoutUserInput | PlaylistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlaylistUpdateManyWithWhereWithoutUserInput | PlaylistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlaylistScalarWhereInput | PlaylistScalarWhereInput[]
  }

  export type UserLikedSongUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLikedSongCreateWithoutUserInput, UserLikedSongUncheckedCreateWithoutUserInput> | UserLikedSongCreateWithoutUserInput[] | UserLikedSongUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLikedSongCreateOrConnectWithoutUserInput | UserLikedSongCreateOrConnectWithoutUserInput[]
    upsert?: UserLikedSongUpsertWithWhereUniqueWithoutUserInput | UserLikedSongUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLikedSongCreateManyUserInputEnvelope
    set?: UserLikedSongWhereUniqueInput | UserLikedSongWhereUniqueInput[]
    disconnect?: UserLikedSongWhereUniqueInput | UserLikedSongWhereUniqueInput[]
    delete?: UserLikedSongWhereUniqueInput | UserLikedSongWhereUniqueInput[]
    connect?: UserLikedSongWhereUniqueInput | UserLikedSongWhereUniqueInput[]
    update?: UserLikedSongUpdateWithWhereUniqueWithoutUserInput | UserLikedSongUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLikedSongUpdateManyWithWhereWithoutUserInput | UserLikedSongUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLikedSongScalarWhereInput | UserLikedSongScalarWhereInput[]
  }

  export type UserLikedAlbumUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLikedAlbumCreateWithoutUserInput, UserLikedAlbumUncheckedCreateWithoutUserInput> | UserLikedAlbumCreateWithoutUserInput[] | UserLikedAlbumUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLikedAlbumCreateOrConnectWithoutUserInput | UserLikedAlbumCreateOrConnectWithoutUserInput[]
    upsert?: UserLikedAlbumUpsertWithWhereUniqueWithoutUserInput | UserLikedAlbumUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLikedAlbumCreateManyUserInputEnvelope
    set?: UserLikedAlbumWhereUniqueInput | UserLikedAlbumWhereUniqueInput[]
    disconnect?: UserLikedAlbumWhereUniqueInput | UserLikedAlbumWhereUniqueInput[]
    delete?: UserLikedAlbumWhereUniqueInput | UserLikedAlbumWhereUniqueInput[]
    connect?: UserLikedAlbumWhereUniqueInput | UserLikedAlbumWhereUniqueInput[]
    update?: UserLikedAlbumUpdateWithWhereUniqueWithoutUserInput | UserLikedAlbumUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLikedAlbumUpdateManyWithWhereWithoutUserInput | UserLikedAlbumUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLikedAlbumScalarWhereInput | UserLikedAlbumScalarWhereInput[]
  }

  export type UserLikedPlaylistUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLikedPlaylistCreateWithoutUserInput, UserLikedPlaylistUncheckedCreateWithoutUserInput> | UserLikedPlaylistCreateWithoutUserInput[] | UserLikedPlaylistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLikedPlaylistCreateOrConnectWithoutUserInput | UserLikedPlaylistCreateOrConnectWithoutUserInput[]
    upsert?: UserLikedPlaylistUpsertWithWhereUniqueWithoutUserInput | UserLikedPlaylistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLikedPlaylistCreateManyUserInputEnvelope
    set?: UserLikedPlaylistWhereUniqueInput | UserLikedPlaylistWhereUniqueInput[]
    disconnect?: UserLikedPlaylistWhereUniqueInput | UserLikedPlaylistWhereUniqueInput[]
    delete?: UserLikedPlaylistWhereUniqueInput | UserLikedPlaylistWhereUniqueInput[]
    connect?: UserLikedPlaylistWhereUniqueInput | UserLikedPlaylistWhereUniqueInput[]
    update?: UserLikedPlaylistUpdateWithWhereUniqueWithoutUserInput | UserLikedPlaylistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLikedPlaylistUpdateManyWithWhereWithoutUserInput | UserLikedPlaylistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLikedPlaylistScalarWhereInput | UserLikedPlaylistScalarWhereInput[]
  }

  export type UserLikedArtistUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLikedArtistCreateWithoutUserInput, UserLikedArtistUncheckedCreateWithoutUserInput> | UserLikedArtistCreateWithoutUserInput[] | UserLikedArtistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLikedArtistCreateOrConnectWithoutUserInput | UserLikedArtistCreateOrConnectWithoutUserInput[]
    upsert?: UserLikedArtistUpsertWithWhereUniqueWithoutUserInput | UserLikedArtistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLikedArtistCreateManyUserInputEnvelope
    set?: UserLikedArtistWhereUniqueInput | UserLikedArtistWhereUniqueInput[]
    disconnect?: UserLikedArtistWhereUniqueInput | UserLikedArtistWhereUniqueInput[]
    delete?: UserLikedArtistWhereUniqueInput | UserLikedArtistWhereUniqueInput[]
    connect?: UserLikedArtistWhereUniqueInput | UserLikedArtistWhereUniqueInput[]
    update?: UserLikedArtistUpdateWithWhereUniqueWithoutUserInput | UserLikedArtistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLikedArtistUpdateManyWithWhereWithoutUserInput | UserLikedArtistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLikedArtistScalarWhereInput | UserLikedArtistScalarWhereInput[]
  }

  export type PlayHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlayHistoryCreateWithoutUserInput, PlayHistoryUncheckedCreateWithoutUserInput> | PlayHistoryCreateWithoutUserInput[] | PlayHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayHistoryCreateOrConnectWithoutUserInput | PlayHistoryCreateOrConnectWithoutUserInput[]
    upsert?: PlayHistoryUpsertWithWhereUniqueWithoutUserInput | PlayHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlayHistoryCreateManyUserInputEnvelope
    set?: PlayHistoryWhereUniqueInput | PlayHistoryWhereUniqueInput[]
    disconnect?: PlayHistoryWhereUniqueInput | PlayHistoryWhereUniqueInput[]
    delete?: PlayHistoryWhereUniqueInput | PlayHistoryWhereUniqueInput[]
    connect?: PlayHistoryWhereUniqueInput | PlayHistoryWhereUniqueInput[]
    update?: PlayHistoryUpdateWithWhereUniqueWithoutUserInput | PlayHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlayHistoryUpdateManyWithWhereWithoutUserInput | PlayHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlayHistoryScalarWhereInput | PlayHistoryScalarWhereInput[]
  }

  export type SearchHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput> | SearchHistoryCreateWithoutUserInput[] | SearchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutUserInput | SearchHistoryCreateOrConnectWithoutUserInput[]
    upsert?: SearchHistoryUpsertWithWhereUniqueWithoutUserInput | SearchHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SearchHistoryCreateManyUserInputEnvelope
    set?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    disconnect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    delete?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    update?: SearchHistoryUpdateWithWhereUniqueWithoutUserInput | SearchHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SearchHistoryUpdateManyWithWhereWithoutUserInput | SearchHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
  }

  export type UserFollowUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<UserFollowCreateWithoutFollowerInput, UserFollowUncheckedCreateWithoutFollowerInput> | UserFollowCreateWithoutFollowerInput[] | UserFollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutFollowerInput | UserFollowCreateOrConnectWithoutFollowerInput[]
    upsert?: UserFollowUpsertWithWhereUniqueWithoutFollowerInput | UserFollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: UserFollowCreateManyFollowerInputEnvelope
    set?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    disconnect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    delete?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    update?: UserFollowUpdateWithWhereUniqueWithoutFollowerInput | UserFollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: UserFollowUpdateManyWithWhereWithoutFollowerInput | UserFollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: UserFollowScalarWhereInput | UserFollowScalarWhereInput[]
  }

  export type UserFollowUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<UserFollowCreateWithoutFollowingInput, UserFollowUncheckedCreateWithoutFollowingInput> | UserFollowCreateWithoutFollowingInput[] | UserFollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutFollowingInput | UserFollowCreateOrConnectWithoutFollowingInput[]
    upsert?: UserFollowUpsertWithWhereUniqueWithoutFollowingInput | UserFollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: UserFollowCreateManyFollowingInputEnvelope
    set?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    disconnect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    delete?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    update?: UserFollowUpdateWithWhereUniqueWithoutFollowingInput | UserFollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: UserFollowUpdateManyWithWhereWithoutFollowingInput | UserFollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: UserFollowScalarWhereInput | UserFollowScalarWhereInput[]
  }

  export type UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput
    upsert?: UserSubscriptionUpsertWithoutUserInput
    disconnect?: UserSubscriptionWhereInput | boolean
    delete?: UserSubscriptionWhereInput | boolean
    connect?: UserSubscriptionWhereUniqueInput
    update?: XOR<XOR<UserSubscriptionUpdateToOneWithWhereWithoutUserInput, UserSubscriptionUpdateWithoutUserInput>, UserSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type PlaylistUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlaylistCreateWithoutUserInput, PlaylistUncheckedCreateWithoutUserInput> | PlaylistCreateWithoutUserInput[] | PlaylistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaylistCreateOrConnectWithoutUserInput | PlaylistCreateOrConnectWithoutUserInput[]
    upsert?: PlaylistUpsertWithWhereUniqueWithoutUserInput | PlaylistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlaylistCreateManyUserInputEnvelope
    set?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    disconnect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    delete?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    update?: PlaylistUpdateWithWhereUniqueWithoutUserInput | PlaylistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlaylistUpdateManyWithWhereWithoutUserInput | PlaylistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlaylistScalarWhereInput | PlaylistScalarWhereInput[]
  }

  export type UserLikedSongUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLikedSongCreateWithoutUserInput, UserLikedSongUncheckedCreateWithoutUserInput> | UserLikedSongCreateWithoutUserInput[] | UserLikedSongUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLikedSongCreateOrConnectWithoutUserInput | UserLikedSongCreateOrConnectWithoutUserInput[]
    upsert?: UserLikedSongUpsertWithWhereUniqueWithoutUserInput | UserLikedSongUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLikedSongCreateManyUserInputEnvelope
    set?: UserLikedSongWhereUniqueInput | UserLikedSongWhereUniqueInput[]
    disconnect?: UserLikedSongWhereUniqueInput | UserLikedSongWhereUniqueInput[]
    delete?: UserLikedSongWhereUniqueInput | UserLikedSongWhereUniqueInput[]
    connect?: UserLikedSongWhereUniqueInput | UserLikedSongWhereUniqueInput[]
    update?: UserLikedSongUpdateWithWhereUniqueWithoutUserInput | UserLikedSongUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLikedSongUpdateManyWithWhereWithoutUserInput | UserLikedSongUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLikedSongScalarWhereInput | UserLikedSongScalarWhereInput[]
  }

  export type UserLikedAlbumUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLikedAlbumCreateWithoutUserInput, UserLikedAlbumUncheckedCreateWithoutUserInput> | UserLikedAlbumCreateWithoutUserInput[] | UserLikedAlbumUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLikedAlbumCreateOrConnectWithoutUserInput | UserLikedAlbumCreateOrConnectWithoutUserInput[]
    upsert?: UserLikedAlbumUpsertWithWhereUniqueWithoutUserInput | UserLikedAlbumUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLikedAlbumCreateManyUserInputEnvelope
    set?: UserLikedAlbumWhereUniqueInput | UserLikedAlbumWhereUniqueInput[]
    disconnect?: UserLikedAlbumWhereUniqueInput | UserLikedAlbumWhereUniqueInput[]
    delete?: UserLikedAlbumWhereUniqueInput | UserLikedAlbumWhereUniqueInput[]
    connect?: UserLikedAlbumWhereUniqueInput | UserLikedAlbumWhereUniqueInput[]
    update?: UserLikedAlbumUpdateWithWhereUniqueWithoutUserInput | UserLikedAlbumUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLikedAlbumUpdateManyWithWhereWithoutUserInput | UserLikedAlbumUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLikedAlbumScalarWhereInput | UserLikedAlbumScalarWhereInput[]
  }

  export type UserLikedPlaylistUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLikedPlaylistCreateWithoutUserInput, UserLikedPlaylistUncheckedCreateWithoutUserInput> | UserLikedPlaylistCreateWithoutUserInput[] | UserLikedPlaylistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLikedPlaylistCreateOrConnectWithoutUserInput | UserLikedPlaylistCreateOrConnectWithoutUserInput[]
    upsert?: UserLikedPlaylistUpsertWithWhereUniqueWithoutUserInput | UserLikedPlaylistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLikedPlaylistCreateManyUserInputEnvelope
    set?: UserLikedPlaylistWhereUniqueInput | UserLikedPlaylistWhereUniqueInput[]
    disconnect?: UserLikedPlaylistWhereUniqueInput | UserLikedPlaylistWhereUniqueInput[]
    delete?: UserLikedPlaylistWhereUniqueInput | UserLikedPlaylistWhereUniqueInput[]
    connect?: UserLikedPlaylistWhereUniqueInput | UserLikedPlaylistWhereUniqueInput[]
    update?: UserLikedPlaylistUpdateWithWhereUniqueWithoutUserInput | UserLikedPlaylistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLikedPlaylistUpdateManyWithWhereWithoutUserInput | UserLikedPlaylistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLikedPlaylistScalarWhereInput | UserLikedPlaylistScalarWhereInput[]
  }

  export type UserLikedArtistUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLikedArtistCreateWithoutUserInput, UserLikedArtistUncheckedCreateWithoutUserInput> | UserLikedArtistCreateWithoutUserInput[] | UserLikedArtistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLikedArtistCreateOrConnectWithoutUserInput | UserLikedArtistCreateOrConnectWithoutUserInput[]
    upsert?: UserLikedArtistUpsertWithWhereUniqueWithoutUserInput | UserLikedArtistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLikedArtistCreateManyUserInputEnvelope
    set?: UserLikedArtistWhereUniqueInput | UserLikedArtistWhereUniqueInput[]
    disconnect?: UserLikedArtistWhereUniqueInput | UserLikedArtistWhereUniqueInput[]
    delete?: UserLikedArtistWhereUniqueInput | UserLikedArtistWhereUniqueInput[]
    connect?: UserLikedArtistWhereUniqueInput | UserLikedArtistWhereUniqueInput[]
    update?: UserLikedArtistUpdateWithWhereUniqueWithoutUserInput | UserLikedArtistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLikedArtistUpdateManyWithWhereWithoutUserInput | UserLikedArtistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLikedArtistScalarWhereInput | UserLikedArtistScalarWhereInput[]
  }

  export type PlayHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlayHistoryCreateWithoutUserInput, PlayHistoryUncheckedCreateWithoutUserInput> | PlayHistoryCreateWithoutUserInput[] | PlayHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayHistoryCreateOrConnectWithoutUserInput | PlayHistoryCreateOrConnectWithoutUserInput[]
    upsert?: PlayHistoryUpsertWithWhereUniqueWithoutUserInput | PlayHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlayHistoryCreateManyUserInputEnvelope
    set?: PlayHistoryWhereUniqueInput | PlayHistoryWhereUniqueInput[]
    disconnect?: PlayHistoryWhereUniqueInput | PlayHistoryWhereUniqueInput[]
    delete?: PlayHistoryWhereUniqueInput | PlayHistoryWhereUniqueInput[]
    connect?: PlayHistoryWhereUniqueInput | PlayHistoryWhereUniqueInput[]
    update?: PlayHistoryUpdateWithWhereUniqueWithoutUserInput | PlayHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlayHistoryUpdateManyWithWhereWithoutUserInput | PlayHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlayHistoryScalarWhereInput | PlayHistoryScalarWhereInput[]
  }

  export type SearchHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput> | SearchHistoryCreateWithoutUserInput[] | SearchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutUserInput | SearchHistoryCreateOrConnectWithoutUserInput[]
    upsert?: SearchHistoryUpsertWithWhereUniqueWithoutUserInput | SearchHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SearchHistoryCreateManyUserInputEnvelope
    set?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    disconnect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    delete?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    update?: SearchHistoryUpdateWithWhereUniqueWithoutUserInput | SearchHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SearchHistoryUpdateManyWithWhereWithoutUserInput | SearchHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
  }

  export type UserFollowUncheckedUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<UserFollowCreateWithoutFollowerInput, UserFollowUncheckedCreateWithoutFollowerInput> | UserFollowCreateWithoutFollowerInput[] | UserFollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutFollowerInput | UserFollowCreateOrConnectWithoutFollowerInput[]
    upsert?: UserFollowUpsertWithWhereUniqueWithoutFollowerInput | UserFollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: UserFollowCreateManyFollowerInputEnvelope
    set?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    disconnect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    delete?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    update?: UserFollowUpdateWithWhereUniqueWithoutFollowerInput | UserFollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: UserFollowUpdateManyWithWhereWithoutFollowerInput | UserFollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: UserFollowScalarWhereInput | UserFollowScalarWhereInput[]
  }

  export type UserFollowUncheckedUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<UserFollowCreateWithoutFollowingInput, UserFollowUncheckedCreateWithoutFollowingInput> | UserFollowCreateWithoutFollowingInput[] | UserFollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutFollowingInput | UserFollowCreateOrConnectWithoutFollowingInput[]
    upsert?: UserFollowUpsertWithWhereUniqueWithoutFollowingInput | UserFollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: UserFollowCreateManyFollowingInputEnvelope
    set?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    disconnect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    delete?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    update?: UserFollowUpdateWithWhereUniqueWithoutFollowingInput | UserFollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: UserFollowUpdateManyWithWhereWithoutFollowingInput | UserFollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: UserFollowScalarWhereInput | UserFollowScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSubscriptionTypeFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionType
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    upsert?: UserUpsertWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionInput, UserUpdateWithoutSubscriptionInput>, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type AlbumCreateNestedManyWithoutArtistInput = {
    create?: XOR<AlbumCreateWithoutArtistInput, AlbumUncheckedCreateWithoutArtistInput> | AlbumCreateWithoutArtistInput[] | AlbumUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: AlbumCreateOrConnectWithoutArtistInput | AlbumCreateOrConnectWithoutArtistInput[]
    createMany?: AlbumCreateManyArtistInputEnvelope
    connect?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
  }

  export type SongArtistCreateNestedManyWithoutArtistInput = {
    create?: XOR<SongArtistCreateWithoutArtistInput, SongArtistUncheckedCreateWithoutArtistInput> | SongArtistCreateWithoutArtistInput[] | SongArtistUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: SongArtistCreateOrConnectWithoutArtistInput | SongArtistCreateOrConnectWithoutArtistInput[]
    createMany?: SongArtistCreateManyArtistInputEnvelope
    connect?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
  }

  export type ArtistGenreCreateNestedManyWithoutArtistInput = {
    create?: XOR<ArtistGenreCreateWithoutArtistInput, ArtistGenreUncheckedCreateWithoutArtistInput> | ArtistGenreCreateWithoutArtistInput[] | ArtistGenreUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: ArtistGenreCreateOrConnectWithoutArtistInput | ArtistGenreCreateOrConnectWithoutArtistInput[]
    createMany?: ArtistGenreCreateManyArtistInputEnvelope
    connect?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
  }

  export type UserLikedArtistCreateNestedManyWithoutArtistInput = {
    create?: XOR<UserLikedArtistCreateWithoutArtistInput, UserLikedArtistUncheckedCreateWithoutArtistInput> | UserLikedArtistCreateWithoutArtistInput[] | UserLikedArtistUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: UserLikedArtistCreateOrConnectWithoutArtistInput | UserLikedArtistCreateOrConnectWithoutArtistInput[]
    createMany?: UserLikedArtistCreateManyArtistInputEnvelope
    connect?: UserLikedArtistWhereUniqueInput | UserLikedArtistWhereUniqueInput[]
  }

  export type SongCreditCreateNestedManyWithoutArtistInput = {
    create?: XOR<SongCreditCreateWithoutArtistInput, SongCreditUncheckedCreateWithoutArtistInput> | SongCreditCreateWithoutArtistInput[] | SongCreditUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: SongCreditCreateOrConnectWithoutArtistInput | SongCreditCreateOrConnectWithoutArtistInput[]
    createMany?: SongCreditCreateManyArtistInputEnvelope
    connect?: SongCreditWhereUniqueInput | SongCreditWhereUniqueInput[]
  }

  export type AlbumUncheckedCreateNestedManyWithoutArtistInput = {
    create?: XOR<AlbumCreateWithoutArtistInput, AlbumUncheckedCreateWithoutArtistInput> | AlbumCreateWithoutArtistInput[] | AlbumUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: AlbumCreateOrConnectWithoutArtistInput | AlbumCreateOrConnectWithoutArtistInput[]
    createMany?: AlbumCreateManyArtistInputEnvelope
    connect?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
  }

  export type SongArtistUncheckedCreateNestedManyWithoutArtistInput = {
    create?: XOR<SongArtistCreateWithoutArtistInput, SongArtistUncheckedCreateWithoutArtistInput> | SongArtistCreateWithoutArtistInput[] | SongArtistUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: SongArtistCreateOrConnectWithoutArtistInput | SongArtistCreateOrConnectWithoutArtistInput[]
    createMany?: SongArtistCreateManyArtistInputEnvelope
    connect?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
  }

  export type ArtistGenreUncheckedCreateNestedManyWithoutArtistInput = {
    create?: XOR<ArtistGenreCreateWithoutArtistInput, ArtistGenreUncheckedCreateWithoutArtistInput> | ArtistGenreCreateWithoutArtistInput[] | ArtistGenreUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: ArtistGenreCreateOrConnectWithoutArtistInput | ArtistGenreCreateOrConnectWithoutArtistInput[]
    createMany?: ArtistGenreCreateManyArtistInputEnvelope
    connect?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
  }

  export type UserLikedArtistUncheckedCreateNestedManyWithoutArtistInput = {
    create?: XOR<UserLikedArtistCreateWithoutArtistInput, UserLikedArtistUncheckedCreateWithoutArtistInput> | UserLikedArtistCreateWithoutArtistInput[] | UserLikedArtistUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: UserLikedArtistCreateOrConnectWithoutArtistInput | UserLikedArtistCreateOrConnectWithoutArtistInput[]
    createMany?: UserLikedArtistCreateManyArtistInputEnvelope
    connect?: UserLikedArtistWhereUniqueInput | UserLikedArtistWhereUniqueInput[]
  }

  export type SongCreditUncheckedCreateNestedManyWithoutArtistInput = {
    create?: XOR<SongCreditCreateWithoutArtistInput, SongCreditUncheckedCreateWithoutArtistInput> | SongCreditCreateWithoutArtistInput[] | SongCreditUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: SongCreditCreateOrConnectWithoutArtistInput | SongCreditCreateOrConnectWithoutArtistInput[]
    createMany?: SongCreditCreateManyArtistInputEnvelope
    connect?: SongCreditWhereUniqueInput | SongCreditWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AlbumUpdateManyWithoutArtistNestedInput = {
    create?: XOR<AlbumCreateWithoutArtistInput, AlbumUncheckedCreateWithoutArtistInput> | AlbumCreateWithoutArtistInput[] | AlbumUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: AlbumCreateOrConnectWithoutArtistInput | AlbumCreateOrConnectWithoutArtistInput[]
    upsert?: AlbumUpsertWithWhereUniqueWithoutArtistInput | AlbumUpsertWithWhereUniqueWithoutArtistInput[]
    createMany?: AlbumCreateManyArtistInputEnvelope
    set?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
    disconnect?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
    delete?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
    connect?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
    update?: AlbumUpdateWithWhereUniqueWithoutArtistInput | AlbumUpdateWithWhereUniqueWithoutArtistInput[]
    updateMany?: AlbumUpdateManyWithWhereWithoutArtistInput | AlbumUpdateManyWithWhereWithoutArtistInput[]
    deleteMany?: AlbumScalarWhereInput | AlbumScalarWhereInput[]
  }

  export type SongArtistUpdateManyWithoutArtistNestedInput = {
    create?: XOR<SongArtistCreateWithoutArtistInput, SongArtistUncheckedCreateWithoutArtistInput> | SongArtistCreateWithoutArtistInput[] | SongArtistUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: SongArtistCreateOrConnectWithoutArtistInput | SongArtistCreateOrConnectWithoutArtistInput[]
    upsert?: SongArtistUpsertWithWhereUniqueWithoutArtistInput | SongArtistUpsertWithWhereUniqueWithoutArtistInput[]
    createMany?: SongArtistCreateManyArtistInputEnvelope
    set?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    disconnect?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    delete?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    connect?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    update?: SongArtistUpdateWithWhereUniqueWithoutArtistInput | SongArtistUpdateWithWhereUniqueWithoutArtistInput[]
    updateMany?: SongArtistUpdateManyWithWhereWithoutArtistInput | SongArtistUpdateManyWithWhereWithoutArtistInput[]
    deleteMany?: SongArtistScalarWhereInput | SongArtistScalarWhereInput[]
  }

  export type ArtistGenreUpdateManyWithoutArtistNestedInput = {
    create?: XOR<ArtistGenreCreateWithoutArtistInput, ArtistGenreUncheckedCreateWithoutArtistInput> | ArtistGenreCreateWithoutArtistInput[] | ArtistGenreUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: ArtistGenreCreateOrConnectWithoutArtistInput | ArtistGenreCreateOrConnectWithoutArtistInput[]
    upsert?: ArtistGenreUpsertWithWhereUniqueWithoutArtistInput | ArtistGenreUpsertWithWhereUniqueWithoutArtistInput[]
    createMany?: ArtistGenreCreateManyArtistInputEnvelope
    set?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    disconnect?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    delete?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    connect?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    update?: ArtistGenreUpdateWithWhereUniqueWithoutArtistInput | ArtistGenreUpdateWithWhereUniqueWithoutArtistInput[]
    updateMany?: ArtistGenreUpdateManyWithWhereWithoutArtistInput | ArtistGenreUpdateManyWithWhereWithoutArtistInput[]
    deleteMany?: ArtistGenreScalarWhereInput | ArtistGenreScalarWhereInput[]
  }

  export type UserLikedArtistUpdateManyWithoutArtistNestedInput = {
    create?: XOR<UserLikedArtistCreateWithoutArtistInput, UserLikedArtistUncheckedCreateWithoutArtistInput> | UserLikedArtistCreateWithoutArtistInput[] | UserLikedArtistUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: UserLikedArtistCreateOrConnectWithoutArtistInput | UserLikedArtistCreateOrConnectWithoutArtistInput[]
    upsert?: UserLikedArtistUpsertWithWhereUniqueWithoutArtistInput | UserLikedArtistUpsertWithWhereUniqueWithoutArtistInput[]
    createMany?: UserLikedArtistCreateManyArtistInputEnvelope
    set?: UserLikedArtistWhereUniqueInput | UserLikedArtistWhereUniqueInput[]
    disconnect?: UserLikedArtistWhereUniqueInput | UserLikedArtistWhereUniqueInput[]
    delete?: UserLikedArtistWhereUniqueInput | UserLikedArtistWhereUniqueInput[]
    connect?: UserLikedArtistWhereUniqueInput | UserLikedArtistWhereUniqueInput[]
    update?: UserLikedArtistUpdateWithWhereUniqueWithoutArtistInput | UserLikedArtistUpdateWithWhereUniqueWithoutArtistInput[]
    updateMany?: UserLikedArtistUpdateManyWithWhereWithoutArtistInput | UserLikedArtistUpdateManyWithWhereWithoutArtistInput[]
    deleteMany?: UserLikedArtistScalarWhereInput | UserLikedArtistScalarWhereInput[]
  }

  export type SongCreditUpdateManyWithoutArtistNestedInput = {
    create?: XOR<SongCreditCreateWithoutArtistInput, SongCreditUncheckedCreateWithoutArtistInput> | SongCreditCreateWithoutArtistInput[] | SongCreditUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: SongCreditCreateOrConnectWithoutArtistInput | SongCreditCreateOrConnectWithoutArtistInput[]
    upsert?: SongCreditUpsertWithWhereUniqueWithoutArtistInput | SongCreditUpsertWithWhereUniqueWithoutArtistInput[]
    createMany?: SongCreditCreateManyArtistInputEnvelope
    set?: SongCreditWhereUniqueInput | SongCreditWhereUniqueInput[]
    disconnect?: SongCreditWhereUniqueInput | SongCreditWhereUniqueInput[]
    delete?: SongCreditWhereUniqueInput | SongCreditWhereUniqueInput[]
    connect?: SongCreditWhereUniqueInput | SongCreditWhereUniqueInput[]
    update?: SongCreditUpdateWithWhereUniqueWithoutArtistInput | SongCreditUpdateWithWhereUniqueWithoutArtistInput[]
    updateMany?: SongCreditUpdateManyWithWhereWithoutArtistInput | SongCreditUpdateManyWithWhereWithoutArtistInput[]
    deleteMany?: SongCreditScalarWhereInput | SongCreditScalarWhereInput[]
  }

  export type AlbumUncheckedUpdateManyWithoutArtistNestedInput = {
    create?: XOR<AlbumCreateWithoutArtistInput, AlbumUncheckedCreateWithoutArtistInput> | AlbumCreateWithoutArtistInput[] | AlbumUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: AlbumCreateOrConnectWithoutArtistInput | AlbumCreateOrConnectWithoutArtistInput[]
    upsert?: AlbumUpsertWithWhereUniqueWithoutArtistInput | AlbumUpsertWithWhereUniqueWithoutArtistInput[]
    createMany?: AlbumCreateManyArtistInputEnvelope
    set?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
    disconnect?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
    delete?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
    connect?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
    update?: AlbumUpdateWithWhereUniqueWithoutArtistInput | AlbumUpdateWithWhereUniqueWithoutArtistInput[]
    updateMany?: AlbumUpdateManyWithWhereWithoutArtistInput | AlbumUpdateManyWithWhereWithoutArtistInput[]
    deleteMany?: AlbumScalarWhereInput | AlbumScalarWhereInput[]
  }

  export type SongArtistUncheckedUpdateManyWithoutArtistNestedInput = {
    create?: XOR<SongArtistCreateWithoutArtistInput, SongArtistUncheckedCreateWithoutArtistInput> | SongArtistCreateWithoutArtistInput[] | SongArtistUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: SongArtistCreateOrConnectWithoutArtistInput | SongArtistCreateOrConnectWithoutArtistInput[]
    upsert?: SongArtistUpsertWithWhereUniqueWithoutArtistInput | SongArtistUpsertWithWhereUniqueWithoutArtistInput[]
    createMany?: SongArtistCreateManyArtistInputEnvelope
    set?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    disconnect?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    delete?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    connect?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    update?: SongArtistUpdateWithWhereUniqueWithoutArtistInput | SongArtistUpdateWithWhereUniqueWithoutArtistInput[]
    updateMany?: SongArtistUpdateManyWithWhereWithoutArtistInput | SongArtistUpdateManyWithWhereWithoutArtistInput[]
    deleteMany?: SongArtistScalarWhereInput | SongArtistScalarWhereInput[]
  }

  export type ArtistGenreUncheckedUpdateManyWithoutArtistNestedInput = {
    create?: XOR<ArtistGenreCreateWithoutArtistInput, ArtistGenreUncheckedCreateWithoutArtistInput> | ArtistGenreCreateWithoutArtistInput[] | ArtistGenreUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: ArtistGenreCreateOrConnectWithoutArtistInput | ArtistGenreCreateOrConnectWithoutArtistInput[]
    upsert?: ArtistGenreUpsertWithWhereUniqueWithoutArtistInput | ArtistGenreUpsertWithWhereUniqueWithoutArtistInput[]
    createMany?: ArtistGenreCreateManyArtistInputEnvelope
    set?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    disconnect?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    delete?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    connect?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    update?: ArtistGenreUpdateWithWhereUniqueWithoutArtistInput | ArtistGenreUpdateWithWhereUniqueWithoutArtistInput[]
    updateMany?: ArtistGenreUpdateManyWithWhereWithoutArtistInput | ArtistGenreUpdateManyWithWhereWithoutArtistInput[]
    deleteMany?: ArtistGenreScalarWhereInput | ArtistGenreScalarWhereInput[]
  }

  export type UserLikedArtistUncheckedUpdateManyWithoutArtistNestedInput = {
    create?: XOR<UserLikedArtistCreateWithoutArtistInput, UserLikedArtistUncheckedCreateWithoutArtistInput> | UserLikedArtistCreateWithoutArtistInput[] | UserLikedArtistUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: UserLikedArtistCreateOrConnectWithoutArtistInput | UserLikedArtistCreateOrConnectWithoutArtistInput[]
    upsert?: UserLikedArtistUpsertWithWhereUniqueWithoutArtistInput | UserLikedArtistUpsertWithWhereUniqueWithoutArtistInput[]
    createMany?: UserLikedArtistCreateManyArtistInputEnvelope
    set?: UserLikedArtistWhereUniqueInput | UserLikedArtistWhereUniqueInput[]
    disconnect?: UserLikedArtistWhereUniqueInput | UserLikedArtistWhereUniqueInput[]
    delete?: UserLikedArtistWhereUniqueInput | UserLikedArtistWhereUniqueInput[]
    connect?: UserLikedArtistWhereUniqueInput | UserLikedArtistWhereUniqueInput[]
    update?: UserLikedArtistUpdateWithWhereUniqueWithoutArtistInput | UserLikedArtistUpdateWithWhereUniqueWithoutArtistInput[]
    updateMany?: UserLikedArtistUpdateManyWithWhereWithoutArtistInput | UserLikedArtistUpdateManyWithWhereWithoutArtistInput[]
    deleteMany?: UserLikedArtistScalarWhereInput | UserLikedArtistScalarWhereInput[]
  }

  export type SongCreditUncheckedUpdateManyWithoutArtistNestedInput = {
    create?: XOR<SongCreditCreateWithoutArtistInput, SongCreditUncheckedCreateWithoutArtistInput> | SongCreditCreateWithoutArtistInput[] | SongCreditUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: SongCreditCreateOrConnectWithoutArtistInput | SongCreditCreateOrConnectWithoutArtistInput[]
    upsert?: SongCreditUpsertWithWhereUniqueWithoutArtistInput | SongCreditUpsertWithWhereUniqueWithoutArtistInput[]
    createMany?: SongCreditCreateManyArtistInputEnvelope
    set?: SongCreditWhereUniqueInput | SongCreditWhereUniqueInput[]
    disconnect?: SongCreditWhereUniqueInput | SongCreditWhereUniqueInput[]
    delete?: SongCreditWhereUniqueInput | SongCreditWhereUniqueInput[]
    connect?: SongCreditWhereUniqueInput | SongCreditWhereUniqueInput[]
    update?: SongCreditUpdateWithWhereUniqueWithoutArtistInput | SongCreditUpdateWithWhereUniqueWithoutArtistInput[]
    updateMany?: SongCreditUpdateManyWithWhereWithoutArtistInput | SongCreditUpdateManyWithWhereWithoutArtistInput[]
    deleteMany?: SongCreditScalarWhereInput | SongCreditScalarWhereInput[]
  }

  export type ArtistCreateNestedOneWithoutAlbumsInput = {
    create?: XOR<ArtistCreateWithoutAlbumsInput, ArtistUncheckedCreateWithoutAlbumsInput>
    connectOrCreate?: ArtistCreateOrConnectWithoutAlbumsInput
    connect?: ArtistWhereUniqueInput
  }

  export type SongCreateNestedManyWithoutAlbumInput = {
    create?: XOR<SongCreateWithoutAlbumInput, SongUncheckedCreateWithoutAlbumInput> | SongCreateWithoutAlbumInput[] | SongUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: SongCreateOrConnectWithoutAlbumInput | SongCreateOrConnectWithoutAlbumInput[]
    createMany?: SongCreateManyAlbumInputEnvelope
    connect?: SongWhereUniqueInput | SongWhereUniqueInput[]
  }

  export type AlbumGenreCreateNestedManyWithoutAlbumInput = {
    create?: XOR<AlbumGenreCreateWithoutAlbumInput, AlbumGenreUncheckedCreateWithoutAlbumInput> | AlbumGenreCreateWithoutAlbumInput[] | AlbumGenreUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: AlbumGenreCreateOrConnectWithoutAlbumInput | AlbumGenreCreateOrConnectWithoutAlbumInput[]
    createMany?: AlbumGenreCreateManyAlbumInputEnvelope
    connect?: AlbumGenreWhereUniqueInput | AlbumGenreWhereUniqueInput[]
  }

  export type UserLikedAlbumCreateNestedManyWithoutAlbumInput = {
    create?: XOR<UserLikedAlbumCreateWithoutAlbumInput, UserLikedAlbumUncheckedCreateWithoutAlbumInput> | UserLikedAlbumCreateWithoutAlbumInput[] | UserLikedAlbumUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: UserLikedAlbumCreateOrConnectWithoutAlbumInput | UserLikedAlbumCreateOrConnectWithoutAlbumInput[]
    createMany?: UserLikedAlbumCreateManyAlbumInputEnvelope
    connect?: UserLikedAlbumWhereUniqueInput | UserLikedAlbumWhereUniqueInput[]
  }

  export type SongUncheckedCreateNestedManyWithoutAlbumInput = {
    create?: XOR<SongCreateWithoutAlbumInput, SongUncheckedCreateWithoutAlbumInput> | SongCreateWithoutAlbumInput[] | SongUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: SongCreateOrConnectWithoutAlbumInput | SongCreateOrConnectWithoutAlbumInput[]
    createMany?: SongCreateManyAlbumInputEnvelope
    connect?: SongWhereUniqueInput | SongWhereUniqueInput[]
  }

  export type AlbumGenreUncheckedCreateNestedManyWithoutAlbumInput = {
    create?: XOR<AlbumGenreCreateWithoutAlbumInput, AlbumGenreUncheckedCreateWithoutAlbumInput> | AlbumGenreCreateWithoutAlbumInput[] | AlbumGenreUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: AlbumGenreCreateOrConnectWithoutAlbumInput | AlbumGenreCreateOrConnectWithoutAlbumInput[]
    createMany?: AlbumGenreCreateManyAlbumInputEnvelope
    connect?: AlbumGenreWhereUniqueInput | AlbumGenreWhereUniqueInput[]
  }

  export type UserLikedAlbumUncheckedCreateNestedManyWithoutAlbumInput = {
    create?: XOR<UserLikedAlbumCreateWithoutAlbumInput, UserLikedAlbumUncheckedCreateWithoutAlbumInput> | UserLikedAlbumCreateWithoutAlbumInput[] | UserLikedAlbumUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: UserLikedAlbumCreateOrConnectWithoutAlbumInput | UserLikedAlbumCreateOrConnectWithoutAlbumInput[]
    createMany?: UserLikedAlbumCreateManyAlbumInputEnvelope
    connect?: UserLikedAlbumWhereUniqueInput | UserLikedAlbumWhereUniqueInput[]
  }

  export type EnumAlbumTypeFieldUpdateOperationsInput = {
    set?: $Enums.AlbumType
  }

  export type ArtistUpdateOneRequiredWithoutAlbumsNestedInput = {
    create?: XOR<ArtistCreateWithoutAlbumsInput, ArtistUncheckedCreateWithoutAlbumsInput>
    connectOrCreate?: ArtistCreateOrConnectWithoutAlbumsInput
    upsert?: ArtistUpsertWithoutAlbumsInput
    connect?: ArtistWhereUniqueInput
    update?: XOR<XOR<ArtistUpdateToOneWithWhereWithoutAlbumsInput, ArtistUpdateWithoutAlbumsInput>, ArtistUncheckedUpdateWithoutAlbumsInput>
  }

  export type SongUpdateManyWithoutAlbumNestedInput = {
    create?: XOR<SongCreateWithoutAlbumInput, SongUncheckedCreateWithoutAlbumInput> | SongCreateWithoutAlbumInput[] | SongUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: SongCreateOrConnectWithoutAlbumInput | SongCreateOrConnectWithoutAlbumInput[]
    upsert?: SongUpsertWithWhereUniqueWithoutAlbumInput | SongUpsertWithWhereUniqueWithoutAlbumInput[]
    createMany?: SongCreateManyAlbumInputEnvelope
    set?: SongWhereUniqueInput | SongWhereUniqueInput[]
    disconnect?: SongWhereUniqueInput | SongWhereUniqueInput[]
    delete?: SongWhereUniqueInput | SongWhereUniqueInput[]
    connect?: SongWhereUniqueInput | SongWhereUniqueInput[]
    update?: SongUpdateWithWhereUniqueWithoutAlbumInput | SongUpdateWithWhereUniqueWithoutAlbumInput[]
    updateMany?: SongUpdateManyWithWhereWithoutAlbumInput | SongUpdateManyWithWhereWithoutAlbumInput[]
    deleteMany?: SongScalarWhereInput | SongScalarWhereInput[]
  }

  export type AlbumGenreUpdateManyWithoutAlbumNestedInput = {
    create?: XOR<AlbumGenreCreateWithoutAlbumInput, AlbumGenreUncheckedCreateWithoutAlbumInput> | AlbumGenreCreateWithoutAlbumInput[] | AlbumGenreUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: AlbumGenreCreateOrConnectWithoutAlbumInput | AlbumGenreCreateOrConnectWithoutAlbumInput[]
    upsert?: AlbumGenreUpsertWithWhereUniqueWithoutAlbumInput | AlbumGenreUpsertWithWhereUniqueWithoutAlbumInput[]
    createMany?: AlbumGenreCreateManyAlbumInputEnvelope
    set?: AlbumGenreWhereUniqueInput | AlbumGenreWhereUniqueInput[]
    disconnect?: AlbumGenreWhereUniqueInput | AlbumGenreWhereUniqueInput[]
    delete?: AlbumGenreWhereUniqueInput | AlbumGenreWhereUniqueInput[]
    connect?: AlbumGenreWhereUniqueInput | AlbumGenreWhereUniqueInput[]
    update?: AlbumGenreUpdateWithWhereUniqueWithoutAlbumInput | AlbumGenreUpdateWithWhereUniqueWithoutAlbumInput[]
    updateMany?: AlbumGenreUpdateManyWithWhereWithoutAlbumInput | AlbumGenreUpdateManyWithWhereWithoutAlbumInput[]
    deleteMany?: AlbumGenreScalarWhereInput | AlbumGenreScalarWhereInput[]
  }

  export type UserLikedAlbumUpdateManyWithoutAlbumNestedInput = {
    create?: XOR<UserLikedAlbumCreateWithoutAlbumInput, UserLikedAlbumUncheckedCreateWithoutAlbumInput> | UserLikedAlbumCreateWithoutAlbumInput[] | UserLikedAlbumUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: UserLikedAlbumCreateOrConnectWithoutAlbumInput | UserLikedAlbumCreateOrConnectWithoutAlbumInput[]
    upsert?: UserLikedAlbumUpsertWithWhereUniqueWithoutAlbumInput | UserLikedAlbumUpsertWithWhereUniqueWithoutAlbumInput[]
    createMany?: UserLikedAlbumCreateManyAlbumInputEnvelope
    set?: UserLikedAlbumWhereUniqueInput | UserLikedAlbumWhereUniqueInput[]
    disconnect?: UserLikedAlbumWhereUniqueInput | UserLikedAlbumWhereUniqueInput[]
    delete?: UserLikedAlbumWhereUniqueInput | UserLikedAlbumWhereUniqueInput[]
    connect?: UserLikedAlbumWhereUniqueInput | UserLikedAlbumWhereUniqueInput[]
    update?: UserLikedAlbumUpdateWithWhereUniqueWithoutAlbumInput | UserLikedAlbumUpdateWithWhereUniqueWithoutAlbumInput[]
    updateMany?: UserLikedAlbumUpdateManyWithWhereWithoutAlbumInput | UserLikedAlbumUpdateManyWithWhereWithoutAlbumInput[]
    deleteMany?: UserLikedAlbumScalarWhereInput | UserLikedAlbumScalarWhereInput[]
  }

  export type SongUncheckedUpdateManyWithoutAlbumNestedInput = {
    create?: XOR<SongCreateWithoutAlbumInput, SongUncheckedCreateWithoutAlbumInput> | SongCreateWithoutAlbumInput[] | SongUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: SongCreateOrConnectWithoutAlbumInput | SongCreateOrConnectWithoutAlbumInput[]
    upsert?: SongUpsertWithWhereUniqueWithoutAlbumInput | SongUpsertWithWhereUniqueWithoutAlbumInput[]
    createMany?: SongCreateManyAlbumInputEnvelope
    set?: SongWhereUniqueInput | SongWhereUniqueInput[]
    disconnect?: SongWhereUniqueInput | SongWhereUniqueInput[]
    delete?: SongWhereUniqueInput | SongWhereUniqueInput[]
    connect?: SongWhereUniqueInput | SongWhereUniqueInput[]
    update?: SongUpdateWithWhereUniqueWithoutAlbumInput | SongUpdateWithWhereUniqueWithoutAlbumInput[]
    updateMany?: SongUpdateManyWithWhereWithoutAlbumInput | SongUpdateManyWithWhereWithoutAlbumInput[]
    deleteMany?: SongScalarWhereInput | SongScalarWhereInput[]
  }

  export type AlbumGenreUncheckedUpdateManyWithoutAlbumNestedInput = {
    create?: XOR<AlbumGenreCreateWithoutAlbumInput, AlbumGenreUncheckedCreateWithoutAlbumInput> | AlbumGenreCreateWithoutAlbumInput[] | AlbumGenreUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: AlbumGenreCreateOrConnectWithoutAlbumInput | AlbumGenreCreateOrConnectWithoutAlbumInput[]
    upsert?: AlbumGenreUpsertWithWhereUniqueWithoutAlbumInput | AlbumGenreUpsertWithWhereUniqueWithoutAlbumInput[]
    createMany?: AlbumGenreCreateManyAlbumInputEnvelope
    set?: AlbumGenreWhereUniqueInput | AlbumGenreWhereUniqueInput[]
    disconnect?: AlbumGenreWhereUniqueInput | AlbumGenreWhereUniqueInput[]
    delete?: AlbumGenreWhereUniqueInput | AlbumGenreWhereUniqueInput[]
    connect?: AlbumGenreWhereUniqueInput | AlbumGenreWhereUniqueInput[]
    update?: AlbumGenreUpdateWithWhereUniqueWithoutAlbumInput | AlbumGenreUpdateWithWhereUniqueWithoutAlbumInput[]
    updateMany?: AlbumGenreUpdateManyWithWhereWithoutAlbumInput | AlbumGenreUpdateManyWithWhereWithoutAlbumInput[]
    deleteMany?: AlbumGenreScalarWhereInput | AlbumGenreScalarWhereInput[]
  }

  export type UserLikedAlbumUncheckedUpdateManyWithoutAlbumNestedInput = {
    create?: XOR<UserLikedAlbumCreateWithoutAlbumInput, UserLikedAlbumUncheckedCreateWithoutAlbumInput> | UserLikedAlbumCreateWithoutAlbumInput[] | UserLikedAlbumUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: UserLikedAlbumCreateOrConnectWithoutAlbumInput | UserLikedAlbumCreateOrConnectWithoutAlbumInput[]
    upsert?: UserLikedAlbumUpsertWithWhereUniqueWithoutAlbumInput | UserLikedAlbumUpsertWithWhereUniqueWithoutAlbumInput[]
    createMany?: UserLikedAlbumCreateManyAlbumInputEnvelope
    set?: UserLikedAlbumWhereUniqueInput | UserLikedAlbumWhereUniqueInput[]
    disconnect?: UserLikedAlbumWhereUniqueInput | UserLikedAlbumWhereUniqueInput[]
    delete?: UserLikedAlbumWhereUniqueInput | UserLikedAlbumWhereUniqueInput[]
    connect?: UserLikedAlbumWhereUniqueInput | UserLikedAlbumWhereUniqueInput[]
    update?: UserLikedAlbumUpdateWithWhereUniqueWithoutAlbumInput | UserLikedAlbumUpdateWithWhereUniqueWithoutAlbumInput[]
    updateMany?: UserLikedAlbumUpdateManyWithWhereWithoutAlbumInput | UserLikedAlbumUpdateManyWithWhereWithoutAlbumInput[]
    deleteMany?: UserLikedAlbumScalarWhereInput | UserLikedAlbumScalarWhereInput[]
  }

  export type AlbumCreateNestedOneWithoutSongsInput = {
    create?: XOR<AlbumCreateWithoutSongsInput, AlbumUncheckedCreateWithoutSongsInput>
    connectOrCreate?: AlbumCreateOrConnectWithoutSongsInput
    connect?: AlbumWhereUniqueInput
  }

  export type SongArtistCreateNestedManyWithoutSongInput = {
    create?: XOR<SongArtistCreateWithoutSongInput, SongArtistUncheckedCreateWithoutSongInput> | SongArtistCreateWithoutSongInput[] | SongArtistUncheckedCreateWithoutSongInput[]
    connectOrCreate?: SongArtistCreateOrConnectWithoutSongInput | SongArtistCreateOrConnectWithoutSongInput[]
    createMany?: SongArtistCreateManySongInputEnvelope
    connect?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
  }

  export type SongCreditCreateNestedManyWithoutSongInput = {
    create?: XOR<SongCreditCreateWithoutSongInput, SongCreditUncheckedCreateWithoutSongInput> | SongCreditCreateWithoutSongInput[] | SongCreditUncheckedCreateWithoutSongInput[]
    connectOrCreate?: SongCreditCreateOrConnectWithoutSongInput | SongCreditCreateOrConnectWithoutSongInput[]
    createMany?: SongCreditCreateManySongInputEnvelope
    connect?: SongCreditWhereUniqueInput | SongCreditWhereUniqueInput[]
  }

  export type SongGenreCreateNestedManyWithoutSongInput = {
    create?: XOR<SongGenreCreateWithoutSongInput, SongGenreUncheckedCreateWithoutSongInput> | SongGenreCreateWithoutSongInput[] | SongGenreUncheckedCreateWithoutSongInput[]
    connectOrCreate?: SongGenreCreateOrConnectWithoutSongInput | SongGenreCreateOrConnectWithoutSongInput[]
    createMany?: SongGenreCreateManySongInputEnvelope
    connect?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
  }

  export type UserLikedSongCreateNestedManyWithoutSongInput = {
    create?: XOR<UserLikedSongCreateWithoutSongInput, UserLikedSongUncheckedCreateWithoutSongInput> | UserLikedSongCreateWithoutSongInput[] | UserLikedSongUncheckedCreateWithoutSongInput[]
    connectOrCreate?: UserLikedSongCreateOrConnectWithoutSongInput | UserLikedSongCreateOrConnectWithoutSongInput[]
    createMany?: UserLikedSongCreateManySongInputEnvelope
    connect?: UserLikedSongWhereUniqueInput | UserLikedSongWhereUniqueInput[]
  }

  export type PlaylistItemCreateNestedManyWithoutSongInput = {
    create?: XOR<PlaylistItemCreateWithoutSongInput, PlaylistItemUncheckedCreateWithoutSongInput> | PlaylistItemCreateWithoutSongInput[] | PlaylistItemUncheckedCreateWithoutSongInput[]
    connectOrCreate?: PlaylistItemCreateOrConnectWithoutSongInput | PlaylistItemCreateOrConnectWithoutSongInput[]
    createMany?: PlaylistItemCreateManySongInputEnvelope
    connect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[]
  }

  export type PlayHistoryCreateNestedManyWithoutSongInput = {
    create?: XOR<PlayHistoryCreateWithoutSongInput, PlayHistoryUncheckedCreateWithoutSongInput> | PlayHistoryCreateWithoutSongInput[] | PlayHistoryUncheckedCreateWithoutSongInput[]
    connectOrCreate?: PlayHistoryCreateOrConnectWithoutSongInput | PlayHistoryCreateOrConnectWithoutSongInput[]
    createMany?: PlayHistoryCreateManySongInputEnvelope
    connect?: PlayHistoryWhereUniqueInput | PlayHistoryWhereUniqueInput[]
  }

  export type SongArtistUncheckedCreateNestedManyWithoutSongInput = {
    create?: XOR<SongArtistCreateWithoutSongInput, SongArtistUncheckedCreateWithoutSongInput> | SongArtistCreateWithoutSongInput[] | SongArtistUncheckedCreateWithoutSongInput[]
    connectOrCreate?: SongArtistCreateOrConnectWithoutSongInput | SongArtistCreateOrConnectWithoutSongInput[]
    createMany?: SongArtistCreateManySongInputEnvelope
    connect?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
  }

  export type SongCreditUncheckedCreateNestedManyWithoutSongInput = {
    create?: XOR<SongCreditCreateWithoutSongInput, SongCreditUncheckedCreateWithoutSongInput> | SongCreditCreateWithoutSongInput[] | SongCreditUncheckedCreateWithoutSongInput[]
    connectOrCreate?: SongCreditCreateOrConnectWithoutSongInput | SongCreditCreateOrConnectWithoutSongInput[]
    createMany?: SongCreditCreateManySongInputEnvelope
    connect?: SongCreditWhereUniqueInput | SongCreditWhereUniqueInput[]
  }

  export type SongGenreUncheckedCreateNestedManyWithoutSongInput = {
    create?: XOR<SongGenreCreateWithoutSongInput, SongGenreUncheckedCreateWithoutSongInput> | SongGenreCreateWithoutSongInput[] | SongGenreUncheckedCreateWithoutSongInput[]
    connectOrCreate?: SongGenreCreateOrConnectWithoutSongInput | SongGenreCreateOrConnectWithoutSongInput[]
    createMany?: SongGenreCreateManySongInputEnvelope
    connect?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
  }

  export type UserLikedSongUncheckedCreateNestedManyWithoutSongInput = {
    create?: XOR<UserLikedSongCreateWithoutSongInput, UserLikedSongUncheckedCreateWithoutSongInput> | UserLikedSongCreateWithoutSongInput[] | UserLikedSongUncheckedCreateWithoutSongInput[]
    connectOrCreate?: UserLikedSongCreateOrConnectWithoutSongInput | UserLikedSongCreateOrConnectWithoutSongInput[]
    createMany?: UserLikedSongCreateManySongInputEnvelope
    connect?: UserLikedSongWhereUniqueInput | UserLikedSongWhereUniqueInput[]
  }

  export type PlaylistItemUncheckedCreateNestedManyWithoutSongInput = {
    create?: XOR<PlaylistItemCreateWithoutSongInput, PlaylistItemUncheckedCreateWithoutSongInput> | PlaylistItemCreateWithoutSongInput[] | PlaylistItemUncheckedCreateWithoutSongInput[]
    connectOrCreate?: PlaylistItemCreateOrConnectWithoutSongInput | PlaylistItemCreateOrConnectWithoutSongInput[]
    createMany?: PlaylistItemCreateManySongInputEnvelope
    connect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[]
  }

  export type PlayHistoryUncheckedCreateNestedManyWithoutSongInput = {
    create?: XOR<PlayHistoryCreateWithoutSongInput, PlayHistoryUncheckedCreateWithoutSongInput> | PlayHistoryCreateWithoutSongInput[] | PlayHistoryUncheckedCreateWithoutSongInput[]
    connectOrCreate?: PlayHistoryCreateOrConnectWithoutSongInput | PlayHistoryCreateOrConnectWithoutSongInput[]
    createMany?: PlayHistoryCreateManySongInputEnvelope
    connect?: PlayHistoryWhereUniqueInput | PlayHistoryWhereUniqueInput[]
  }

  export type AlbumUpdateOneRequiredWithoutSongsNestedInput = {
    create?: XOR<AlbumCreateWithoutSongsInput, AlbumUncheckedCreateWithoutSongsInput>
    connectOrCreate?: AlbumCreateOrConnectWithoutSongsInput
    upsert?: AlbumUpsertWithoutSongsInput
    connect?: AlbumWhereUniqueInput
    update?: XOR<XOR<AlbumUpdateToOneWithWhereWithoutSongsInput, AlbumUpdateWithoutSongsInput>, AlbumUncheckedUpdateWithoutSongsInput>
  }

  export type SongArtistUpdateManyWithoutSongNestedInput = {
    create?: XOR<SongArtistCreateWithoutSongInput, SongArtistUncheckedCreateWithoutSongInput> | SongArtistCreateWithoutSongInput[] | SongArtistUncheckedCreateWithoutSongInput[]
    connectOrCreate?: SongArtistCreateOrConnectWithoutSongInput | SongArtistCreateOrConnectWithoutSongInput[]
    upsert?: SongArtistUpsertWithWhereUniqueWithoutSongInput | SongArtistUpsertWithWhereUniqueWithoutSongInput[]
    createMany?: SongArtistCreateManySongInputEnvelope
    set?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    disconnect?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    delete?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    connect?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    update?: SongArtistUpdateWithWhereUniqueWithoutSongInput | SongArtistUpdateWithWhereUniqueWithoutSongInput[]
    updateMany?: SongArtistUpdateManyWithWhereWithoutSongInput | SongArtistUpdateManyWithWhereWithoutSongInput[]
    deleteMany?: SongArtistScalarWhereInput | SongArtistScalarWhereInput[]
  }

  export type SongCreditUpdateManyWithoutSongNestedInput = {
    create?: XOR<SongCreditCreateWithoutSongInput, SongCreditUncheckedCreateWithoutSongInput> | SongCreditCreateWithoutSongInput[] | SongCreditUncheckedCreateWithoutSongInput[]
    connectOrCreate?: SongCreditCreateOrConnectWithoutSongInput | SongCreditCreateOrConnectWithoutSongInput[]
    upsert?: SongCreditUpsertWithWhereUniqueWithoutSongInput | SongCreditUpsertWithWhereUniqueWithoutSongInput[]
    createMany?: SongCreditCreateManySongInputEnvelope
    set?: SongCreditWhereUniqueInput | SongCreditWhereUniqueInput[]
    disconnect?: SongCreditWhereUniqueInput | SongCreditWhereUniqueInput[]
    delete?: SongCreditWhereUniqueInput | SongCreditWhereUniqueInput[]
    connect?: SongCreditWhereUniqueInput | SongCreditWhereUniqueInput[]
    update?: SongCreditUpdateWithWhereUniqueWithoutSongInput | SongCreditUpdateWithWhereUniqueWithoutSongInput[]
    updateMany?: SongCreditUpdateManyWithWhereWithoutSongInput | SongCreditUpdateManyWithWhereWithoutSongInput[]
    deleteMany?: SongCreditScalarWhereInput | SongCreditScalarWhereInput[]
  }

  export type SongGenreUpdateManyWithoutSongNestedInput = {
    create?: XOR<SongGenreCreateWithoutSongInput, SongGenreUncheckedCreateWithoutSongInput> | SongGenreCreateWithoutSongInput[] | SongGenreUncheckedCreateWithoutSongInput[]
    connectOrCreate?: SongGenreCreateOrConnectWithoutSongInput | SongGenreCreateOrConnectWithoutSongInput[]
    upsert?: SongGenreUpsertWithWhereUniqueWithoutSongInput | SongGenreUpsertWithWhereUniqueWithoutSongInput[]
    createMany?: SongGenreCreateManySongInputEnvelope
    set?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    disconnect?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    delete?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    connect?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    update?: SongGenreUpdateWithWhereUniqueWithoutSongInput | SongGenreUpdateWithWhereUniqueWithoutSongInput[]
    updateMany?: SongGenreUpdateManyWithWhereWithoutSongInput | SongGenreUpdateManyWithWhereWithoutSongInput[]
    deleteMany?: SongGenreScalarWhereInput | SongGenreScalarWhereInput[]
  }

  export type UserLikedSongUpdateManyWithoutSongNestedInput = {
    create?: XOR<UserLikedSongCreateWithoutSongInput, UserLikedSongUncheckedCreateWithoutSongInput> | UserLikedSongCreateWithoutSongInput[] | UserLikedSongUncheckedCreateWithoutSongInput[]
    connectOrCreate?: UserLikedSongCreateOrConnectWithoutSongInput | UserLikedSongCreateOrConnectWithoutSongInput[]
    upsert?: UserLikedSongUpsertWithWhereUniqueWithoutSongInput | UserLikedSongUpsertWithWhereUniqueWithoutSongInput[]
    createMany?: UserLikedSongCreateManySongInputEnvelope
    set?: UserLikedSongWhereUniqueInput | UserLikedSongWhereUniqueInput[]
    disconnect?: UserLikedSongWhereUniqueInput | UserLikedSongWhereUniqueInput[]
    delete?: UserLikedSongWhereUniqueInput | UserLikedSongWhereUniqueInput[]
    connect?: UserLikedSongWhereUniqueInput | UserLikedSongWhereUniqueInput[]
    update?: UserLikedSongUpdateWithWhereUniqueWithoutSongInput | UserLikedSongUpdateWithWhereUniqueWithoutSongInput[]
    updateMany?: UserLikedSongUpdateManyWithWhereWithoutSongInput | UserLikedSongUpdateManyWithWhereWithoutSongInput[]
    deleteMany?: UserLikedSongScalarWhereInput | UserLikedSongScalarWhereInput[]
  }

  export type PlaylistItemUpdateManyWithoutSongNestedInput = {
    create?: XOR<PlaylistItemCreateWithoutSongInput, PlaylistItemUncheckedCreateWithoutSongInput> | PlaylistItemCreateWithoutSongInput[] | PlaylistItemUncheckedCreateWithoutSongInput[]
    connectOrCreate?: PlaylistItemCreateOrConnectWithoutSongInput | PlaylistItemCreateOrConnectWithoutSongInput[]
    upsert?: PlaylistItemUpsertWithWhereUniqueWithoutSongInput | PlaylistItemUpsertWithWhereUniqueWithoutSongInput[]
    createMany?: PlaylistItemCreateManySongInputEnvelope
    set?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[]
    disconnect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[]
    delete?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[]
    connect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[]
    update?: PlaylistItemUpdateWithWhereUniqueWithoutSongInput | PlaylistItemUpdateWithWhereUniqueWithoutSongInput[]
    updateMany?: PlaylistItemUpdateManyWithWhereWithoutSongInput | PlaylistItemUpdateManyWithWhereWithoutSongInput[]
    deleteMany?: PlaylistItemScalarWhereInput | PlaylistItemScalarWhereInput[]
  }

  export type PlayHistoryUpdateManyWithoutSongNestedInput = {
    create?: XOR<PlayHistoryCreateWithoutSongInput, PlayHistoryUncheckedCreateWithoutSongInput> | PlayHistoryCreateWithoutSongInput[] | PlayHistoryUncheckedCreateWithoutSongInput[]
    connectOrCreate?: PlayHistoryCreateOrConnectWithoutSongInput | PlayHistoryCreateOrConnectWithoutSongInput[]
    upsert?: PlayHistoryUpsertWithWhereUniqueWithoutSongInput | PlayHistoryUpsertWithWhereUniqueWithoutSongInput[]
    createMany?: PlayHistoryCreateManySongInputEnvelope
    set?: PlayHistoryWhereUniqueInput | PlayHistoryWhereUniqueInput[]
    disconnect?: PlayHistoryWhereUniqueInput | PlayHistoryWhereUniqueInput[]
    delete?: PlayHistoryWhereUniqueInput | PlayHistoryWhereUniqueInput[]
    connect?: PlayHistoryWhereUniqueInput | PlayHistoryWhereUniqueInput[]
    update?: PlayHistoryUpdateWithWhereUniqueWithoutSongInput | PlayHistoryUpdateWithWhereUniqueWithoutSongInput[]
    updateMany?: PlayHistoryUpdateManyWithWhereWithoutSongInput | PlayHistoryUpdateManyWithWhereWithoutSongInput[]
    deleteMany?: PlayHistoryScalarWhereInput | PlayHistoryScalarWhereInput[]
  }

  export type SongArtistUncheckedUpdateManyWithoutSongNestedInput = {
    create?: XOR<SongArtistCreateWithoutSongInput, SongArtistUncheckedCreateWithoutSongInput> | SongArtistCreateWithoutSongInput[] | SongArtistUncheckedCreateWithoutSongInput[]
    connectOrCreate?: SongArtistCreateOrConnectWithoutSongInput | SongArtistCreateOrConnectWithoutSongInput[]
    upsert?: SongArtistUpsertWithWhereUniqueWithoutSongInput | SongArtistUpsertWithWhereUniqueWithoutSongInput[]
    createMany?: SongArtistCreateManySongInputEnvelope
    set?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    disconnect?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    delete?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    connect?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    update?: SongArtistUpdateWithWhereUniqueWithoutSongInput | SongArtistUpdateWithWhereUniqueWithoutSongInput[]
    updateMany?: SongArtistUpdateManyWithWhereWithoutSongInput | SongArtistUpdateManyWithWhereWithoutSongInput[]
    deleteMany?: SongArtistScalarWhereInput | SongArtistScalarWhereInput[]
  }

  export type SongCreditUncheckedUpdateManyWithoutSongNestedInput = {
    create?: XOR<SongCreditCreateWithoutSongInput, SongCreditUncheckedCreateWithoutSongInput> | SongCreditCreateWithoutSongInput[] | SongCreditUncheckedCreateWithoutSongInput[]
    connectOrCreate?: SongCreditCreateOrConnectWithoutSongInput | SongCreditCreateOrConnectWithoutSongInput[]
    upsert?: SongCreditUpsertWithWhereUniqueWithoutSongInput | SongCreditUpsertWithWhereUniqueWithoutSongInput[]
    createMany?: SongCreditCreateManySongInputEnvelope
    set?: SongCreditWhereUniqueInput | SongCreditWhereUniqueInput[]
    disconnect?: SongCreditWhereUniqueInput | SongCreditWhereUniqueInput[]
    delete?: SongCreditWhereUniqueInput | SongCreditWhereUniqueInput[]
    connect?: SongCreditWhereUniqueInput | SongCreditWhereUniqueInput[]
    update?: SongCreditUpdateWithWhereUniqueWithoutSongInput | SongCreditUpdateWithWhereUniqueWithoutSongInput[]
    updateMany?: SongCreditUpdateManyWithWhereWithoutSongInput | SongCreditUpdateManyWithWhereWithoutSongInput[]
    deleteMany?: SongCreditScalarWhereInput | SongCreditScalarWhereInput[]
  }

  export type SongGenreUncheckedUpdateManyWithoutSongNestedInput = {
    create?: XOR<SongGenreCreateWithoutSongInput, SongGenreUncheckedCreateWithoutSongInput> | SongGenreCreateWithoutSongInput[] | SongGenreUncheckedCreateWithoutSongInput[]
    connectOrCreate?: SongGenreCreateOrConnectWithoutSongInput | SongGenreCreateOrConnectWithoutSongInput[]
    upsert?: SongGenreUpsertWithWhereUniqueWithoutSongInput | SongGenreUpsertWithWhereUniqueWithoutSongInput[]
    createMany?: SongGenreCreateManySongInputEnvelope
    set?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    disconnect?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    delete?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    connect?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    update?: SongGenreUpdateWithWhereUniqueWithoutSongInput | SongGenreUpdateWithWhereUniqueWithoutSongInput[]
    updateMany?: SongGenreUpdateManyWithWhereWithoutSongInput | SongGenreUpdateManyWithWhereWithoutSongInput[]
    deleteMany?: SongGenreScalarWhereInput | SongGenreScalarWhereInput[]
  }

  export type UserLikedSongUncheckedUpdateManyWithoutSongNestedInput = {
    create?: XOR<UserLikedSongCreateWithoutSongInput, UserLikedSongUncheckedCreateWithoutSongInput> | UserLikedSongCreateWithoutSongInput[] | UserLikedSongUncheckedCreateWithoutSongInput[]
    connectOrCreate?: UserLikedSongCreateOrConnectWithoutSongInput | UserLikedSongCreateOrConnectWithoutSongInput[]
    upsert?: UserLikedSongUpsertWithWhereUniqueWithoutSongInput | UserLikedSongUpsertWithWhereUniqueWithoutSongInput[]
    createMany?: UserLikedSongCreateManySongInputEnvelope
    set?: UserLikedSongWhereUniqueInput | UserLikedSongWhereUniqueInput[]
    disconnect?: UserLikedSongWhereUniqueInput | UserLikedSongWhereUniqueInput[]
    delete?: UserLikedSongWhereUniqueInput | UserLikedSongWhereUniqueInput[]
    connect?: UserLikedSongWhereUniqueInput | UserLikedSongWhereUniqueInput[]
    update?: UserLikedSongUpdateWithWhereUniqueWithoutSongInput | UserLikedSongUpdateWithWhereUniqueWithoutSongInput[]
    updateMany?: UserLikedSongUpdateManyWithWhereWithoutSongInput | UserLikedSongUpdateManyWithWhereWithoutSongInput[]
    deleteMany?: UserLikedSongScalarWhereInput | UserLikedSongScalarWhereInput[]
  }

  export type PlaylistItemUncheckedUpdateManyWithoutSongNestedInput = {
    create?: XOR<PlaylistItemCreateWithoutSongInput, PlaylistItemUncheckedCreateWithoutSongInput> | PlaylistItemCreateWithoutSongInput[] | PlaylistItemUncheckedCreateWithoutSongInput[]
    connectOrCreate?: PlaylistItemCreateOrConnectWithoutSongInput | PlaylistItemCreateOrConnectWithoutSongInput[]
    upsert?: PlaylistItemUpsertWithWhereUniqueWithoutSongInput | PlaylistItemUpsertWithWhereUniqueWithoutSongInput[]
    createMany?: PlaylistItemCreateManySongInputEnvelope
    set?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[]
    disconnect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[]
    delete?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[]
    connect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[]
    update?: PlaylistItemUpdateWithWhereUniqueWithoutSongInput | PlaylistItemUpdateWithWhereUniqueWithoutSongInput[]
    updateMany?: PlaylistItemUpdateManyWithWhereWithoutSongInput | PlaylistItemUpdateManyWithWhereWithoutSongInput[]
    deleteMany?: PlaylistItemScalarWhereInput | PlaylistItemScalarWhereInput[]
  }

  export type PlayHistoryUncheckedUpdateManyWithoutSongNestedInput = {
    create?: XOR<PlayHistoryCreateWithoutSongInput, PlayHistoryUncheckedCreateWithoutSongInput> | PlayHistoryCreateWithoutSongInput[] | PlayHistoryUncheckedCreateWithoutSongInput[]
    connectOrCreate?: PlayHistoryCreateOrConnectWithoutSongInput | PlayHistoryCreateOrConnectWithoutSongInput[]
    upsert?: PlayHistoryUpsertWithWhereUniqueWithoutSongInput | PlayHistoryUpsertWithWhereUniqueWithoutSongInput[]
    createMany?: PlayHistoryCreateManySongInputEnvelope
    set?: PlayHistoryWhereUniqueInput | PlayHistoryWhereUniqueInput[]
    disconnect?: PlayHistoryWhereUniqueInput | PlayHistoryWhereUniqueInput[]
    delete?: PlayHistoryWhereUniqueInput | PlayHistoryWhereUniqueInput[]
    connect?: PlayHistoryWhereUniqueInput | PlayHistoryWhereUniqueInput[]
    update?: PlayHistoryUpdateWithWhereUniqueWithoutSongInput | PlayHistoryUpdateWithWhereUniqueWithoutSongInput[]
    updateMany?: PlayHistoryUpdateManyWithWhereWithoutSongInput | PlayHistoryUpdateManyWithWhereWithoutSongInput[]
    deleteMany?: PlayHistoryScalarWhereInput | PlayHistoryScalarWhereInput[]
  }

  export type SongGenreCreateNestedManyWithoutGenreInput = {
    create?: XOR<SongGenreCreateWithoutGenreInput, SongGenreUncheckedCreateWithoutGenreInput> | SongGenreCreateWithoutGenreInput[] | SongGenreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: SongGenreCreateOrConnectWithoutGenreInput | SongGenreCreateOrConnectWithoutGenreInput[]
    createMany?: SongGenreCreateManyGenreInputEnvelope
    connect?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
  }

  export type AlbumGenreCreateNestedManyWithoutGenreInput = {
    create?: XOR<AlbumGenreCreateWithoutGenreInput, AlbumGenreUncheckedCreateWithoutGenreInput> | AlbumGenreCreateWithoutGenreInput[] | AlbumGenreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: AlbumGenreCreateOrConnectWithoutGenreInput | AlbumGenreCreateOrConnectWithoutGenreInput[]
    createMany?: AlbumGenreCreateManyGenreInputEnvelope
    connect?: AlbumGenreWhereUniqueInput | AlbumGenreWhereUniqueInput[]
  }

  export type ArtistGenreCreateNestedManyWithoutGenreInput = {
    create?: XOR<ArtistGenreCreateWithoutGenreInput, ArtistGenreUncheckedCreateWithoutGenreInput> | ArtistGenreCreateWithoutGenreInput[] | ArtistGenreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: ArtistGenreCreateOrConnectWithoutGenreInput | ArtistGenreCreateOrConnectWithoutGenreInput[]
    createMany?: ArtistGenreCreateManyGenreInputEnvelope
    connect?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
  }

  export type SongGenreUncheckedCreateNestedManyWithoutGenreInput = {
    create?: XOR<SongGenreCreateWithoutGenreInput, SongGenreUncheckedCreateWithoutGenreInput> | SongGenreCreateWithoutGenreInput[] | SongGenreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: SongGenreCreateOrConnectWithoutGenreInput | SongGenreCreateOrConnectWithoutGenreInput[]
    createMany?: SongGenreCreateManyGenreInputEnvelope
    connect?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
  }

  export type AlbumGenreUncheckedCreateNestedManyWithoutGenreInput = {
    create?: XOR<AlbumGenreCreateWithoutGenreInput, AlbumGenreUncheckedCreateWithoutGenreInput> | AlbumGenreCreateWithoutGenreInput[] | AlbumGenreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: AlbumGenreCreateOrConnectWithoutGenreInput | AlbumGenreCreateOrConnectWithoutGenreInput[]
    createMany?: AlbumGenreCreateManyGenreInputEnvelope
    connect?: AlbumGenreWhereUniqueInput | AlbumGenreWhereUniqueInput[]
  }

  export type ArtistGenreUncheckedCreateNestedManyWithoutGenreInput = {
    create?: XOR<ArtistGenreCreateWithoutGenreInput, ArtistGenreUncheckedCreateWithoutGenreInput> | ArtistGenreCreateWithoutGenreInput[] | ArtistGenreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: ArtistGenreCreateOrConnectWithoutGenreInput | ArtistGenreCreateOrConnectWithoutGenreInput[]
    createMany?: ArtistGenreCreateManyGenreInputEnvelope
    connect?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
  }

  export type SongGenreUpdateManyWithoutGenreNestedInput = {
    create?: XOR<SongGenreCreateWithoutGenreInput, SongGenreUncheckedCreateWithoutGenreInput> | SongGenreCreateWithoutGenreInput[] | SongGenreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: SongGenreCreateOrConnectWithoutGenreInput | SongGenreCreateOrConnectWithoutGenreInput[]
    upsert?: SongGenreUpsertWithWhereUniqueWithoutGenreInput | SongGenreUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: SongGenreCreateManyGenreInputEnvelope
    set?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    disconnect?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    delete?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    connect?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    update?: SongGenreUpdateWithWhereUniqueWithoutGenreInput | SongGenreUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: SongGenreUpdateManyWithWhereWithoutGenreInput | SongGenreUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: SongGenreScalarWhereInput | SongGenreScalarWhereInput[]
  }

  export type AlbumGenreUpdateManyWithoutGenreNestedInput = {
    create?: XOR<AlbumGenreCreateWithoutGenreInput, AlbumGenreUncheckedCreateWithoutGenreInput> | AlbumGenreCreateWithoutGenreInput[] | AlbumGenreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: AlbumGenreCreateOrConnectWithoutGenreInput | AlbumGenreCreateOrConnectWithoutGenreInput[]
    upsert?: AlbumGenreUpsertWithWhereUniqueWithoutGenreInput | AlbumGenreUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: AlbumGenreCreateManyGenreInputEnvelope
    set?: AlbumGenreWhereUniqueInput | AlbumGenreWhereUniqueInput[]
    disconnect?: AlbumGenreWhereUniqueInput | AlbumGenreWhereUniqueInput[]
    delete?: AlbumGenreWhereUniqueInput | AlbumGenreWhereUniqueInput[]
    connect?: AlbumGenreWhereUniqueInput | AlbumGenreWhereUniqueInput[]
    update?: AlbumGenreUpdateWithWhereUniqueWithoutGenreInput | AlbumGenreUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: AlbumGenreUpdateManyWithWhereWithoutGenreInput | AlbumGenreUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: AlbumGenreScalarWhereInput | AlbumGenreScalarWhereInput[]
  }

  export type ArtistGenreUpdateManyWithoutGenreNestedInput = {
    create?: XOR<ArtistGenreCreateWithoutGenreInput, ArtistGenreUncheckedCreateWithoutGenreInput> | ArtistGenreCreateWithoutGenreInput[] | ArtistGenreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: ArtistGenreCreateOrConnectWithoutGenreInput | ArtistGenreCreateOrConnectWithoutGenreInput[]
    upsert?: ArtistGenreUpsertWithWhereUniqueWithoutGenreInput | ArtistGenreUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: ArtistGenreCreateManyGenreInputEnvelope
    set?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    disconnect?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    delete?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    connect?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    update?: ArtistGenreUpdateWithWhereUniqueWithoutGenreInput | ArtistGenreUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: ArtistGenreUpdateManyWithWhereWithoutGenreInput | ArtistGenreUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: ArtistGenreScalarWhereInput | ArtistGenreScalarWhereInput[]
  }

  export type SongGenreUncheckedUpdateManyWithoutGenreNestedInput = {
    create?: XOR<SongGenreCreateWithoutGenreInput, SongGenreUncheckedCreateWithoutGenreInput> | SongGenreCreateWithoutGenreInput[] | SongGenreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: SongGenreCreateOrConnectWithoutGenreInput | SongGenreCreateOrConnectWithoutGenreInput[]
    upsert?: SongGenreUpsertWithWhereUniqueWithoutGenreInput | SongGenreUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: SongGenreCreateManyGenreInputEnvelope
    set?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    disconnect?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    delete?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    connect?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    update?: SongGenreUpdateWithWhereUniqueWithoutGenreInput | SongGenreUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: SongGenreUpdateManyWithWhereWithoutGenreInput | SongGenreUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: SongGenreScalarWhereInput | SongGenreScalarWhereInput[]
  }

  export type AlbumGenreUncheckedUpdateManyWithoutGenreNestedInput = {
    create?: XOR<AlbumGenreCreateWithoutGenreInput, AlbumGenreUncheckedCreateWithoutGenreInput> | AlbumGenreCreateWithoutGenreInput[] | AlbumGenreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: AlbumGenreCreateOrConnectWithoutGenreInput | AlbumGenreCreateOrConnectWithoutGenreInput[]
    upsert?: AlbumGenreUpsertWithWhereUniqueWithoutGenreInput | AlbumGenreUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: AlbumGenreCreateManyGenreInputEnvelope
    set?: AlbumGenreWhereUniqueInput | AlbumGenreWhereUniqueInput[]
    disconnect?: AlbumGenreWhereUniqueInput | AlbumGenreWhereUniqueInput[]
    delete?: AlbumGenreWhereUniqueInput | AlbumGenreWhereUniqueInput[]
    connect?: AlbumGenreWhereUniqueInput | AlbumGenreWhereUniqueInput[]
    update?: AlbumGenreUpdateWithWhereUniqueWithoutGenreInput | AlbumGenreUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: AlbumGenreUpdateManyWithWhereWithoutGenreInput | AlbumGenreUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: AlbumGenreScalarWhereInput | AlbumGenreScalarWhereInput[]
  }

  export type ArtistGenreUncheckedUpdateManyWithoutGenreNestedInput = {
    create?: XOR<ArtistGenreCreateWithoutGenreInput, ArtistGenreUncheckedCreateWithoutGenreInput> | ArtistGenreCreateWithoutGenreInput[] | ArtistGenreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: ArtistGenreCreateOrConnectWithoutGenreInput | ArtistGenreCreateOrConnectWithoutGenreInput[]
    upsert?: ArtistGenreUpsertWithWhereUniqueWithoutGenreInput | ArtistGenreUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: ArtistGenreCreateManyGenreInputEnvelope
    set?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    disconnect?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    delete?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    connect?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    update?: ArtistGenreUpdateWithWhereUniqueWithoutGenreInput | ArtistGenreUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: ArtistGenreUpdateManyWithWhereWithoutGenreInput | ArtistGenreUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: ArtistGenreScalarWhereInput | ArtistGenreScalarWhereInput[]
  }

  export type SongCreateNestedOneWithoutArtistsInput = {
    create?: XOR<SongCreateWithoutArtistsInput, SongUncheckedCreateWithoutArtistsInput>
    connectOrCreate?: SongCreateOrConnectWithoutArtistsInput
    connect?: SongWhereUniqueInput
  }

  export type ArtistCreateNestedOneWithoutSongsInput = {
    create?: XOR<ArtistCreateWithoutSongsInput, ArtistUncheckedCreateWithoutSongsInput>
    connectOrCreate?: ArtistCreateOrConnectWithoutSongsInput
    connect?: ArtistWhereUniqueInput
  }

  export type EnumArtistRoleFieldUpdateOperationsInput = {
    set?: $Enums.ArtistRole
  }

  export type SongUpdateOneRequiredWithoutArtistsNestedInput = {
    create?: XOR<SongCreateWithoutArtistsInput, SongUncheckedCreateWithoutArtistsInput>
    connectOrCreate?: SongCreateOrConnectWithoutArtistsInput
    upsert?: SongUpsertWithoutArtistsInput
    connect?: SongWhereUniqueInput
    update?: XOR<XOR<SongUpdateToOneWithWhereWithoutArtistsInput, SongUpdateWithoutArtistsInput>, SongUncheckedUpdateWithoutArtistsInput>
  }

  export type ArtistUpdateOneRequiredWithoutSongsNestedInput = {
    create?: XOR<ArtistCreateWithoutSongsInput, ArtistUncheckedCreateWithoutSongsInput>
    connectOrCreate?: ArtistCreateOrConnectWithoutSongsInput
    upsert?: ArtistUpsertWithoutSongsInput
    connect?: ArtistWhereUniqueInput
    update?: XOR<XOR<ArtistUpdateToOneWithWhereWithoutSongsInput, ArtistUpdateWithoutSongsInput>, ArtistUncheckedUpdateWithoutSongsInput>
  }

  export type SongCreateNestedOneWithoutCreditsInput = {
    create?: XOR<SongCreateWithoutCreditsInput, SongUncheckedCreateWithoutCreditsInput>
    connectOrCreate?: SongCreateOrConnectWithoutCreditsInput
    connect?: SongWhereUniqueInput
  }

  export type ArtistCreateNestedOneWithoutCreditsInput = {
    create?: XOR<ArtistCreateWithoutCreditsInput, ArtistUncheckedCreateWithoutCreditsInput>
    connectOrCreate?: ArtistCreateOrConnectWithoutCreditsInput
    connect?: ArtistWhereUniqueInput
  }

  export type EnumCreditRoleFieldUpdateOperationsInput = {
    set?: $Enums.CreditRole
  }

  export type SongUpdateOneRequiredWithoutCreditsNestedInput = {
    create?: XOR<SongCreateWithoutCreditsInput, SongUncheckedCreateWithoutCreditsInput>
    connectOrCreate?: SongCreateOrConnectWithoutCreditsInput
    upsert?: SongUpsertWithoutCreditsInput
    connect?: SongWhereUniqueInput
    update?: XOR<XOR<SongUpdateToOneWithWhereWithoutCreditsInput, SongUpdateWithoutCreditsInput>, SongUncheckedUpdateWithoutCreditsInput>
  }

  export type ArtistUpdateOneWithoutCreditsNestedInput = {
    create?: XOR<ArtistCreateWithoutCreditsInput, ArtistUncheckedCreateWithoutCreditsInput>
    connectOrCreate?: ArtistCreateOrConnectWithoutCreditsInput
    upsert?: ArtistUpsertWithoutCreditsInput
    disconnect?: ArtistWhereInput | boolean
    delete?: ArtistWhereInput | boolean
    connect?: ArtistWhereUniqueInput
    update?: XOR<XOR<ArtistUpdateToOneWithWhereWithoutCreditsInput, ArtistUpdateWithoutCreditsInput>, ArtistUncheckedUpdateWithoutCreditsInput>
  }

  export type SongCreateNestedOneWithoutGenresInput = {
    create?: XOR<SongCreateWithoutGenresInput, SongUncheckedCreateWithoutGenresInput>
    connectOrCreate?: SongCreateOrConnectWithoutGenresInput
    connect?: SongWhereUniqueInput
  }

  export type GenreCreateNestedOneWithoutSongsInput = {
    create?: XOR<GenreCreateWithoutSongsInput, GenreUncheckedCreateWithoutSongsInput>
    connectOrCreate?: GenreCreateOrConnectWithoutSongsInput
    connect?: GenreWhereUniqueInput
  }

  export type SongUpdateOneRequiredWithoutGenresNestedInput = {
    create?: XOR<SongCreateWithoutGenresInput, SongUncheckedCreateWithoutGenresInput>
    connectOrCreate?: SongCreateOrConnectWithoutGenresInput
    upsert?: SongUpsertWithoutGenresInput
    connect?: SongWhereUniqueInput
    update?: XOR<XOR<SongUpdateToOneWithWhereWithoutGenresInput, SongUpdateWithoutGenresInput>, SongUncheckedUpdateWithoutGenresInput>
  }

  export type GenreUpdateOneRequiredWithoutSongsNestedInput = {
    create?: XOR<GenreCreateWithoutSongsInput, GenreUncheckedCreateWithoutSongsInput>
    connectOrCreate?: GenreCreateOrConnectWithoutSongsInput
    upsert?: GenreUpsertWithoutSongsInput
    connect?: GenreWhereUniqueInput
    update?: XOR<XOR<GenreUpdateToOneWithWhereWithoutSongsInput, GenreUpdateWithoutSongsInput>, GenreUncheckedUpdateWithoutSongsInput>
  }

  export type AlbumCreateNestedOneWithoutGenresInput = {
    create?: XOR<AlbumCreateWithoutGenresInput, AlbumUncheckedCreateWithoutGenresInput>
    connectOrCreate?: AlbumCreateOrConnectWithoutGenresInput
    connect?: AlbumWhereUniqueInput
  }

  export type GenreCreateNestedOneWithoutAlbumsInput = {
    create?: XOR<GenreCreateWithoutAlbumsInput, GenreUncheckedCreateWithoutAlbumsInput>
    connectOrCreate?: GenreCreateOrConnectWithoutAlbumsInput
    connect?: GenreWhereUniqueInput
  }

  export type AlbumUpdateOneRequiredWithoutGenresNestedInput = {
    create?: XOR<AlbumCreateWithoutGenresInput, AlbumUncheckedCreateWithoutGenresInput>
    connectOrCreate?: AlbumCreateOrConnectWithoutGenresInput
    upsert?: AlbumUpsertWithoutGenresInput
    connect?: AlbumWhereUniqueInput
    update?: XOR<XOR<AlbumUpdateToOneWithWhereWithoutGenresInput, AlbumUpdateWithoutGenresInput>, AlbumUncheckedUpdateWithoutGenresInput>
  }

  export type GenreUpdateOneRequiredWithoutAlbumsNestedInput = {
    create?: XOR<GenreCreateWithoutAlbumsInput, GenreUncheckedCreateWithoutAlbumsInput>
    connectOrCreate?: GenreCreateOrConnectWithoutAlbumsInput
    upsert?: GenreUpsertWithoutAlbumsInput
    connect?: GenreWhereUniqueInput
    update?: XOR<XOR<GenreUpdateToOneWithWhereWithoutAlbumsInput, GenreUpdateWithoutAlbumsInput>, GenreUncheckedUpdateWithoutAlbumsInput>
  }

  export type ArtistCreateNestedOneWithoutGenresInput = {
    create?: XOR<ArtistCreateWithoutGenresInput, ArtistUncheckedCreateWithoutGenresInput>
    connectOrCreate?: ArtistCreateOrConnectWithoutGenresInput
    connect?: ArtistWhereUniqueInput
  }

  export type GenreCreateNestedOneWithoutArtistsInput = {
    create?: XOR<GenreCreateWithoutArtistsInput, GenreUncheckedCreateWithoutArtistsInput>
    connectOrCreate?: GenreCreateOrConnectWithoutArtistsInput
    connect?: GenreWhereUniqueInput
  }

  export type ArtistUpdateOneRequiredWithoutGenresNestedInput = {
    create?: XOR<ArtistCreateWithoutGenresInput, ArtistUncheckedCreateWithoutGenresInput>
    connectOrCreate?: ArtistCreateOrConnectWithoutGenresInput
    upsert?: ArtistUpsertWithoutGenresInput
    connect?: ArtistWhereUniqueInput
    update?: XOR<XOR<ArtistUpdateToOneWithWhereWithoutGenresInput, ArtistUpdateWithoutGenresInput>, ArtistUncheckedUpdateWithoutGenresInput>
  }

  export type GenreUpdateOneRequiredWithoutArtistsNestedInput = {
    create?: XOR<GenreCreateWithoutArtistsInput, GenreUncheckedCreateWithoutArtistsInput>
    connectOrCreate?: GenreCreateOrConnectWithoutArtistsInput
    upsert?: GenreUpsertWithoutArtistsInput
    connect?: GenreWhereUniqueInput
    update?: XOR<XOR<GenreUpdateToOneWithWhereWithoutArtistsInput, GenreUpdateWithoutArtistsInput>, GenreUncheckedUpdateWithoutArtistsInput>
  }

  export type UserCreateNestedOneWithoutPlaylistsInput = {
    create?: XOR<UserCreateWithoutPlaylistsInput, UserUncheckedCreateWithoutPlaylistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlaylistsInput
    connect?: UserWhereUniqueInput
  }

  export type PlaylistItemCreateNestedManyWithoutPlaylistInput = {
    create?: XOR<PlaylistItemCreateWithoutPlaylistInput, PlaylistItemUncheckedCreateWithoutPlaylistInput> | PlaylistItemCreateWithoutPlaylistInput[] | PlaylistItemUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: PlaylistItemCreateOrConnectWithoutPlaylistInput | PlaylistItemCreateOrConnectWithoutPlaylistInput[]
    createMany?: PlaylistItemCreateManyPlaylistInputEnvelope
    connect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[]
  }

  export type UserLikedPlaylistCreateNestedManyWithoutPlaylistInput = {
    create?: XOR<UserLikedPlaylistCreateWithoutPlaylistInput, UserLikedPlaylistUncheckedCreateWithoutPlaylistInput> | UserLikedPlaylistCreateWithoutPlaylistInput[] | UserLikedPlaylistUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: UserLikedPlaylistCreateOrConnectWithoutPlaylistInput | UserLikedPlaylistCreateOrConnectWithoutPlaylistInput[]
    createMany?: UserLikedPlaylistCreateManyPlaylistInputEnvelope
    connect?: UserLikedPlaylistWhereUniqueInput | UserLikedPlaylistWhereUniqueInput[]
  }

  export type PlaylistItemUncheckedCreateNestedManyWithoutPlaylistInput = {
    create?: XOR<PlaylistItemCreateWithoutPlaylistInput, PlaylistItemUncheckedCreateWithoutPlaylistInput> | PlaylistItemCreateWithoutPlaylistInput[] | PlaylistItemUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: PlaylistItemCreateOrConnectWithoutPlaylistInput | PlaylistItemCreateOrConnectWithoutPlaylistInput[]
    createMany?: PlaylistItemCreateManyPlaylistInputEnvelope
    connect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[]
  }

  export type UserLikedPlaylistUncheckedCreateNestedManyWithoutPlaylistInput = {
    create?: XOR<UserLikedPlaylistCreateWithoutPlaylistInput, UserLikedPlaylistUncheckedCreateWithoutPlaylistInput> | UserLikedPlaylistCreateWithoutPlaylistInput[] | UserLikedPlaylistUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: UserLikedPlaylistCreateOrConnectWithoutPlaylistInput | UserLikedPlaylistCreateOrConnectWithoutPlaylistInput[]
    createMany?: UserLikedPlaylistCreateManyPlaylistInputEnvelope
    connect?: UserLikedPlaylistWhereUniqueInput | UserLikedPlaylistWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutPlaylistsNestedInput = {
    create?: XOR<UserCreateWithoutPlaylistsInput, UserUncheckedCreateWithoutPlaylistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlaylistsInput
    upsert?: UserUpsertWithoutPlaylistsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlaylistsInput, UserUpdateWithoutPlaylistsInput>, UserUncheckedUpdateWithoutPlaylistsInput>
  }

  export type PlaylistItemUpdateManyWithoutPlaylistNestedInput = {
    create?: XOR<PlaylistItemCreateWithoutPlaylistInput, PlaylistItemUncheckedCreateWithoutPlaylistInput> | PlaylistItemCreateWithoutPlaylistInput[] | PlaylistItemUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: PlaylistItemCreateOrConnectWithoutPlaylistInput | PlaylistItemCreateOrConnectWithoutPlaylistInput[]
    upsert?: PlaylistItemUpsertWithWhereUniqueWithoutPlaylistInput | PlaylistItemUpsertWithWhereUniqueWithoutPlaylistInput[]
    createMany?: PlaylistItemCreateManyPlaylistInputEnvelope
    set?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[]
    disconnect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[]
    delete?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[]
    connect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[]
    update?: PlaylistItemUpdateWithWhereUniqueWithoutPlaylistInput | PlaylistItemUpdateWithWhereUniqueWithoutPlaylistInput[]
    updateMany?: PlaylistItemUpdateManyWithWhereWithoutPlaylistInput | PlaylistItemUpdateManyWithWhereWithoutPlaylistInput[]
    deleteMany?: PlaylistItemScalarWhereInput | PlaylistItemScalarWhereInput[]
  }

  export type UserLikedPlaylistUpdateManyWithoutPlaylistNestedInput = {
    create?: XOR<UserLikedPlaylistCreateWithoutPlaylistInput, UserLikedPlaylistUncheckedCreateWithoutPlaylistInput> | UserLikedPlaylistCreateWithoutPlaylistInput[] | UserLikedPlaylistUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: UserLikedPlaylistCreateOrConnectWithoutPlaylistInput | UserLikedPlaylistCreateOrConnectWithoutPlaylistInput[]
    upsert?: UserLikedPlaylistUpsertWithWhereUniqueWithoutPlaylistInput | UserLikedPlaylistUpsertWithWhereUniqueWithoutPlaylistInput[]
    createMany?: UserLikedPlaylistCreateManyPlaylistInputEnvelope
    set?: UserLikedPlaylistWhereUniqueInput | UserLikedPlaylistWhereUniqueInput[]
    disconnect?: UserLikedPlaylistWhereUniqueInput | UserLikedPlaylistWhereUniqueInput[]
    delete?: UserLikedPlaylistWhereUniqueInput | UserLikedPlaylistWhereUniqueInput[]
    connect?: UserLikedPlaylistWhereUniqueInput | UserLikedPlaylistWhereUniqueInput[]
    update?: UserLikedPlaylistUpdateWithWhereUniqueWithoutPlaylistInput | UserLikedPlaylistUpdateWithWhereUniqueWithoutPlaylistInput[]
    updateMany?: UserLikedPlaylistUpdateManyWithWhereWithoutPlaylistInput | UserLikedPlaylistUpdateManyWithWhereWithoutPlaylistInput[]
    deleteMany?: UserLikedPlaylistScalarWhereInput | UserLikedPlaylistScalarWhereInput[]
  }

  export type PlaylistItemUncheckedUpdateManyWithoutPlaylistNestedInput = {
    create?: XOR<PlaylistItemCreateWithoutPlaylistInput, PlaylistItemUncheckedCreateWithoutPlaylistInput> | PlaylistItemCreateWithoutPlaylistInput[] | PlaylistItemUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: PlaylistItemCreateOrConnectWithoutPlaylistInput | PlaylistItemCreateOrConnectWithoutPlaylistInput[]
    upsert?: PlaylistItemUpsertWithWhereUniqueWithoutPlaylistInput | PlaylistItemUpsertWithWhereUniqueWithoutPlaylistInput[]
    createMany?: PlaylistItemCreateManyPlaylistInputEnvelope
    set?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[]
    disconnect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[]
    delete?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[]
    connect?: PlaylistItemWhereUniqueInput | PlaylistItemWhereUniqueInput[]
    update?: PlaylistItemUpdateWithWhereUniqueWithoutPlaylistInput | PlaylistItemUpdateWithWhereUniqueWithoutPlaylistInput[]
    updateMany?: PlaylistItemUpdateManyWithWhereWithoutPlaylistInput | PlaylistItemUpdateManyWithWhereWithoutPlaylistInput[]
    deleteMany?: PlaylistItemScalarWhereInput | PlaylistItemScalarWhereInput[]
  }

  export type UserLikedPlaylistUncheckedUpdateManyWithoutPlaylistNestedInput = {
    create?: XOR<UserLikedPlaylistCreateWithoutPlaylistInput, UserLikedPlaylistUncheckedCreateWithoutPlaylistInput> | UserLikedPlaylistCreateWithoutPlaylistInput[] | UserLikedPlaylistUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: UserLikedPlaylistCreateOrConnectWithoutPlaylistInput | UserLikedPlaylistCreateOrConnectWithoutPlaylistInput[]
    upsert?: UserLikedPlaylistUpsertWithWhereUniqueWithoutPlaylistInput | UserLikedPlaylistUpsertWithWhereUniqueWithoutPlaylistInput[]
    createMany?: UserLikedPlaylistCreateManyPlaylistInputEnvelope
    set?: UserLikedPlaylistWhereUniqueInput | UserLikedPlaylistWhereUniqueInput[]
    disconnect?: UserLikedPlaylistWhereUniqueInput | UserLikedPlaylistWhereUniqueInput[]
    delete?: UserLikedPlaylistWhereUniqueInput | UserLikedPlaylistWhereUniqueInput[]
    connect?: UserLikedPlaylistWhereUniqueInput | UserLikedPlaylistWhereUniqueInput[]
    update?: UserLikedPlaylistUpdateWithWhereUniqueWithoutPlaylistInput | UserLikedPlaylistUpdateWithWhereUniqueWithoutPlaylistInput[]
    updateMany?: UserLikedPlaylistUpdateManyWithWhereWithoutPlaylistInput | UserLikedPlaylistUpdateManyWithWhereWithoutPlaylistInput[]
    deleteMany?: UserLikedPlaylistScalarWhereInput | UserLikedPlaylistScalarWhereInput[]
  }

  export type PlaylistCreateNestedOneWithoutItemsInput = {
    create?: XOR<PlaylistCreateWithoutItemsInput, PlaylistUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PlaylistCreateOrConnectWithoutItemsInput
    connect?: PlaylistWhereUniqueInput
  }

  export type SongCreateNestedOneWithoutPlaylistItemsInput = {
    create?: XOR<SongCreateWithoutPlaylistItemsInput, SongUncheckedCreateWithoutPlaylistItemsInput>
    connectOrCreate?: SongCreateOrConnectWithoutPlaylistItemsInput
    connect?: SongWhereUniqueInput
  }

  export type PlaylistUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PlaylistCreateWithoutItemsInput, PlaylistUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PlaylistCreateOrConnectWithoutItemsInput
    upsert?: PlaylistUpsertWithoutItemsInput
    connect?: PlaylistWhereUniqueInput
    update?: XOR<XOR<PlaylistUpdateToOneWithWhereWithoutItemsInput, PlaylistUpdateWithoutItemsInput>, PlaylistUncheckedUpdateWithoutItemsInput>
  }

  export type SongUpdateOneRequiredWithoutPlaylistItemsNestedInput = {
    create?: XOR<SongCreateWithoutPlaylistItemsInput, SongUncheckedCreateWithoutPlaylistItemsInput>
    connectOrCreate?: SongCreateOrConnectWithoutPlaylistItemsInput
    upsert?: SongUpsertWithoutPlaylistItemsInput
    connect?: SongWhereUniqueInput
    update?: XOR<XOR<SongUpdateToOneWithWhereWithoutPlaylistItemsInput, SongUpdateWithoutPlaylistItemsInput>, SongUncheckedUpdateWithoutPlaylistItemsInput>
  }

  export type UserCreateNestedOneWithoutLikedSongsInput = {
    create?: XOR<UserCreateWithoutLikedSongsInput, UserUncheckedCreateWithoutLikedSongsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikedSongsInput
    connect?: UserWhereUniqueInput
  }

  export type SongCreateNestedOneWithoutLikedByInput = {
    create?: XOR<SongCreateWithoutLikedByInput, SongUncheckedCreateWithoutLikedByInput>
    connectOrCreate?: SongCreateOrConnectWithoutLikedByInput
    connect?: SongWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLikedSongsNestedInput = {
    create?: XOR<UserCreateWithoutLikedSongsInput, UserUncheckedCreateWithoutLikedSongsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikedSongsInput
    upsert?: UserUpsertWithoutLikedSongsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLikedSongsInput, UserUpdateWithoutLikedSongsInput>, UserUncheckedUpdateWithoutLikedSongsInput>
  }

  export type SongUpdateOneRequiredWithoutLikedByNestedInput = {
    create?: XOR<SongCreateWithoutLikedByInput, SongUncheckedCreateWithoutLikedByInput>
    connectOrCreate?: SongCreateOrConnectWithoutLikedByInput
    upsert?: SongUpsertWithoutLikedByInput
    connect?: SongWhereUniqueInput
    update?: XOR<XOR<SongUpdateToOneWithWhereWithoutLikedByInput, SongUpdateWithoutLikedByInput>, SongUncheckedUpdateWithoutLikedByInput>
  }

  export type UserCreateNestedOneWithoutLikedAlbumsInput = {
    create?: XOR<UserCreateWithoutLikedAlbumsInput, UserUncheckedCreateWithoutLikedAlbumsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikedAlbumsInput
    connect?: UserWhereUniqueInput
  }

  export type AlbumCreateNestedOneWithoutLikedByInput = {
    create?: XOR<AlbumCreateWithoutLikedByInput, AlbumUncheckedCreateWithoutLikedByInput>
    connectOrCreate?: AlbumCreateOrConnectWithoutLikedByInput
    connect?: AlbumWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLikedAlbumsNestedInput = {
    create?: XOR<UserCreateWithoutLikedAlbumsInput, UserUncheckedCreateWithoutLikedAlbumsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikedAlbumsInput
    upsert?: UserUpsertWithoutLikedAlbumsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLikedAlbumsInput, UserUpdateWithoutLikedAlbumsInput>, UserUncheckedUpdateWithoutLikedAlbumsInput>
  }

  export type AlbumUpdateOneRequiredWithoutLikedByNestedInput = {
    create?: XOR<AlbumCreateWithoutLikedByInput, AlbumUncheckedCreateWithoutLikedByInput>
    connectOrCreate?: AlbumCreateOrConnectWithoutLikedByInput
    upsert?: AlbumUpsertWithoutLikedByInput
    connect?: AlbumWhereUniqueInput
    update?: XOR<XOR<AlbumUpdateToOneWithWhereWithoutLikedByInput, AlbumUpdateWithoutLikedByInput>, AlbumUncheckedUpdateWithoutLikedByInput>
  }

  export type UserCreateNestedOneWithoutLikedArtistsInput = {
    create?: XOR<UserCreateWithoutLikedArtistsInput, UserUncheckedCreateWithoutLikedArtistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikedArtistsInput
    connect?: UserWhereUniqueInput
  }

  export type ArtistCreateNestedOneWithoutLikedByInput = {
    create?: XOR<ArtistCreateWithoutLikedByInput, ArtistUncheckedCreateWithoutLikedByInput>
    connectOrCreate?: ArtistCreateOrConnectWithoutLikedByInput
    connect?: ArtistWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLikedArtistsNestedInput = {
    create?: XOR<UserCreateWithoutLikedArtistsInput, UserUncheckedCreateWithoutLikedArtistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikedArtistsInput
    upsert?: UserUpsertWithoutLikedArtistsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLikedArtistsInput, UserUpdateWithoutLikedArtistsInput>, UserUncheckedUpdateWithoutLikedArtistsInput>
  }

  export type ArtistUpdateOneRequiredWithoutLikedByNestedInput = {
    create?: XOR<ArtistCreateWithoutLikedByInput, ArtistUncheckedCreateWithoutLikedByInput>
    connectOrCreate?: ArtistCreateOrConnectWithoutLikedByInput
    upsert?: ArtistUpsertWithoutLikedByInput
    connect?: ArtistWhereUniqueInput
    update?: XOR<XOR<ArtistUpdateToOneWithWhereWithoutLikedByInput, ArtistUpdateWithoutLikedByInput>, ArtistUncheckedUpdateWithoutLikedByInput>
  }

  export type UserCreateNestedOneWithoutLikedPlaylistsInput = {
    create?: XOR<UserCreateWithoutLikedPlaylistsInput, UserUncheckedCreateWithoutLikedPlaylistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikedPlaylistsInput
    connect?: UserWhereUniqueInput
  }

  export type PlaylistCreateNestedOneWithoutLikedByInput = {
    create?: XOR<PlaylistCreateWithoutLikedByInput, PlaylistUncheckedCreateWithoutLikedByInput>
    connectOrCreate?: PlaylistCreateOrConnectWithoutLikedByInput
    connect?: PlaylistWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLikedPlaylistsNestedInput = {
    create?: XOR<UserCreateWithoutLikedPlaylistsInput, UserUncheckedCreateWithoutLikedPlaylistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikedPlaylistsInput
    upsert?: UserUpsertWithoutLikedPlaylistsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLikedPlaylistsInput, UserUpdateWithoutLikedPlaylistsInput>, UserUncheckedUpdateWithoutLikedPlaylistsInput>
  }

  export type PlaylistUpdateOneRequiredWithoutLikedByNestedInput = {
    create?: XOR<PlaylistCreateWithoutLikedByInput, PlaylistUncheckedCreateWithoutLikedByInput>
    connectOrCreate?: PlaylistCreateOrConnectWithoutLikedByInput
    upsert?: PlaylistUpsertWithoutLikedByInput
    connect?: PlaylistWhereUniqueInput
    update?: XOR<XOR<PlaylistUpdateToOneWithWhereWithoutLikedByInput, PlaylistUpdateWithoutLikedByInput>, PlaylistUncheckedUpdateWithoutLikedByInput>
  }

  export type UserCreateNestedOneWithoutFollowersInput = {
    create?: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFollowingInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFollowersNestedInput = {
    create?: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowersInput
    upsert?: UserUpsertWithoutFollowersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowersInput, UserUpdateWithoutFollowersInput>, UserUncheckedUpdateWithoutFollowersInput>
  }

  export type UserUpdateOneRequiredWithoutFollowingNestedInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    upsert?: UserUpsertWithoutFollowingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowingInput, UserUpdateWithoutFollowingInput>, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type UserCreateNestedOneWithoutPlayHistoryInput = {
    create?: XOR<UserCreateWithoutPlayHistoryInput, UserUncheckedCreateWithoutPlayHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlayHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type SongCreateNestedOneWithoutPlayHistoryInput = {
    create?: XOR<SongCreateWithoutPlayHistoryInput, SongUncheckedCreateWithoutPlayHistoryInput>
    connectOrCreate?: SongCreateOrConnectWithoutPlayHistoryInput
    connect?: SongWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPlayHistoryNestedInput = {
    create?: XOR<UserCreateWithoutPlayHistoryInput, UserUncheckedCreateWithoutPlayHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlayHistoryInput
    upsert?: UserUpsertWithoutPlayHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlayHistoryInput, UserUpdateWithoutPlayHistoryInput>, UserUncheckedUpdateWithoutPlayHistoryInput>
  }

  export type SongUpdateOneRequiredWithoutPlayHistoryNestedInput = {
    create?: XOR<SongCreateWithoutPlayHistoryInput, SongUncheckedCreateWithoutPlayHistoryInput>
    connectOrCreate?: SongCreateOrConnectWithoutPlayHistoryInput
    upsert?: SongUpsertWithoutPlayHistoryInput
    connect?: SongWhereUniqueInput
    update?: XOR<XOR<SongUpdateToOneWithWhereWithoutPlayHistoryInput, SongUpdateWithoutPlayHistoryInput>, SongUncheckedUpdateWithoutPlayHistoryInput>
  }

  export type UserCreateNestedOneWithoutSearchHistoryInput = {
    create?: XOR<UserCreateWithoutSearchHistoryInput, UserUncheckedCreateWithoutSearchHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutSearchHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSearchHistoryNestedInput = {
    create?: XOR<UserCreateWithoutSearchHistoryInput, UserUncheckedCreateWithoutSearchHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutSearchHistoryInput
    upsert?: UserUpsertWithoutSearchHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSearchHistoryInput, UserUpdateWithoutSearchHistoryInput>, UserUncheckedUpdateWithoutSearchHistoryInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ChartItemCreateNestedManyWithoutChartInput = {
    create?: XOR<ChartItemCreateWithoutChartInput, ChartItemUncheckedCreateWithoutChartInput> | ChartItemCreateWithoutChartInput[] | ChartItemUncheckedCreateWithoutChartInput[]
    connectOrCreate?: ChartItemCreateOrConnectWithoutChartInput | ChartItemCreateOrConnectWithoutChartInput[]
    createMany?: ChartItemCreateManyChartInputEnvelope
    connect?: ChartItemWhereUniqueInput | ChartItemWhereUniqueInput[]
  }

  export type ChartItemUncheckedCreateNestedManyWithoutChartInput = {
    create?: XOR<ChartItemCreateWithoutChartInput, ChartItemUncheckedCreateWithoutChartInput> | ChartItemCreateWithoutChartInput[] | ChartItemUncheckedCreateWithoutChartInput[]
    connectOrCreate?: ChartItemCreateOrConnectWithoutChartInput | ChartItemCreateOrConnectWithoutChartInput[]
    createMany?: ChartItemCreateManyChartInputEnvelope
    connect?: ChartItemWhereUniqueInput | ChartItemWhereUniqueInput[]
  }

  export type EnumChartTypeFieldUpdateOperationsInput = {
    set?: $Enums.ChartType
  }

  export type ChartItemUpdateManyWithoutChartNestedInput = {
    create?: XOR<ChartItemCreateWithoutChartInput, ChartItemUncheckedCreateWithoutChartInput> | ChartItemCreateWithoutChartInput[] | ChartItemUncheckedCreateWithoutChartInput[]
    connectOrCreate?: ChartItemCreateOrConnectWithoutChartInput | ChartItemCreateOrConnectWithoutChartInput[]
    upsert?: ChartItemUpsertWithWhereUniqueWithoutChartInput | ChartItemUpsertWithWhereUniqueWithoutChartInput[]
    createMany?: ChartItemCreateManyChartInputEnvelope
    set?: ChartItemWhereUniqueInput | ChartItemWhereUniqueInput[]
    disconnect?: ChartItemWhereUniqueInput | ChartItemWhereUniqueInput[]
    delete?: ChartItemWhereUniqueInput | ChartItemWhereUniqueInput[]
    connect?: ChartItemWhereUniqueInput | ChartItemWhereUniqueInput[]
    update?: ChartItemUpdateWithWhereUniqueWithoutChartInput | ChartItemUpdateWithWhereUniqueWithoutChartInput[]
    updateMany?: ChartItemUpdateManyWithWhereWithoutChartInput | ChartItemUpdateManyWithWhereWithoutChartInput[]
    deleteMany?: ChartItemScalarWhereInput | ChartItemScalarWhereInput[]
  }

  export type ChartItemUncheckedUpdateManyWithoutChartNestedInput = {
    create?: XOR<ChartItemCreateWithoutChartInput, ChartItemUncheckedCreateWithoutChartInput> | ChartItemCreateWithoutChartInput[] | ChartItemUncheckedCreateWithoutChartInput[]
    connectOrCreate?: ChartItemCreateOrConnectWithoutChartInput | ChartItemCreateOrConnectWithoutChartInput[]
    upsert?: ChartItemUpsertWithWhereUniqueWithoutChartInput | ChartItemUpsertWithWhereUniqueWithoutChartInput[]
    createMany?: ChartItemCreateManyChartInputEnvelope
    set?: ChartItemWhereUniqueInput | ChartItemWhereUniqueInput[]
    disconnect?: ChartItemWhereUniqueInput | ChartItemWhereUniqueInput[]
    delete?: ChartItemWhereUniqueInput | ChartItemWhereUniqueInput[]
    connect?: ChartItemWhereUniqueInput | ChartItemWhereUniqueInput[]
    update?: ChartItemUpdateWithWhereUniqueWithoutChartInput | ChartItemUpdateWithWhereUniqueWithoutChartInput[]
    updateMany?: ChartItemUpdateManyWithWhereWithoutChartInput | ChartItemUpdateManyWithWhereWithoutChartInput[]
    deleteMany?: ChartItemScalarWhereInput | ChartItemScalarWhereInput[]
  }

  export type ChartCreateNestedOneWithoutItemsInput = {
    create?: XOR<ChartCreateWithoutItemsInput, ChartUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ChartCreateOrConnectWithoutItemsInput
    connect?: ChartWhereUniqueInput
  }

  export type ChartUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ChartCreateWithoutItemsInput, ChartUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ChartCreateOrConnectWithoutItemsInput
    upsert?: ChartUpsertWithoutItemsInput
    connect?: ChartWhereUniqueInput
    update?: XOR<XOR<ChartUpdateToOneWithWhereWithoutItemsInput, ChartUpdateWithoutItemsInput>, ChartUncheckedUpdateWithoutItemsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSubscriptionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTypeFilter<$PrismaModel> | $Enums.SubscriptionType
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumSubscriptionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTypeFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTypeFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumAlbumTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AlbumType | EnumAlbumTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlbumType[] | ListEnumAlbumTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlbumType[] | ListEnumAlbumTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlbumTypeFilter<$PrismaModel> | $Enums.AlbumType
  }

  export type NestedEnumAlbumTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlbumType | EnumAlbumTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlbumType[] | ListEnumAlbumTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlbumType[] | ListEnumAlbumTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlbumTypeWithAggregatesFilter<$PrismaModel> | $Enums.AlbumType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlbumTypeFilter<$PrismaModel>
    _max?: NestedEnumAlbumTypeFilter<$PrismaModel>
  }

  export type NestedEnumArtistRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ArtistRole | EnumArtistRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ArtistRole[] | ListEnumArtistRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArtistRole[] | ListEnumArtistRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumArtistRoleFilter<$PrismaModel> | $Enums.ArtistRole
  }

  export type NestedEnumArtistRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArtistRole | EnumArtistRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ArtistRole[] | ListEnumArtistRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArtistRole[] | ListEnumArtistRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumArtistRoleWithAggregatesFilter<$PrismaModel> | $Enums.ArtistRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArtistRoleFilter<$PrismaModel>
    _max?: NestedEnumArtistRoleFilter<$PrismaModel>
  }

  export type NestedEnumCreditRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditRole | EnumCreditRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CreditRole[] | ListEnumCreditRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditRole[] | ListEnumCreditRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditRoleFilter<$PrismaModel> | $Enums.CreditRole
  }

  export type NestedEnumCreditRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditRole | EnumCreditRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CreditRole[] | ListEnumCreditRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditRole[] | ListEnumCreditRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditRoleWithAggregatesFilter<$PrismaModel> | $Enums.CreditRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreditRoleFilter<$PrismaModel>
    _max?: NestedEnumCreditRoleFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumChartTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChartType | EnumChartTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChartType[] | ListEnumChartTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChartType[] | ListEnumChartTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChartTypeFilter<$PrismaModel> | $Enums.ChartType
  }

  export type NestedEnumChartTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChartType | EnumChartTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChartType[] | ListEnumChartTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChartType[] | ListEnumChartTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChartTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChartType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChartTypeFilter<$PrismaModel>
    _max?: NestedEnumChartTypeFilter<$PrismaModel>
  }

  export type UserSubscriptionCreateWithoutUserInput = {
    id?: string
    type?: $Enums.SubscriptionType
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    endDate?: Date | string | null
    autoRenew?: boolean
    paymentMethod?: string | null
  }

  export type UserSubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    type?: $Enums.SubscriptionType
    status?: $Enums.SubscriptionStatus
    startDate?: Date | string
    endDate?: Date | string | null
    autoRenew?: boolean
    paymentMethod?: string | null
  }

  export type UserSubscriptionCreateOrConnectWithoutUserInput = {
    where: UserSubscriptionWhereUniqueInput
    create: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PlaylistCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    imageId?: string | null
    isPublic?: boolean
    isOfficial?: boolean
    totalTracks?: number
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PlaylistItemCreateNestedManyWithoutPlaylistInput
    likedBy?: UserLikedPlaylistCreateNestedManyWithoutPlaylistInput
  }

  export type PlaylistUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    imageId?: string | null
    isPublic?: boolean
    isOfficial?: boolean
    totalTracks?: number
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PlaylistItemUncheckedCreateNestedManyWithoutPlaylistInput
    likedBy?: UserLikedPlaylistUncheckedCreateNestedManyWithoutPlaylistInput
  }

  export type PlaylistCreateOrConnectWithoutUserInput = {
    where: PlaylistWhereUniqueInput
    create: XOR<PlaylistCreateWithoutUserInput, PlaylistUncheckedCreateWithoutUserInput>
  }

  export type PlaylistCreateManyUserInputEnvelope = {
    data: PlaylistCreateManyUserInput | PlaylistCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserLikedSongCreateWithoutUserInput = {
    likedAt?: Date | string
    song: SongCreateNestedOneWithoutLikedByInput
  }

  export type UserLikedSongUncheckedCreateWithoutUserInput = {
    songId: string
    likedAt?: Date | string
  }

  export type UserLikedSongCreateOrConnectWithoutUserInput = {
    where: UserLikedSongWhereUniqueInput
    create: XOR<UserLikedSongCreateWithoutUserInput, UserLikedSongUncheckedCreateWithoutUserInput>
  }

  export type UserLikedSongCreateManyUserInputEnvelope = {
    data: UserLikedSongCreateManyUserInput | UserLikedSongCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserLikedAlbumCreateWithoutUserInput = {
    likedAt?: Date | string
    album: AlbumCreateNestedOneWithoutLikedByInput
  }

  export type UserLikedAlbumUncheckedCreateWithoutUserInput = {
    albumId: string
    likedAt?: Date | string
  }

  export type UserLikedAlbumCreateOrConnectWithoutUserInput = {
    where: UserLikedAlbumWhereUniqueInput
    create: XOR<UserLikedAlbumCreateWithoutUserInput, UserLikedAlbumUncheckedCreateWithoutUserInput>
  }

  export type UserLikedAlbumCreateManyUserInputEnvelope = {
    data: UserLikedAlbumCreateManyUserInput | UserLikedAlbumCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserLikedPlaylistCreateWithoutUserInput = {
    likedAt?: Date | string
    playlist: PlaylistCreateNestedOneWithoutLikedByInput
  }

  export type UserLikedPlaylistUncheckedCreateWithoutUserInput = {
    playlistId: string
    likedAt?: Date | string
  }

  export type UserLikedPlaylistCreateOrConnectWithoutUserInput = {
    where: UserLikedPlaylistWhereUniqueInput
    create: XOR<UserLikedPlaylistCreateWithoutUserInput, UserLikedPlaylistUncheckedCreateWithoutUserInput>
  }

  export type UserLikedPlaylistCreateManyUserInputEnvelope = {
    data: UserLikedPlaylistCreateManyUserInput | UserLikedPlaylistCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserLikedArtistCreateWithoutUserInput = {
    likedAt?: Date | string
    artist: ArtistCreateNestedOneWithoutLikedByInput
  }

  export type UserLikedArtistUncheckedCreateWithoutUserInput = {
    artistId: string
    likedAt?: Date | string
  }

  export type UserLikedArtistCreateOrConnectWithoutUserInput = {
    where: UserLikedArtistWhereUniqueInput
    create: XOR<UserLikedArtistCreateWithoutUserInput, UserLikedArtistUncheckedCreateWithoutUserInput>
  }

  export type UserLikedArtistCreateManyUserInputEnvelope = {
    data: UserLikedArtistCreateManyUserInput | UserLikedArtistCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PlayHistoryCreateWithoutUserInput = {
    id?: string
    playedAt?: Date | string
    duration: number
    deviceType?: string | null
    song: SongCreateNestedOneWithoutPlayHistoryInput
  }

  export type PlayHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    playedAt?: Date | string
    duration: number
    deviceType?: string | null
    songId: string
  }

  export type PlayHistoryCreateOrConnectWithoutUserInput = {
    where: PlayHistoryWhereUniqueInput
    create: XOR<PlayHistoryCreateWithoutUserInput, PlayHistoryUncheckedCreateWithoutUserInput>
  }

  export type PlayHistoryCreateManyUserInputEnvelope = {
    data: PlayHistoryCreateManyUserInput | PlayHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SearchHistoryCreateWithoutUserInput = {
    id?: string
    query: string
    resultType?: string | null
    resultId?: string | null
    searchedAt?: Date | string
  }

  export type SearchHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    query: string
    resultType?: string | null
    resultId?: string | null
    searchedAt?: Date | string
  }

  export type SearchHistoryCreateOrConnectWithoutUserInput = {
    where: SearchHistoryWhereUniqueInput
    create: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput>
  }

  export type SearchHistoryCreateManyUserInputEnvelope = {
    data: SearchHistoryCreateManyUserInput | SearchHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserFollowCreateWithoutFollowerInput = {
    followedAt?: Date | string
    following: UserCreateNestedOneWithoutFollowingInput
  }

  export type UserFollowUncheckedCreateWithoutFollowerInput = {
    followingId: string
    followedAt?: Date | string
  }

  export type UserFollowCreateOrConnectWithoutFollowerInput = {
    where: UserFollowWhereUniqueInput
    create: XOR<UserFollowCreateWithoutFollowerInput, UserFollowUncheckedCreateWithoutFollowerInput>
  }

  export type UserFollowCreateManyFollowerInputEnvelope = {
    data: UserFollowCreateManyFollowerInput | UserFollowCreateManyFollowerInput[]
    skipDuplicates?: boolean
  }

  export type UserFollowCreateWithoutFollowingInput = {
    followedAt?: Date | string
    follower: UserCreateNestedOneWithoutFollowersInput
  }

  export type UserFollowUncheckedCreateWithoutFollowingInput = {
    followerId: string
    followedAt?: Date | string
  }

  export type UserFollowCreateOrConnectWithoutFollowingInput = {
    where: UserFollowWhereUniqueInput
    create: XOR<UserFollowCreateWithoutFollowingInput, UserFollowUncheckedCreateWithoutFollowingInput>
  }

  export type UserFollowCreateManyFollowingInputEnvelope = {
    data: UserFollowCreateManyFollowingInput | UserFollowCreateManyFollowingInput[]
    skipDuplicates?: boolean
  }

  export type UserSubscriptionUpsertWithoutUserInput = {
    update: XOR<UserSubscriptionUpdateWithoutUserInput, UserSubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput>
    where?: UserSubscriptionWhereInput
  }

  export type UserSubscriptionUpdateToOneWithWhereWithoutUserInput = {
    where?: UserSubscriptionWhereInput
    data: XOR<UserSubscriptionUpdateWithoutUserInput, UserSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type UserSubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type PlaylistUpsertWithWhereUniqueWithoutUserInput = {
    where: PlaylistWhereUniqueInput
    update: XOR<PlaylistUpdateWithoutUserInput, PlaylistUncheckedUpdateWithoutUserInput>
    create: XOR<PlaylistCreateWithoutUserInput, PlaylistUncheckedCreateWithoutUserInput>
  }

  export type PlaylistUpdateWithWhereUniqueWithoutUserInput = {
    where: PlaylistWhereUniqueInput
    data: XOR<PlaylistUpdateWithoutUserInput, PlaylistUncheckedUpdateWithoutUserInput>
  }

  export type PlaylistUpdateManyWithWhereWithoutUserInput = {
    where: PlaylistScalarWhereInput
    data: XOR<PlaylistUpdateManyMutationInput, PlaylistUncheckedUpdateManyWithoutUserInput>
  }

  export type PlaylistScalarWhereInput = {
    AND?: PlaylistScalarWhereInput | PlaylistScalarWhereInput[]
    OR?: PlaylistScalarWhereInput[]
    NOT?: PlaylistScalarWhereInput | PlaylistScalarWhereInput[]
    id?: StringFilter<"Playlist"> | string
    title?: StringFilter<"Playlist"> | string
    description?: StringNullableFilter<"Playlist"> | string | null
    imageId?: StringNullableFilter<"Playlist"> | string | null
    isPublic?: BoolFilter<"Playlist"> | boolean
    isOfficial?: BoolFilter<"Playlist"> | boolean
    totalTracks?: IntFilter<"Playlist"> | number
    duration?: IntFilter<"Playlist"> | number
    createdAt?: DateTimeFilter<"Playlist"> | Date | string
    updatedAt?: DateTimeFilter<"Playlist"> | Date | string
    userId?: StringNullableFilter<"Playlist"> | string | null
  }

  export type UserLikedSongUpsertWithWhereUniqueWithoutUserInput = {
    where: UserLikedSongWhereUniqueInput
    update: XOR<UserLikedSongUpdateWithoutUserInput, UserLikedSongUncheckedUpdateWithoutUserInput>
    create: XOR<UserLikedSongCreateWithoutUserInput, UserLikedSongUncheckedCreateWithoutUserInput>
  }

  export type UserLikedSongUpdateWithWhereUniqueWithoutUserInput = {
    where: UserLikedSongWhereUniqueInput
    data: XOR<UserLikedSongUpdateWithoutUserInput, UserLikedSongUncheckedUpdateWithoutUserInput>
  }

  export type UserLikedSongUpdateManyWithWhereWithoutUserInput = {
    where: UserLikedSongScalarWhereInput
    data: XOR<UserLikedSongUpdateManyMutationInput, UserLikedSongUncheckedUpdateManyWithoutUserInput>
  }

  export type UserLikedSongScalarWhereInput = {
    AND?: UserLikedSongScalarWhereInput | UserLikedSongScalarWhereInput[]
    OR?: UserLikedSongScalarWhereInput[]
    NOT?: UserLikedSongScalarWhereInput | UserLikedSongScalarWhereInput[]
    userId?: StringFilter<"UserLikedSong"> | string
    songId?: StringFilter<"UserLikedSong"> | string
    likedAt?: DateTimeFilter<"UserLikedSong"> | Date | string
  }

  export type UserLikedAlbumUpsertWithWhereUniqueWithoutUserInput = {
    where: UserLikedAlbumWhereUniqueInput
    update: XOR<UserLikedAlbumUpdateWithoutUserInput, UserLikedAlbumUncheckedUpdateWithoutUserInput>
    create: XOR<UserLikedAlbumCreateWithoutUserInput, UserLikedAlbumUncheckedCreateWithoutUserInput>
  }

  export type UserLikedAlbumUpdateWithWhereUniqueWithoutUserInput = {
    where: UserLikedAlbumWhereUniqueInput
    data: XOR<UserLikedAlbumUpdateWithoutUserInput, UserLikedAlbumUncheckedUpdateWithoutUserInput>
  }

  export type UserLikedAlbumUpdateManyWithWhereWithoutUserInput = {
    where: UserLikedAlbumScalarWhereInput
    data: XOR<UserLikedAlbumUpdateManyMutationInput, UserLikedAlbumUncheckedUpdateManyWithoutUserInput>
  }

  export type UserLikedAlbumScalarWhereInput = {
    AND?: UserLikedAlbumScalarWhereInput | UserLikedAlbumScalarWhereInput[]
    OR?: UserLikedAlbumScalarWhereInput[]
    NOT?: UserLikedAlbumScalarWhereInput | UserLikedAlbumScalarWhereInput[]
    userId?: StringFilter<"UserLikedAlbum"> | string
    albumId?: StringFilter<"UserLikedAlbum"> | string
    likedAt?: DateTimeFilter<"UserLikedAlbum"> | Date | string
  }

  export type UserLikedPlaylistUpsertWithWhereUniqueWithoutUserInput = {
    where: UserLikedPlaylistWhereUniqueInput
    update: XOR<UserLikedPlaylistUpdateWithoutUserInput, UserLikedPlaylistUncheckedUpdateWithoutUserInput>
    create: XOR<UserLikedPlaylistCreateWithoutUserInput, UserLikedPlaylistUncheckedCreateWithoutUserInput>
  }

  export type UserLikedPlaylistUpdateWithWhereUniqueWithoutUserInput = {
    where: UserLikedPlaylistWhereUniqueInput
    data: XOR<UserLikedPlaylistUpdateWithoutUserInput, UserLikedPlaylistUncheckedUpdateWithoutUserInput>
  }

  export type UserLikedPlaylistUpdateManyWithWhereWithoutUserInput = {
    where: UserLikedPlaylistScalarWhereInput
    data: XOR<UserLikedPlaylistUpdateManyMutationInput, UserLikedPlaylistUncheckedUpdateManyWithoutUserInput>
  }

  export type UserLikedPlaylistScalarWhereInput = {
    AND?: UserLikedPlaylistScalarWhereInput | UserLikedPlaylistScalarWhereInput[]
    OR?: UserLikedPlaylistScalarWhereInput[]
    NOT?: UserLikedPlaylistScalarWhereInput | UserLikedPlaylistScalarWhereInput[]
    userId?: StringFilter<"UserLikedPlaylist"> | string
    playlistId?: StringFilter<"UserLikedPlaylist"> | string
    likedAt?: DateTimeFilter<"UserLikedPlaylist"> | Date | string
  }

  export type UserLikedArtistUpsertWithWhereUniqueWithoutUserInput = {
    where: UserLikedArtistWhereUniqueInput
    update: XOR<UserLikedArtistUpdateWithoutUserInput, UserLikedArtistUncheckedUpdateWithoutUserInput>
    create: XOR<UserLikedArtistCreateWithoutUserInput, UserLikedArtistUncheckedCreateWithoutUserInput>
  }

  export type UserLikedArtistUpdateWithWhereUniqueWithoutUserInput = {
    where: UserLikedArtistWhereUniqueInput
    data: XOR<UserLikedArtistUpdateWithoutUserInput, UserLikedArtistUncheckedUpdateWithoutUserInput>
  }

  export type UserLikedArtistUpdateManyWithWhereWithoutUserInput = {
    where: UserLikedArtistScalarWhereInput
    data: XOR<UserLikedArtistUpdateManyMutationInput, UserLikedArtistUncheckedUpdateManyWithoutUserInput>
  }

  export type UserLikedArtistScalarWhereInput = {
    AND?: UserLikedArtistScalarWhereInput | UserLikedArtistScalarWhereInput[]
    OR?: UserLikedArtistScalarWhereInput[]
    NOT?: UserLikedArtistScalarWhereInput | UserLikedArtistScalarWhereInput[]
    userId?: StringFilter<"UserLikedArtist"> | string
    artistId?: StringFilter<"UserLikedArtist"> | string
    likedAt?: DateTimeFilter<"UserLikedArtist"> | Date | string
  }

  export type PlayHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: PlayHistoryWhereUniqueInput
    update: XOR<PlayHistoryUpdateWithoutUserInput, PlayHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<PlayHistoryCreateWithoutUserInput, PlayHistoryUncheckedCreateWithoutUserInput>
  }

  export type PlayHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: PlayHistoryWhereUniqueInput
    data: XOR<PlayHistoryUpdateWithoutUserInput, PlayHistoryUncheckedUpdateWithoutUserInput>
  }

  export type PlayHistoryUpdateManyWithWhereWithoutUserInput = {
    where: PlayHistoryScalarWhereInput
    data: XOR<PlayHistoryUpdateManyMutationInput, PlayHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type PlayHistoryScalarWhereInput = {
    AND?: PlayHistoryScalarWhereInput | PlayHistoryScalarWhereInput[]
    OR?: PlayHistoryScalarWhereInput[]
    NOT?: PlayHistoryScalarWhereInput | PlayHistoryScalarWhereInput[]
    id?: StringFilter<"PlayHistory"> | string
    playedAt?: DateTimeFilter<"PlayHistory"> | Date | string
    duration?: IntFilter<"PlayHistory"> | number
    deviceType?: StringNullableFilter<"PlayHistory"> | string | null
    userId?: StringFilter<"PlayHistory"> | string
    songId?: StringFilter<"PlayHistory"> | string
  }

  export type SearchHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: SearchHistoryWhereUniqueInput
    update: XOR<SearchHistoryUpdateWithoutUserInput, SearchHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput>
  }

  export type SearchHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: SearchHistoryWhereUniqueInput
    data: XOR<SearchHistoryUpdateWithoutUserInput, SearchHistoryUncheckedUpdateWithoutUserInput>
  }

  export type SearchHistoryUpdateManyWithWhereWithoutUserInput = {
    where: SearchHistoryScalarWhereInput
    data: XOR<SearchHistoryUpdateManyMutationInput, SearchHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type SearchHistoryScalarWhereInput = {
    AND?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
    OR?: SearchHistoryScalarWhereInput[]
    NOT?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
    id?: StringFilter<"SearchHistory"> | string
    query?: StringFilter<"SearchHistory"> | string
    resultType?: StringNullableFilter<"SearchHistory"> | string | null
    resultId?: StringNullableFilter<"SearchHistory"> | string | null
    searchedAt?: DateTimeFilter<"SearchHistory"> | Date | string
    userId?: StringFilter<"SearchHistory"> | string
  }

  export type UserFollowUpsertWithWhereUniqueWithoutFollowerInput = {
    where: UserFollowWhereUniqueInput
    update: XOR<UserFollowUpdateWithoutFollowerInput, UserFollowUncheckedUpdateWithoutFollowerInput>
    create: XOR<UserFollowCreateWithoutFollowerInput, UserFollowUncheckedCreateWithoutFollowerInput>
  }

  export type UserFollowUpdateWithWhereUniqueWithoutFollowerInput = {
    where: UserFollowWhereUniqueInput
    data: XOR<UserFollowUpdateWithoutFollowerInput, UserFollowUncheckedUpdateWithoutFollowerInput>
  }

  export type UserFollowUpdateManyWithWhereWithoutFollowerInput = {
    where: UserFollowScalarWhereInput
    data: XOR<UserFollowUpdateManyMutationInput, UserFollowUncheckedUpdateManyWithoutFollowerInput>
  }

  export type UserFollowScalarWhereInput = {
    AND?: UserFollowScalarWhereInput | UserFollowScalarWhereInput[]
    OR?: UserFollowScalarWhereInput[]
    NOT?: UserFollowScalarWhereInput | UserFollowScalarWhereInput[]
    followerId?: StringFilter<"UserFollow"> | string
    followingId?: StringFilter<"UserFollow"> | string
    followedAt?: DateTimeFilter<"UserFollow"> | Date | string
  }

  export type UserFollowUpsertWithWhereUniqueWithoutFollowingInput = {
    where: UserFollowWhereUniqueInput
    update: XOR<UserFollowUpdateWithoutFollowingInput, UserFollowUncheckedUpdateWithoutFollowingInput>
    create: XOR<UserFollowCreateWithoutFollowingInput, UserFollowUncheckedCreateWithoutFollowingInput>
  }

  export type UserFollowUpdateWithWhereUniqueWithoutFollowingInput = {
    where: UserFollowWhereUniqueInput
    data: XOR<UserFollowUpdateWithoutFollowingInput, UserFollowUncheckedUpdateWithoutFollowingInput>
  }

  export type UserFollowUpdateManyWithWhereWithoutFollowingInput = {
    where: UserFollowScalarWhereInput
    data: XOR<UserFollowUpdateManyMutationInput, UserFollowUncheckedUpdateManyWithoutFollowingInput>
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    username?: string | null
    name?: string | null
    password?: string | null
    imageId?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bio?: string | null
    country?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    likedSongs?: UserLikedSongCreateNestedManyWithoutUserInput
    likedAlbums?: UserLikedAlbumCreateNestedManyWithoutUserInput
    likedPlaylists?: UserLikedPlaylistCreateNestedManyWithoutUserInput
    likedArtists?: UserLikedArtistCreateNestedManyWithoutUserInput
    playHistory?: PlayHistoryCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowerInput
    following?: UserFollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email: string
    username?: string | null
    name?: string | null
    password?: string | null
    imageId?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bio?: string | null
    country?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    likedSongs?: UserLikedSongUncheckedCreateNestedManyWithoutUserInput
    likedAlbums?: UserLikedAlbumUncheckedCreateNestedManyWithoutUserInput
    likedPlaylists?: UserLikedPlaylistUncheckedCreateNestedManyWithoutUserInput
    likedArtists?: UserLikedArtistUncheckedCreateNestedManyWithoutUserInput
    playHistory?: PlayHistoryUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    likedSongs?: UserLikedSongUpdateManyWithoutUserNestedInput
    likedAlbums?: UserLikedAlbumUpdateManyWithoutUserNestedInput
    likedPlaylists?: UserLikedPlaylistUpdateManyWithoutUserNestedInput
    likedArtists?: UserLikedArtistUpdateManyWithoutUserNestedInput
    playHistory?: PlayHistoryUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowerNestedInput
    following?: UserFollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    likedSongs?: UserLikedSongUncheckedUpdateManyWithoutUserNestedInput
    likedAlbums?: UserLikedAlbumUncheckedUpdateManyWithoutUserNestedInput
    likedPlaylists?: UserLikedPlaylistUncheckedUpdateManyWithoutUserNestedInput
    likedArtists?: UserLikedArtistUncheckedUpdateManyWithoutUserNestedInput
    playHistory?: PlayHistoryUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    username?: string | null
    name?: string | null
    password?: string | null
    imageId?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bio?: string | null
    country?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    likedSongs?: UserLikedSongCreateNestedManyWithoutUserInput
    likedAlbums?: UserLikedAlbumCreateNestedManyWithoutUserInput
    likedPlaylists?: UserLikedPlaylistCreateNestedManyWithoutUserInput
    likedArtists?: UserLikedArtistCreateNestedManyWithoutUserInput
    playHistory?: PlayHistoryCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowerInput
    following?: UserFollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    username?: string | null
    name?: string | null
    password?: string | null
    imageId?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bio?: string | null
    country?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    likedSongs?: UserLikedSongUncheckedCreateNestedManyWithoutUserInput
    likedAlbums?: UserLikedAlbumUncheckedCreateNestedManyWithoutUserInput
    likedPlaylists?: UserLikedPlaylistUncheckedCreateNestedManyWithoutUserInput
    likedArtists?: UserLikedArtistUncheckedCreateNestedManyWithoutUserInput
    playHistory?: PlayHistoryUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    likedSongs?: UserLikedSongUpdateManyWithoutUserNestedInput
    likedAlbums?: UserLikedAlbumUpdateManyWithoutUserNestedInput
    likedPlaylists?: UserLikedPlaylistUpdateManyWithoutUserNestedInput
    likedArtists?: UserLikedArtistUpdateManyWithoutUserNestedInput
    playHistory?: PlayHistoryUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowerNestedInput
    following?: UserFollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    likedSongs?: UserLikedSongUncheckedUpdateManyWithoutUserNestedInput
    likedAlbums?: UserLikedAlbumUncheckedUpdateManyWithoutUserNestedInput
    likedPlaylists?: UserLikedPlaylistUncheckedUpdateManyWithoutUserNestedInput
    likedArtists?: UserLikedArtistUncheckedUpdateManyWithoutUserNestedInput
    playHistory?: PlayHistoryUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserCreateWithoutSubscriptionInput = {
    id?: string
    email: string
    username?: string | null
    name?: string | null
    password?: string | null
    imageId?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bio?: string | null
    country?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    likedSongs?: UserLikedSongCreateNestedManyWithoutUserInput
    likedAlbums?: UserLikedAlbumCreateNestedManyWithoutUserInput
    likedPlaylists?: UserLikedPlaylistCreateNestedManyWithoutUserInput
    likedArtists?: UserLikedArtistCreateNestedManyWithoutUserInput
    playHistory?: PlayHistoryCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowerInput
    following?: UserFollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    email: string
    username?: string | null
    name?: string | null
    password?: string | null
    imageId?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bio?: string | null
    country?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    likedSongs?: UserLikedSongUncheckedCreateNestedManyWithoutUserInput
    likedAlbums?: UserLikedAlbumUncheckedCreateNestedManyWithoutUserInput
    likedPlaylists?: UserLikedPlaylistUncheckedCreateNestedManyWithoutUserInput
    likedArtists?: UserLikedArtistUncheckedCreateNestedManyWithoutUserInput
    playHistory?: PlayHistoryUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutSubscriptionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
  }

  export type UserUpsertWithoutSubscriptionInput = {
    update: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UserUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    likedSongs?: UserLikedSongUpdateManyWithoutUserNestedInput
    likedAlbums?: UserLikedAlbumUpdateManyWithoutUserNestedInput
    likedPlaylists?: UserLikedPlaylistUpdateManyWithoutUserNestedInput
    likedArtists?: UserLikedArtistUpdateManyWithoutUserNestedInput
    playHistory?: PlayHistoryUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowerNestedInput
    following?: UserFollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    likedSongs?: UserLikedSongUncheckedUpdateManyWithoutUserNestedInput
    likedAlbums?: UserLikedAlbumUncheckedUpdateManyWithoutUserNestedInput
    likedPlaylists?: UserLikedPlaylistUncheckedUpdateManyWithoutUserNestedInput
    likedArtists?: UserLikedArtistUncheckedUpdateManyWithoutUserNestedInput
    playHistory?: PlayHistoryUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type AlbumCreateWithoutArtistInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    imageId: string
    albumType?: $Enums.AlbumType
    releaseDate?: Date | string
    totalTracks?: number
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    songs?: SongCreateNestedManyWithoutAlbumInput
    genres?: AlbumGenreCreateNestedManyWithoutAlbumInput
    likedBy?: UserLikedAlbumCreateNestedManyWithoutAlbumInput
  }

  export type AlbumUncheckedCreateWithoutArtistInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    imageId: string
    albumType?: $Enums.AlbumType
    releaseDate?: Date | string
    totalTracks?: number
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    songs?: SongUncheckedCreateNestedManyWithoutAlbumInput
    genres?: AlbumGenreUncheckedCreateNestedManyWithoutAlbumInput
    likedBy?: UserLikedAlbumUncheckedCreateNestedManyWithoutAlbumInput
  }

  export type AlbumCreateOrConnectWithoutArtistInput = {
    where: AlbumWhereUniqueInput
    create: XOR<AlbumCreateWithoutArtistInput, AlbumUncheckedCreateWithoutArtistInput>
  }

  export type AlbumCreateManyArtistInputEnvelope = {
    data: AlbumCreateManyArtistInput | AlbumCreateManyArtistInput[]
    skipDuplicates?: boolean
  }

  export type SongArtistCreateWithoutArtistInput = {
    id?: string
    role?: $Enums.ArtistRole
    order?: number
    song: SongCreateNestedOneWithoutArtistsInput
  }

  export type SongArtistUncheckedCreateWithoutArtistInput = {
    id?: string
    songId: string
    role?: $Enums.ArtistRole
    order?: number
  }

  export type SongArtistCreateOrConnectWithoutArtistInput = {
    where: SongArtistWhereUniqueInput
    create: XOR<SongArtistCreateWithoutArtistInput, SongArtistUncheckedCreateWithoutArtistInput>
  }

  export type SongArtistCreateManyArtistInputEnvelope = {
    data: SongArtistCreateManyArtistInput | SongArtistCreateManyArtistInput[]
    skipDuplicates?: boolean
  }

  export type ArtistGenreCreateWithoutArtistInput = {
    genre: GenreCreateNestedOneWithoutArtistsInput
  }

  export type ArtistGenreUncheckedCreateWithoutArtistInput = {
    genreId: string
  }

  export type ArtistGenreCreateOrConnectWithoutArtistInput = {
    where: ArtistGenreWhereUniqueInput
    create: XOR<ArtistGenreCreateWithoutArtistInput, ArtistGenreUncheckedCreateWithoutArtistInput>
  }

  export type ArtistGenreCreateManyArtistInputEnvelope = {
    data: ArtistGenreCreateManyArtistInput | ArtistGenreCreateManyArtistInput[]
    skipDuplicates?: boolean
  }

  export type UserLikedArtistCreateWithoutArtistInput = {
    likedAt?: Date | string
    user: UserCreateNestedOneWithoutLikedArtistsInput
  }

  export type UserLikedArtistUncheckedCreateWithoutArtistInput = {
    userId: string
    likedAt?: Date | string
  }

  export type UserLikedArtistCreateOrConnectWithoutArtistInput = {
    where: UserLikedArtistWhereUniqueInput
    create: XOR<UserLikedArtistCreateWithoutArtistInput, UserLikedArtistUncheckedCreateWithoutArtistInput>
  }

  export type UserLikedArtistCreateManyArtistInputEnvelope = {
    data: UserLikedArtistCreateManyArtistInput | UserLikedArtistCreateManyArtistInput[]
    skipDuplicates?: boolean
  }

  export type SongCreditCreateWithoutArtistInput = {
    id?: string
    name: string
    role: $Enums.CreditRole
    details?: string | null
    order?: number
    song: SongCreateNestedOneWithoutCreditsInput
  }

  export type SongCreditUncheckedCreateWithoutArtistInput = {
    id?: string
    songId: string
    name: string
    role: $Enums.CreditRole
    details?: string | null
    order?: number
  }

  export type SongCreditCreateOrConnectWithoutArtistInput = {
    where: SongCreditWhereUniqueInput
    create: XOR<SongCreditCreateWithoutArtistInput, SongCreditUncheckedCreateWithoutArtistInput>
  }

  export type SongCreditCreateManyArtistInputEnvelope = {
    data: SongCreditCreateManyArtistInput | SongCreditCreateManyArtistInput[]
    skipDuplicates?: boolean
  }

  export type AlbumUpsertWithWhereUniqueWithoutArtistInput = {
    where: AlbumWhereUniqueInput
    update: XOR<AlbumUpdateWithoutArtistInput, AlbumUncheckedUpdateWithoutArtistInput>
    create: XOR<AlbumCreateWithoutArtistInput, AlbumUncheckedCreateWithoutArtistInput>
  }

  export type AlbumUpdateWithWhereUniqueWithoutArtistInput = {
    where: AlbumWhereUniqueInput
    data: XOR<AlbumUpdateWithoutArtistInput, AlbumUncheckedUpdateWithoutArtistInput>
  }

  export type AlbumUpdateManyWithWhereWithoutArtistInput = {
    where: AlbumScalarWhereInput
    data: XOR<AlbumUpdateManyMutationInput, AlbumUncheckedUpdateManyWithoutArtistInput>
  }

  export type AlbumScalarWhereInput = {
    AND?: AlbumScalarWhereInput | AlbumScalarWhereInput[]
    OR?: AlbumScalarWhereInput[]
    NOT?: AlbumScalarWhereInput | AlbumScalarWhereInput[]
    id?: StringFilter<"Album"> | string
    title?: StringFilter<"Album"> | string
    slug?: StringFilter<"Album"> | string
    description?: StringNullableFilter<"Album"> | string | null
    imageId?: StringFilter<"Album"> | string
    albumType?: EnumAlbumTypeFilter<"Album"> | $Enums.AlbumType
    releaseDate?: DateTimeFilter<"Album"> | Date | string
    totalTracks?: IntFilter<"Album"> | number
    duration?: IntFilter<"Album"> | number
    createdAt?: DateTimeFilter<"Album"> | Date | string
    updatedAt?: DateTimeFilter<"Album"> | Date | string
    artistId?: StringFilter<"Album"> | string
  }

  export type SongArtistUpsertWithWhereUniqueWithoutArtistInput = {
    where: SongArtistWhereUniqueInput
    update: XOR<SongArtistUpdateWithoutArtistInput, SongArtistUncheckedUpdateWithoutArtistInput>
    create: XOR<SongArtistCreateWithoutArtistInput, SongArtistUncheckedCreateWithoutArtistInput>
  }

  export type SongArtistUpdateWithWhereUniqueWithoutArtistInput = {
    where: SongArtistWhereUniqueInput
    data: XOR<SongArtistUpdateWithoutArtistInput, SongArtistUncheckedUpdateWithoutArtistInput>
  }

  export type SongArtistUpdateManyWithWhereWithoutArtistInput = {
    where: SongArtistScalarWhereInput
    data: XOR<SongArtistUpdateManyMutationInput, SongArtistUncheckedUpdateManyWithoutArtistInput>
  }

  export type SongArtistScalarWhereInput = {
    AND?: SongArtistScalarWhereInput | SongArtistScalarWhereInput[]
    OR?: SongArtistScalarWhereInput[]
    NOT?: SongArtistScalarWhereInput | SongArtistScalarWhereInput[]
    id?: StringFilter<"SongArtist"> | string
    songId?: StringFilter<"SongArtist"> | string
    artistId?: StringFilter<"SongArtist"> | string
    role?: EnumArtistRoleFilter<"SongArtist"> | $Enums.ArtistRole
    order?: IntFilter<"SongArtist"> | number
  }

  export type ArtistGenreUpsertWithWhereUniqueWithoutArtistInput = {
    where: ArtistGenreWhereUniqueInput
    update: XOR<ArtistGenreUpdateWithoutArtistInput, ArtistGenreUncheckedUpdateWithoutArtistInput>
    create: XOR<ArtistGenreCreateWithoutArtistInput, ArtistGenreUncheckedCreateWithoutArtistInput>
  }

  export type ArtistGenreUpdateWithWhereUniqueWithoutArtistInput = {
    where: ArtistGenreWhereUniqueInput
    data: XOR<ArtistGenreUpdateWithoutArtistInput, ArtistGenreUncheckedUpdateWithoutArtistInput>
  }

  export type ArtistGenreUpdateManyWithWhereWithoutArtistInput = {
    where: ArtistGenreScalarWhereInput
    data: XOR<ArtistGenreUpdateManyMutationInput, ArtistGenreUncheckedUpdateManyWithoutArtistInput>
  }

  export type ArtistGenreScalarWhereInput = {
    AND?: ArtistGenreScalarWhereInput | ArtistGenreScalarWhereInput[]
    OR?: ArtistGenreScalarWhereInput[]
    NOT?: ArtistGenreScalarWhereInput | ArtistGenreScalarWhereInput[]
    artistId?: StringFilter<"ArtistGenre"> | string
    genreId?: StringFilter<"ArtistGenre"> | string
  }

  export type UserLikedArtistUpsertWithWhereUniqueWithoutArtistInput = {
    where: UserLikedArtistWhereUniqueInput
    update: XOR<UserLikedArtistUpdateWithoutArtistInput, UserLikedArtistUncheckedUpdateWithoutArtistInput>
    create: XOR<UserLikedArtistCreateWithoutArtistInput, UserLikedArtistUncheckedCreateWithoutArtistInput>
  }

  export type UserLikedArtistUpdateWithWhereUniqueWithoutArtistInput = {
    where: UserLikedArtistWhereUniqueInput
    data: XOR<UserLikedArtistUpdateWithoutArtistInput, UserLikedArtistUncheckedUpdateWithoutArtistInput>
  }

  export type UserLikedArtistUpdateManyWithWhereWithoutArtistInput = {
    where: UserLikedArtistScalarWhereInput
    data: XOR<UserLikedArtistUpdateManyMutationInput, UserLikedArtistUncheckedUpdateManyWithoutArtistInput>
  }

  export type SongCreditUpsertWithWhereUniqueWithoutArtistInput = {
    where: SongCreditWhereUniqueInput
    update: XOR<SongCreditUpdateWithoutArtistInput, SongCreditUncheckedUpdateWithoutArtistInput>
    create: XOR<SongCreditCreateWithoutArtistInput, SongCreditUncheckedCreateWithoutArtistInput>
  }

  export type SongCreditUpdateWithWhereUniqueWithoutArtistInput = {
    where: SongCreditWhereUniqueInput
    data: XOR<SongCreditUpdateWithoutArtistInput, SongCreditUncheckedUpdateWithoutArtistInput>
  }

  export type SongCreditUpdateManyWithWhereWithoutArtistInput = {
    where: SongCreditScalarWhereInput
    data: XOR<SongCreditUpdateManyMutationInput, SongCreditUncheckedUpdateManyWithoutArtistInput>
  }

  export type SongCreditScalarWhereInput = {
    AND?: SongCreditScalarWhereInput | SongCreditScalarWhereInput[]
    OR?: SongCreditScalarWhereInput[]
    NOT?: SongCreditScalarWhereInput | SongCreditScalarWhereInput[]
    id?: StringFilter<"SongCredit"> | string
    songId?: StringFilter<"SongCredit"> | string
    artistId?: StringNullableFilter<"SongCredit"> | string | null
    name?: StringFilter<"SongCredit"> | string
    role?: EnumCreditRoleFilter<"SongCredit"> | $Enums.CreditRole
    details?: StringNullableFilter<"SongCredit"> | string | null
    order?: IntFilter<"SongCredit"> | number
  }

  export type ArtistCreateWithoutAlbumsInput = {
    id?: string
    name: string
    slug: string
    bio?: string | null
    imageId: string
    verified?: boolean
    monthlyListeners?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    songs?: SongArtistCreateNestedManyWithoutArtistInput
    genres?: ArtistGenreCreateNestedManyWithoutArtistInput
    likedBy?: UserLikedArtistCreateNestedManyWithoutArtistInput
    credits?: SongCreditCreateNestedManyWithoutArtistInput
  }

  export type ArtistUncheckedCreateWithoutAlbumsInput = {
    id?: string
    name: string
    slug: string
    bio?: string | null
    imageId: string
    verified?: boolean
    monthlyListeners?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    songs?: SongArtistUncheckedCreateNestedManyWithoutArtistInput
    genres?: ArtistGenreUncheckedCreateNestedManyWithoutArtistInput
    likedBy?: UserLikedArtistUncheckedCreateNestedManyWithoutArtistInput
    credits?: SongCreditUncheckedCreateNestedManyWithoutArtistInput
  }

  export type ArtistCreateOrConnectWithoutAlbumsInput = {
    where: ArtistWhereUniqueInput
    create: XOR<ArtistCreateWithoutAlbumsInput, ArtistUncheckedCreateWithoutAlbumsInput>
  }

  export type SongCreateWithoutAlbumInput = {
    id?: string
    title: string
    slug: string
    audioId: string
    duration: number
    trackNumber: number
    lyrics?: string | null
    isExplicit?: boolean
    playCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    artists?: SongArtistCreateNestedManyWithoutSongInput
    credits?: SongCreditCreateNestedManyWithoutSongInput
    genres?: SongGenreCreateNestedManyWithoutSongInput
    likedBy?: UserLikedSongCreateNestedManyWithoutSongInput
    playlistItems?: PlaylistItemCreateNestedManyWithoutSongInput
    playHistory?: PlayHistoryCreateNestedManyWithoutSongInput
  }

  export type SongUncheckedCreateWithoutAlbumInput = {
    id?: string
    title: string
    slug: string
    audioId: string
    duration: number
    trackNumber: number
    lyrics?: string | null
    isExplicit?: boolean
    playCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    artists?: SongArtistUncheckedCreateNestedManyWithoutSongInput
    credits?: SongCreditUncheckedCreateNestedManyWithoutSongInput
    genres?: SongGenreUncheckedCreateNestedManyWithoutSongInput
    likedBy?: UserLikedSongUncheckedCreateNestedManyWithoutSongInput
    playlistItems?: PlaylistItemUncheckedCreateNestedManyWithoutSongInput
    playHistory?: PlayHistoryUncheckedCreateNestedManyWithoutSongInput
  }

  export type SongCreateOrConnectWithoutAlbumInput = {
    where: SongWhereUniqueInput
    create: XOR<SongCreateWithoutAlbumInput, SongUncheckedCreateWithoutAlbumInput>
  }

  export type SongCreateManyAlbumInputEnvelope = {
    data: SongCreateManyAlbumInput | SongCreateManyAlbumInput[]
    skipDuplicates?: boolean
  }

  export type AlbumGenreCreateWithoutAlbumInput = {
    genre: GenreCreateNestedOneWithoutAlbumsInput
  }

  export type AlbumGenreUncheckedCreateWithoutAlbumInput = {
    genreId: string
  }

  export type AlbumGenreCreateOrConnectWithoutAlbumInput = {
    where: AlbumGenreWhereUniqueInput
    create: XOR<AlbumGenreCreateWithoutAlbumInput, AlbumGenreUncheckedCreateWithoutAlbumInput>
  }

  export type AlbumGenreCreateManyAlbumInputEnvelope = {
    data: AlbumGenreCreateManyAlbumInput | AlbumGenreCreateManyAlbumInput[]
    skipDuplicates?: boolean
  }

  export type UserLikedAlbumCreateWithoutAlbumInput = {
    likedAt?: Date | string
    user: UserCreateNestedOneWithoutLikedAlbumsInput
  }

  export type UserLikedAlbumUncheckedCreateWithoutAlbumInput = {
    userId: string
    likedAt?: Date | string
  }

  export type UserLikedAlbumCreateOrConnectWithoutAlbumInput = {
    where: UserLikedAlbumWhereUniqueInput
    create: XOR<UserLikedAlbumCreateWithoutAlbumInput, UserLikedAlbumUncheckedCreateWithoutAlbumInput>
  }

  export type UserLikedAlbumCreateManyAlbumInputEnvelope = {
    data: UserLikedAlbumCreateManyAlbumInput | UserLikedAlbumCreateManyAlbumInput[]
    skipDuplicates?: boolean
  }

  export type ArtistUpsertWithoutAlbumsInput = {
    update: XOR<ArtistUpdateWithoutAlbumsInput, ArtistUncheckedUpdateWithoutAlbumsInput>
    create: XOR<ArtistCreateWithoutAlbumsInput, ArtistUncheckedCreateWithoutAlbumsInput>
    where?: ArtistWhereInput
  }

  export type ArtistUpdateToOneWithWhereWithoutAlbumsInput = {
    where?: ArtistWhereInput
    data: XOR<ArtistUpdateWithoutAlbumsInput, ArtistUncheckedUpdateWithoutAlbumsInput>
  }

  export type ArtistUpdateWithoutAlbumsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    songs?: SongArtistUpdateManyWithoutArtistNestedInput
    genres?: ArtistGenreUpdateManyWithoutArtistNestedInput
    likedBy?: UserLikedArtistUpdateManyWithoutArtistNestedInput
    credits?: SongCreditUpdateManyWithoutArtistNestedInput
  }

  export type ArtistUncheckedUpdateWithoutAlbumsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    songs?: SongArtistUncheckedUpdateManyWithoutArtistNestedInput
    genres?: ArtistGenreUncheckedUpdateManyWithoutArtistNestedInput
    likedBy?: UserLikedArtistUncheckedUpdateManyWithoutArtistNestedInput
    credits?: SongCreditUncheckedUpdateManyWithoutArtistNestedInput
  }

  export type SongUpsertWithWhereUniqueWithoutAlbumInput = {
    where: SongWhereUniqueInput
    update: XOR<SongUpdateWithoutAlbumInput, SongUncheckedUpdateWithoutAlbumInput>
    create: XOR<SongCreateWithoutAlbumInput, SongUncheckedCreateWithoutAlbumInput>
  }

  export type SongUpdateWithWhereUniqueWithoutAlbumInput = {
    where: SongWhereUniqueInput
    data: XOR<SongUpdateWithoutAlbumInput, SongUncheckedUpdateWithoutAlbumInput>
  }

  export type SongUpdateManyWithWhereWithoutAlbumInput = {
    where: SongScalarWhereInput
    data: XOR<SongUpdateManyMutationInput, SongUncheckedUpdateManyWithoutAlbumInput>
  }

  export type SongScalarWhereInput = {
    AND?: SongScalarWhereInput | SongScalarWhereInput[]
    OR?: SongScalarWhereInput[]
    NOT?: SongScalarWhereInput | SongScalarWhereInput[]
    id?: StringFilter<"Song"> | string
    title?: StringFilter<"Song"> | string
    slug?: StringFilter<"Song"> | string
    audioId?: StringFilter<"Song"> | string
    duration?: IntFilter<"Song"> | number
    trackNumber?: IntFilter<"Song"> | number
    lyrics?: StringNullableFilter<"Song"> | string | null
    isExplicit?: BoolFilter<"Song"> | boolean
    playCount?: IntFilter<"Song"> | number
    createdAt?: DateTimeFilter<"Song"> | Date | string
    updatedAt?: DateTimeFilter<"Song"> | Date | string
    albumId?: StringFilter<"Song"> | string
  }

  export type AlbumGenreUpsertWithWhereUniqueWithoutAlbumInput = {
    where: AlbumGenreWhereUniqueInput
    update: XOR<AlbumGenreUpdateWithoutAlbumInput, AlbumGenreUncheckedUpdateWithoutAlbumInput>
    create: XOR<AlbumGenreCreateWithoutAlbumInput, AlbumGenreUncheckedCreateWithoutAlbumInput>
  }

  export type AlbumGenreUpdateWithWhereUniqueWithoutAlbumInput = {
    where: AlbumGenreWhereUniqueInput
    data: XOR<AlbumGenreUpdateWithoutAlbumInput, AlbumGenreUncheckedUpdateWithoutAlbumInput>
  }

  export type AlbumGenreUpdateManyWithWhereWithoutAlbumInput = {
    where: AlbumGenreScalarWhereInput
    data: XOR<AlbumGenreUpdateManyMutationInput, AlbumGenreUncheckedUpdateManyWithoutAlbumInput>
  }

  export type AlbumGenreScalarWhereInput = {
    AND?: AlbumGenreScalarWhereInput | AlbumGenreScalarWhereInput[]
    OR?: AlbumGenreScalarWhereInput[]
    NOT?: AlbumGenreScalarWhereInput | AlbumGenreScalarWhereInput[]
    albumId?: StringFilter<"AlbumGenre"> | string
    genreId?: StringFilter<"AlbumGenre"> | string
  }

  export type UserLikedAlbumUpsertWithWhereUniqueWithoutAlbumInput = {
    where: UserLikedAlbumWhereUniqueInput
    update: XOR<UserLikedAlbumUpdateWithoutAlbumInput, UserLikedAlbumUncheckedUpdateWithoutAlbumInput>
    create: XOR<UserLikedAlbumCreateWithoutAlbumInput, UserLikedAlbumUncheckedCreateWithoutAlbumInput>
  }

  export type UserLikedAlbumUpdateWithWhereUniqueWithoutAlbumInput = {
    where: UserLikedAlbumWhereUniqueInput
    data: XOR<UserLikedAlbumUpdateWithoutAlbumInput, UserLikedAlbumUncheckedUpdateWithoutAlbumInput>
  }

  export type UserLikedAlbumUpdateManyWithWhereWithoutAlbumInput = {
    where: UserLikedAlbumScalarWhereInput
    data: XOR<UserLikedAlbumUpdateManyMutationInput, UserLikedAlbumUncheckedUpdateManyWithoutAlbumInput>
  }

  export type AlbumCreateWithoutSongsInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    imageId: string
    albumType?: $Enums.AlbumType
    releaseDate?: Date | string
    totalTracks?: number
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    artist: ArtistCreateNestedOneWithoutAlbumsInput
    genres?: AlbumGenreCreateNestedManyWithoutAlbumInput
    likedBy?: UserLikedAlbumCreateNestedManyWithoutAlbumInput
  }

  export type AlbumUncheckedCreateWithoutSongsInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    imageId: string
    albumType?: $Enums.AlbumType
    releaseDate?: Date | string
    totalTracks?: number
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    artistId: string
    genres?: AlbumGenreUncheckedCreateNestedManyWithoutAlbumInput
    likedBy?: UserLikedAlbumUncheckedCreateNestedManyWithoutAlbumInput
  }

  export type AlbumCreateOrConnectWithoutSongsInput = {
    where: AlbumWhereUniqueInput
    create: XOR<AlbumCreateWithoutSongsInput, AlbumUncheckedCreateWithoutSongsInput>
  }

  export type SongArtistCreateWithoutSongInput = {
    id?: string
    role?: $Enums.ArtistRole
    order?: number
    artist: ArtistCreateNestedOneWithoutSongsInput
  }

  export type SongArtistUncheckedCreateWithoutSongInput = {
    id?: string
    artistId: string
    role?: $Enums.ArtistRole
    order?: number
  }

  export type SongArtistCreateOrConnectWithoutSongInput = {
    where: SongArtistWhereUniqueInput
    create: XOR<SongArtistCreateWithoutSongInput, SongArtistUncheckedCreateWithoutSongInput>
  }

  export type SongArtistCreateManySongInputEnvelope = {
    data: SongArtistCreateManySongInput | SongArtistCreateManySongInput[]
    skipDuplicates?: boolean
  }

  export type SongCreditCreateWithoutSongInput = {
    id?: string
    name: string
    role: $Enums.CreditRole
    details?: string | null
    order?: number
    artist?: ArtistCreateNestedOneWithoutCreditsInput
  }

  export type SongCreditUncheckedCreateWithoutSongInput = {
    id?: string
    artistId?: string | null
    name: string
    role: $Enums.CreditRole
    details?: string | null
    order?: number
  }

  export type SongCreditCreateOrConnectWithoutSongInput = {
    where: SongCreditWhereUniqueInput
    create: XOR<SongCreditCreateWithoutSongInput, SongCreditUncheckedCreateWithoutSongInput>
  }

  export type SongCreditCreateManySongInputEnvelope = {
    data: SongCreditCreateManySongInput | SongCreditCreateManySongInput[]
    skipDuplicates?: boolean
  }

  export type SongGenreCreateWithoutSongInput = {
    genre: GenreCreateNestedOneWithoutSongsInput
  }

  export type SongGenreUncheckedCreateWithoutSongInput = {
    genreId: string
  }

  export type SongGenreCreateOrConnectWithoutSongInput = {
    where: SongGenreWhereUniqueInput
    create: XOR<SongGenreCreateWithoutSongInput, SongGenreUncheckedCreateWithoutSongInput>
  }

  export type SongGenreCreateManySongInputEnvelope = {
    data: SongGenreCreateManySongInput | SongGenreCreateManySongInput[]
    skipDuplicates?: boolean
  }

  export type UserLikedSongCreateWithoutSongInput = {
    likedAt?: Date | string
    user: UserCreateNestedOneWithoutLikedSongsInput
  }

  export type UserLikedSongUncheckedCreateWithoutSongInput = {
    userId: string
    likedAt?: Date | string
  }

  export type UserLikedSongCreateOrConnectWithoutSongInput = {
    where: UserLikedSongWhereUniqueInput
    create: XOR<UserLikedSongCreateWithoutSongInput, UserLikedSongUncheckedCreateWithoutSongInput>
  }

  export type UserLikedSongCreateManySongInputEnvelope = {
    data: UserLikedSongCreateManySongInput | UserLikedSongCreateManySongInput[]
    skipDuplicates?: boolean
  }

  export type PlaylistItemCreateWithoutSongInput = {
    id?: string
    position: number
    addedAt?: Date | string
    playlist: PlaylistCreateNestedOneWithoutItemsInput
  }

  export type PlaylistItemUncheckedCreateWithoutSongInput = {
    id?: string
    position: number
    addedAt?: Date | string
    playlistId: string
  }

  export type PlaylistItemCreateOrConnectWithoutSongInput = {
    where: PlaylistItemWhereUniqueInput
    create: XOR<PlaylistItemCreateWithoutSongInput, PlaylistItemUncheckedCreateWithoutSongInput>
  }

  export type PlaylistItemCreateManySongInputEnvelope = {
    data: PlaylistItemCreateManySongInput | PlaylistItemCreateManySongInput[]
    skipDuplicates?: boolean
  }

  export type PlayHistoryCreateWithoutSongInput = {
    id?: string
    playedAt?: Date | string
    duration: number
    deviceType?: string | null
    user: UserCreateNestedOneWithoutPlayHistoryInput
  }

  export type PlayHistoryUncheckedCreateWithoutSongInput = {
    id?: string
    playedAt?: Date | string
    duration: number
    deviceType?: string | null
    userId: string
  }

  export type PlayHistoryCreateOrConnectWithoutSongInput = {
    where: PlayHistoryWhereUniqueInput
    create: XOR<PlayHistoryCreateWithoutSongInput, PlayHistoryUncheckedCreateWithoutSongInput>
  }

  export type PlayHistoryCreateManySongInputEnvelope = {
    data: PlayHistoryCreateManySongInput | PlayHistoryCreateManySongInput[]
    skipDuplicates?: boolean
  }

  export type AlbumUpsertWithoutSongsInput = {
    update: XOR<AlbumUpdateWithoutSongsInput, AlbumUncheckedUpdateWithoutSongsInput>
    create: XOR<AlbumCreateWithoutSongsInput, AlbumUncheckedCreateWithoutSongsInput>
    where?: AlbumWhereInput
  }

  export type AlbumUpdateToOneWithWhereWithoutSongsInput = {
    where?: AlbumWhereInput
    data: XOR<AlbumUpdateWithoutSongsInput, AlbumUncheckedUpdateWithoutSongsInput>
  }

  export type AlbumUpdateWithoutSongsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: StringFieldUpdateOperationsInput | string
    albumType?: EnumAlbumTypeFieldUpdateOperationsInput | $Enums.AlbumType
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalTracks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUpdateOneRequiredWithoutAlbumsNestedInput
    genres?: AlbumGenreUpdateManyWithoutAlbumNestedInput
    likedBy?: UserLikedAlbumUpdateManyWithoutAlbumNestedInput
  }

  export type AlbumUncheckedUpdateWithoutSongsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: StringFieldUpdateOperationsInput | string
    albumType?: EnumAlbumTypeFieldUpdateOperationsInput | $Enums.AlbumType
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalTracks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artistId?: StringFieldUpdateOperationsInput | string
    genres?: AlbumGenreUncheckedUpdateManyWithoutAlbumNestedInput
    likedBy?: UserLikedAlbumUncheckedUpdateManyWithoutAlbumNestedInput
  }

  export type SongArtistUpsertWithWhereUniqueWithoutSongInput = {
    where: SongArtistWhereUniqueInput
    update: XOR<SongArtistUpdateWithoutSongInput, SongArtistUncheckedUpdateWithoutSongInput>
    create: XOR<SongArtistCreateWithoutSongInput, SongArtistUncheckedCreateWithoutSongInput>
  }

  export type SongArtistUpdateWithWhereUniqueWithoutSongInput = {
    where: SongArtistWhereUniqueInput
    data: XOR<SongArtistUpdateWithoutSongInput, SongArtistUncheckedUpdateWithoutSongInput>
  }

  export type SongArtistUpdateManyWithWhereWithoutSongInput = {
    where: SongArtistScalarWhereInput
    data: XOR<SongArtistUpdateManyMutationInput, SongArtistUncheckedUpdateManyWithoutSongInput>
  }

  export type SongCreditUpsertWithWhereUniqueWithoutSongInput = {
    where: SongCreditWhereUniqueInput
    update: XOR<SongCreditUpdateWithoutSongInput, SongCreditUncheckedUpdateWithoutSongInput>
    create: XOR<SongCreditCreateWithoutSongInput, SongCreditUncheckedCreateWithoutSongInput>
  }

  export type SongCreditUpdateWithWhereUniqueWithoutSongInput = {
    where: SongCreditWhereUniqueInput
    data: XOR<SongCreditUpdateWithoutSongInput, SongCreditUncheckedUpdateWithoutSongInput>
  }

  export type SongCreditUpdateManyWithWhereWithoutSongInput = {
    where: SongCreditScalarWhereInput
    data: XOR<SongCreditUpdateManyMutationInput, SongCreditUncheckedUpdateManyWithoutSongInput>
  }

  export type SongGenreUpsertWithWhereUniqueWithoutSongInput = {
    where: SongGenreWhereUniqueInput
    update: XOR<SongGenreUpdateWithoutSongInput, SongGenreUncheckedUpdateWithoutSongInput>
    create: XOR<SongGenreCreateWithoutSongInput, SongGenreUncheckedCreateWithoutSongInput>
  }

  export type SongGenreUpdateWithWhereUniqueWithoutSongInput = {
    where: SongGenreWhereUniqueInput
    data: XOR<SongGenreUpdateWithoutSongInput, SongGenreUncheckedUpdateWithoutSongInput>
  }

  export type SongGenreUpdateManyWithWhereWithoutSongInput = {
    where: SongGenreScalarWhereInput
    data: XOR<SongGenreUpdateManyMutationInput, SongGenreUncheckedUpdateManyWithoutSongInput>
  }

  export type SongGenreScalarWhereInput = {
    AND?: SongGenreScalarWhereInput | SongGenreScalarWhereInput[]
    OR?: SongGenreScalarWhereInput[]
    NOT?: SongGenreScalarWhereInput | SongGenreScalarWhereInput[]
    songId?: StringFilter<"SongGenre"> | string
    genreId?: StringFilter<"SongGenre"> | string
  }

  export type UserLikedSongUpsertWithWhereUniqueWithoutSongInput = {
    where: UserLikedSongWhereUniqueInput
    update: XOR<UserLikedSongUpdateWithoutSongInput, UserLikedSongUncheckedUpdateWithoutSongInput>
    create: XOR<UserLikedSongCreateWithoutSongInput, UserLikedSongUncheckedCreateWithoutSongInput>
  }

  export type UserLikedSongUpdateWithWhereUniqueWithoutSongInput = {
    where: UserLikedSongWhereUniqueInput
    data: XOR<UserLikedSongUpdateWithoutSongInput, UserLikedSongUncheckedUpdateWithoutSongInput>
  }

  export type UserLikedSongUpdateManyWithWhereWithoutSongInput = {
    where: UserLikedSongScalarWhereInput
    data: XOR<UserLikedSongUpdateManyMutationInput, UserLikedSongUncheckedUpdateManyWithoutSongInput>
  }

  export type PlaylistItemUpsertWithWhereUniqueWithoutSongInput = {
    where: PlaylistItemWhereUniqueInput
    update: XOR<PlaylistItemUpdateWithoutSongInput, PlaylistItemUncheckedUpdateWithoutSongInput>
    create: XOR<PlaylistItemCreateWithoutSongInput, PlaylistItemUncheckedCreateWithoutSongInput>
  }

  export type PlaylistItemUpdateWithWhereUniqueWithoutSongInput = {
    where: PlaylistItemWhereUniqueInput
    data: XOR<PlaylistItemUpdateWithoutSongInput, PlaylistItemUncheckedUpdateWithoutSongInput>
  }

  export type PlaylistItemUpdateManyWithWhereWithoutSongInput = {
    where: PlaylistItemScalarWhereInput
    data: XOR<PlaylistItemUpdateManyMutationInput, PlaylistItemUncheckedUpdateManyWithoutSongInput>
  }

  export type PlaylistItemScalarWhereInput = {
    AND?: PlaylistItemScalarWhereInput | PlaylistItemScalarWhereInput[]
    OR?: PlaylistItemScalarWhereInput[]
    NOT?: PlaylistItemScalarWhereInput | PlaylistItemScalarWhereInput[]
    id?: StringFilter<"PlaylistItem"> | string
    position?: IntFilter<"PlaylistItem"> | number
    addedAt?: DateTimeFilter<"PlaylistItem"> | Date | string
    playlistId?: StringFilter<"PlaylistItem"> | string
    songId?: StringFilter<"PlaylistItem"> | string
  }

  export type PlayHistoryUpsertWithWhereUniqueWithoutSongInput = {
    where: PlayHistoryWhereUniqueInput
    update: XOR<PlayHistoryUpdateWithoutSongInput, PlayHistoryUncheckedUpdateWithoutSongInput>
    create: XOR<PlayHistoryCreateWithoutSongInput, PlayHistoryUncheckedCreateWithoutSongInput>
  }

  export type PlayHistoryUpdateWithWhereUniqueWithoutSongInput = {
    where: PlayHistoryWhereUniqueInput
    data: XOR<PlayHistoryUpdateWithoutSongInput, PlayHistoryUncheckedUpdateWithoutSongInput>
  }

  export type PlayHistoryUpdateManyWithWhereWithoutSongInput = {
    where: PlayHistoryScalarWhereInput
    data: XOR<PlayHistoryUpdateManyMutationInput, PlayHistoryUncheckedUpdateManyWithoutSongInput>
  }

  export type SongGenreCreateWithoutGenreInput = {
    song: SongCreateNestedOneWithoutGenresInput
  }

  export type SongGenreUncheckedCreateWithoutGenreInput = {
    songId: string
  }

  export type SongGenreCreateOrConnectWithoutGenreInput = {
    where: SongGenreWhereUniqueInput
    create: XOR<SongGenreCreateWithoutGenreInput, SongGenreUncheckedCreateWithoutGenreInput>
  }

  export type SongGenreCreateManyGenreInputEnvelope = {
    data: SongGenreCreateManyGenreInput | SongGenreCreateManyGenreInput[]
    skipDuplicates?: boolean
  }

  export type AlbumGenreCreateWithoutGenreInput = {
    album: AlbumCreateNestedOneWithoutGenresInput
  }

  export type AlbumGenreUncheckedCreateWithoutGenreInput = {
    albumId: string
  }

  export type AlbumGenreCreateOrConnectWithoutGenreInput = {
    where: AlbumGenreWhereUniqueInput
    create: XOR<AlbumGenreCreateWithoutGenreInput, AlbumGenreUncheckedCreateWithoutGenreInput>
  }

  export type AlbumGenreCreateManyGenreInputEnvelope = {
    data: AlbumGenreCreateManyGenreInput | AlbumGenreCreateManyGenreInput[]
    skipDuplicates?: boolean
  }

  export type ArtistGenreCreateWithoutGenreInput = {
    artist: ArtistCreateNestedOneWithoutGenresInput
  }

  export type ArtistGenreUncheckedCreateWithoutGenreInput = {
    artistId: string
  }

  export type ArtistGenreCreateOrConnectWithoutGenreInput = {
    where: ArtistGenreWhereUniqueInput
    create: XOR<ArtistGenreCreateWithoutGenreInput, ArtistGenreUncheckedCreateWithoutGenreInput>
  }

  export type ArtistGenreCreateManyGenreInputEnvelope = {
    data: ArtistGenreCreateManyGenreInput | ArtistGenreCreateManyGenreInput[]
    skipDuplicates?: boolean
  }

  export type SongGenreUpsertWithWhereUniqueWithoutGenreInput = {
    where: SongGenreWhereUniqueInput
    update: XOR<SongGenreUpdateWithoutGenreInput, SongGenreUncheckedUpdateWithoutGenreInput>
    create: XOR<SongGenreCreateWithoutGenreInput, SongGenreUncheckedCreateWithoutGenreInput>
  }

  export type SongGenreUpdateWithWhereUniqueWithoutGenreInput = {
    where: SongGenreWhereUniqueInput
    data: XOR<SongGenreUpdateWithoutGenreInput, SongGenreUncheckedUpdateWithoutGenreInput>
  }

  export type SongGenreUpdateManyWithWhereWithoutGenreInput = {
    where: SongGenreScalarWhereInput
    data: XOR<SongGenreUpdateManyMutationInput, SongGenreUncheckedUpdateManyWithoutGenreInput>
  }

  export type AlbumGenreUpsertWithWhereUniqueWithoutGenreInput = {
    where: AlbumGenreWhereUniqueInput
    update: XOR<AlbumGenreUpdateWithoutGenreInput, AlbumGenreUncheckedUpdateWithoutGenreInput>
    create: XOR<AlbumGenreCreateWithoutGenreInput, AlbumGenreUncheckedCreateWithoutGenreInput>
  }

  export type AlbumGenreUpdateWithWhereUniqueWithoutGenreInput = {
    where: AlbumGenreWhereUniqueInput
    data: XOR<AlbumGenreUpdateWithoutGenreInput, AlbumGenreUncheckedUpdateWithoutGenreInput>
  }

  export type AlbumGenreUpdateManyWithWhereWithoutGenreInput = {
    where: AlbumGenreScalarWhereInput
    data: XOR<AlbumGenreUpdateManyMutationInput, AlbumGenreUncheckedUpdateManyWithoutGenreInput>
  }

  export type ArtistGenreUpsertWithWhereUniqueWithoutGenreInput = {
    where: ArtistGenreWhereUniqueInput
    update: XOR<ArtistGenreUpdateWithoutGenreInput, ArtistGenreUncheckedUpdateWithoutGenreInput>
    create: XOR<ArtistGenreCreateWithoutGenreInput, ArtistGenreUncheckedCreateWithoutGenreInput>
  }

  export type ArtistGenreUpdateWithWhereUniqueWithoutGenreInput = {
    where: ArtistGenreWhereUniqueInput
    data: XOR<ArtistGenreUpdateWithoutGenreInput, ArtistGenreUncheckedUpdateWithoutGenreInput>
  }

  export type ArtistGenreUpdateManyWithWhereWithoutGenreInput = {
    where: ArtistGenreScalarWhereInput
    data: XOR<ArtistGenreUpdateManyMutationInput, ArtistGenreUncheckedUpdateManyWithoutGenreInput>
  }

  export type SongCreateWithoutArtistsInput = {
    id?: string
    title: string
    slug: string
    audioId: string
    duration: number
    trackNumber: number
    lyrics?: string | null
    isExplicit?: boolean
    playCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    album: AlbumCreateNestedOneWithoutSongsInput
    credits?: SongCreditCreateNestedManyWithoutSongInput
    genres?: SongGenreCreateNestedManyWithoutSongInput
    likedBy?: UserLikedSongCreateNestedManyWithoutSongInput
    playlistItems?: PlaylistItemCreateNestedManyWithoutSongInput
    playHistory?: PlayHistoryCreateNestedManyWithoutSongInput
  }

  export type SongUncheckedCreateWithoutArtistsInput = {
    id?: string
    title: string
    slug: string
    audioId: string
    duration: number
    trackNumber: number
    lyrics?: string | null
    isExplicit?: boolean
    playCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    albumId: string
    credits?: SongCreditUncheckedCreateNestedManyWithoutSongInput
    genres?: SongGenreUncheckedCreateNestedManyWithoutSongInput
    likedBy?: UserLikedSongUncheckedCreateNestedManyWithoutSongInput
    playlistItems?: PlaylistItemUncheckedCreateNestedManyWithoutSongInput
    playHistory?: PlayHistoryUncheckedCreateNestedManyWithoutSongInput
  }

  export type SongCreateOrConnectWithoutArtistsInput = {
    where: SongWhereUniqueInput
    create: XOR<SongCreateWithoutArtistsInput, SongUncheckedCreateWithoutArtistsInput>
  }

  export type ArtistCreateWithoutSongsInput = {
    id?: string
    name: string
    slug: string
    bio?: string | null
    imageId: string
    verified?: boolean
    monthlyListeners?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    albums?: AlbumCreateNestedManyWithoutArtistInput
    genres?: ArtistGenreCreateNestedManyWithoutArtistInput
    likedBy?: UserLikedArtistCreateNestedManyWithoutArtistInput
    credits?: SongCreditCreateNestedManyWithoutArtistInput
  }

  export type ArtistUncheckedCreateWithoutSongsInput = {
    id?: string
    name: string
    slug: string
    bio?: string | null
    imageId: string
    verified?: boolean
    monthlyListeners?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    albums?: AlbumUncheckedCreateNestedManyWithoutArtistInput
    genres?: ArtistGenreUncheckedCreateNestedManyWithoutArtistInput
    likedBy?: UserLikedArtistUncheckedCreateNestedManyWithoutArtistInput
    credits?: SongCreditUncheckedCreateNestedManyWithoutArtistInput
  }

  export type ArtistCreateOrConnectWithoutSongsInput = {
    where: ArtistWhereUniqueInput
    create: XOR<ArtistCreateWithoutSongsInput, ArtistUncheckedCreateWithoutSongsInput>
  }

  export type SongUpsertWithoutArtistsInput = {
    update: XOR<SongUpdateWithoutArtistsInput, SongUncheckedUpdateWithoutArtistsInput>
    create: XOR<SongCreateWithoutArtistsInput, SongUncheckedCreateWithoutArtistsInput>
    where?: SongWhereInput
  }

  export type SongUpdateToOneWithWhereWithoutArtistsInput = {
    where?: SongWhereInput
    data: XOR<SongUpdateWithoutArtistsInput, SongUncheckedUpdateWithoutArtistsInput>
  }

  export type SongUpdateWithoutArtistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    trackNumber?: IntFieldUpdateOperationsInput | number
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    album?: AlbumUpdateOneRequiredWithoutSongsNestedInput
    credits?: SongCreditUpdateManyWithoutSongNestedInput
    genres?: SongGenreUpdateManyWithoutSongNestedInput
    likedBy?: UserLikedSongUpdateManyWithoutSongNestedInput
    playlistItems?: PlaylistItemUpdateManyWithoutSongNestedInput
    playHistory?: PlayHistoryUpdateManyWithoutSongNestedInput
  }

  export type SongUncheckedUpdateWithoutArtistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    trackNumber?: IntFieldUpdateOperationsInput | number
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albumId?: StringFieldUpdateOperationsInput | string
    credits?: SongCreditUncheckedUpdateManyWithoutSongNestedInput
    genres?: SongGenreUncheckedUpdateManyWithoutSongNestedInput
    likedBy?: UserLikedSongUncheckedUpdateManyWithoutSongNestedInput
    playlistItems?: PlaylistItemUncheckedUpdateManyWithoutSongNestedInput
    playHistory?: PlayHistoryUncheckedUpdateManyWithoutSongNestedInput
  }

  export type ArtistUpsertWithoutSongsInput = {
    update: XOR<ArtistUpdateWithoutSongsInput, ArtistUncheckedUpdateWithoutSongsInput>
    create: XOR<ArtistCreateWithoutSongsInput, ArtistUncheckedCreateWithoutSongsInput>
    where?: ArtistWhereInput
  }

  export type ArtistUpdateToOneWithWhereWithoutSongsInput = {
    where?: ArtistWhereInput
    data: XOR<ArtistUpdateWithoutSongsInput, ArtistUncheckedUpdateWithoutSongsInput>
  }

  export type ArtistUpdateWithoutSongsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albums?: AlbumUpdateManyWithoutArtistNestedInput
    genres?: ArtistGenreUpdateManyWithoutArtistNestedInput
    likedBy?: UserLikedArtistUpdateManyWithoutArtistNestedInput
    credits?: SongCreditUpdateManyWithoutArtistNestedInput
  }

  export type ArtistUncheckedUpdateWithoutSongsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albums?: AlbumUncheckedUpdateManyWithoutArtistNestedInput
    genres?: ArtistGenreUncheckedUpdateManyWithoutArtistNestedInput
    likedBy?: UserLikedArtistUncheckedUpdateManyWithoutArtistNestedInput
    credits?: SongCreditUncheckedUpdateManyWithoutArtistNestedInput
  }

  export type SongCreateWithoutCreditsInput = {
    id?: string
    title: string
    slug: string
    audioId: string
    duration: number
    trackNumber: number
    lyrics?: string | null
    isExplicit?: boolean
    playCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    album: AlbumCreateNestedOneWithoutSongsInput
    artists?: SongArtistCreateNestedManyWithoutSongInput
    genres?: SongGenreCreateNestedManyWithoutSongInput
    likedBy?: UserLikedSongCreateNestedManyWithoutSongInput
    playlistItems?: PlaylistItemCreateNestedManyWithoutSongInput
    playHistory?: PlayHistoryCreateNestedManyWithoutSongInput
  }

  export type SongUncheckedCreateWithoutCreditsInput = {
    id?: string
    title: string
    slug: string
    audioId: string
    duration: number
    trackNumber: number
    lyrics?: string | null
    isExplicit?: boolean
    playCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    albumId: string
    artists?: SongArtistUncheckedCreateNestedManyWithoutSongInput
    genres?: SongGenreUncheckedCreateNestedManyWithoutSongInput
    likedBy?: UserLikedSongUncheckedCreateNestedManyWithoutSongInput
    playlistItems?: PlaylistItemUncheckedCreateNestedManyWithoutSongInput
    playHistory?: PlayHistoryUncheckedCreateNestedManyWithoutSongInput
  }

  export type SongCreateOrConnectWithoutCreditsInput = {
    where: SongWhereUniqueInput
    create: XOR<SongCreateWithoutCreditsInput, SongUncheckedCreateWithoutCreditsInput>
  }

  export type ArtistCreateWithoutCreditsInput = {
    id?: string
    name: string
    slug: string
    bio?: string | null
    imageId: string
    verified?: boolean
    monthlyListeners?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    albums?: AlbumCreateNestedManyWithoutArtistInput
    songs?: SongArtistCreateNestedManyWithoutArtistInput
    genres?: ArtistGenreCreateNestedManyWithoutArtistInput
    likedBy?: UserLikedArtistCreateNestedManyWithoutArtistInput
  }

  export type ArtistUncheckedCreateWithoutCreditsInput = {
    id?: string
    name: string
    slug: string
    bio?: string | null
    imageId: string
    verified?: boolean
    monthlyListeners?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    albums?: AlbumUncheckedCreateNestedManyWithoutArtistInput
    songs?: SongArtistUncheckedCreateNestedManyWithoutArtistInput
    genres?: ArtistGenreUncheckedCreateNestedManyWithoutArtistInput
    likedBy?: UserLikedArtistUncheckedCreateNestedManyWithoutArtistInput
  }

  export type ArtistCreateOrConnectWithoutCreditsInput = {
    where: ArtistWhereUniqueInput
    create: XOR<ArtistCreateWithoutCreditsInput, ArtistUncheckedCreateWithoutCreditsInput>
  }

  export type SongUpsertWithoutCreditsInput = {
    update: XOR<SongUpdateWithoutCreditsInput, SongUncheckedUpdateWithoutCreditsInput>
    create: XOR<SongCreateWithoutCreditsInput, SongUncheckedCreateWithoutCreditsInput>
    where?: SongWhereInput
  }

  export type SongUpdateToOneWithWhereWithoutCreditsInput = {
    where?: SongWhereInput
    data: XOR<SongUpdateWithoutCreditsInput, SongUncheckedUpdateWithoutCreditsInput>
  }

  export type SongUpdateWithoutCreditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    trackNumber?: IntFieldUpdateOperationsInput | number
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    album?: AlbumUpdateOneRequiredWithoutSongsNestedInput
    artists?: SongArtistUpdateManyWithoutSongNestedInput
    genres?: SongGenreUpdateManyWithoutSongNestedInput
    likedBy?: UserLikedSongUpdateManyWithoutSongNestedInput
    playlistItems?: PlaylistItemUpdateManyWithoutSongNestedInput
    playHistory?: PlayHistoryUpdateManyWithoutSongNestedInput
  }

  export type SongUncheckedUpdateWithoutCreditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    trackNumber?: IntFieldUpdateOperationsInput | number
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albumId?: StringFieldUpdateOperationsInput | string
    artists?: SongArtistUncheckedUpdateManyWithoutSongNestedInput
    genres?: SongGenreUncheckedUpdateManyWithoutSongNestedInput
    likedBy?: UserLikedSongUncheckedUpdateManyWithoutSongNestedInput
    playlistItems?: PlaylistItemUncheckedUpdateManyWithoutSongNestedInput
    playHistory?: PlayHistoryUncheckedUpdateManyWithoutSongNestedInput
  }

  export type ArtistUpsertWithoutCreditsInput = {
    update: XOR<ArtistUpdateWithoutCreditsInput, ArtistUncheckedUpdateWithoutCreditsInput>
    create: XOR<ArtistCreateWithoutCreditsInput, ArtistUncheckedCreateWithoutCreditsInput>
    where?: ArtistWhereInput
  }

  export type ArtistUpdateToOneWithWhereWithoutCreditsInput = {
    where?: ArtistWhereInput
    data: XOR<ArtistUpdateWithoutCreditsInput, ArtistUncheckedUpdateWithoutCreditsInput>
  }

  export type ArtistUpdateWithoutCreditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albums?: AlbumUpdateManyWithoutArtistNestedInput
    songs?: SongArtistUpdateManyWithoutArtistNestedInput
    genres?: ArtistGenreUpdateManyWithoutArtistNestedInput
    likedBy?: UserLikedArtistUpdateManyWithoutArtistNestedInput
  }

  export type ArtistUncheckedUpdateWithoutCreditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albums?: AlbumUncheckedUpdateManyWithoutArtistNestedInput
    songs?: SongArtistUncheckedUpdateManyWithoutArtistNestedInput
    genres?: ArtistGenreUncheckedUpdateManyWithoutArtistNestedInput
    likedBy?: UserLikedArtistUncheckedUpdateManyWithoutArtistNestedInput
  }

  export type SongCreateWithoutGenresInput = {
    id?: string
    title: string
    slug: string
    audioId: string
    duration: number
    trackNumber: number
    lyrics?: string | null
    isExplicit?: boolean
    playCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    album: AlbumCreateNestedOneWithoutSongsInput
    artists?: SongArtistCreateNestedManyWithoutSongInput
    credits?: SongCreditCreateNestedManyWithoutSongInput
    likedBy?: UserLikedSongCreateNestedManyWithoutSongInput
    playlistItems?: PlaylistItemCreateNestedManyWithoutSongInput
    playHistory?: PlayHistoryCreateNestedManyWithoutSongInput
  }

  export type SongUncheckedCreateWithoutGenresInput = {
    id?: string
    title: string
    slug: string
    audioId: string
    duration: number
    trackNumber: number
    lyrics?: string | null
    isExplicit?: boolean
    playCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    albumId: string
    artists?: SongArtistUncheckedCreateNestedManyWithoutSongInput
    credits?: SongCreditUncheckedCreateNestedManyWithoutSongInput
    likedBy?: UserLikedSongUncheckedCreateNestedManyWithoutSongInput
    playlistItems?: PlaylistItemUncheckedCreateNestedManyWithoutSongInput
    playHistory?: PlayHistoryUncheckedCreateNestedManyWithoutSongInput
  }

  export type SongCreateOrConnectWithoutGenresInput = {
    where: SongWhereUniqueInput
    create: XOR<SongCreateWithoutGenresInput, SongUncheckedCreateWithoutGenresInput>
  }

  export type GenreCreateWithoutSongsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    color?: string | null
    albums?: AlbumGenreCreateNestedManyWithoutGenreInput
    artists?: ArtistGenreCreateNestedManyWithoutGenreInput
  }

  export type GenreUncheckedCreateWithoutSongsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    color?: string | null
    albums?: AlbumGenreUncheckedCreateNestedManyWithoutGenreInput
    artists?: ArtistGenreUncheckedCreateNestedManyWithoutGenreInput
  }

  export type GenreCreateOrConnectWithoutSongsInput = {
    where: GenreWhereUniqueInput
    create: XOR<GenreCreateWithoutSongsInput, GenreUncheckedCreateWithoutSongsInput>
  }

  export type SongUpsertWithoutGenresInput = {
    update: XOR<SongUpdateWithoutGenresInput, SongUncheckedUpdateWithoutGenresInput>
    create: XOR<SongCreateWithoutGenresInput, SongUncheckedCreateWithoutGenresInput>
    where?: SongWhereInput
  }

  export type SongUpdateToOneWithWhereWithoutGenresInput = {
    where?: SongWhereInput
    data: XOR<SongUpdateWithoutGenresInput, SongUncheckedUpdateWithoutGenresInput>
  }

  export type SongUpdateWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    trackNumber?: IntFieldUpdateOperationsInput | number
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    album?: AlbumUpdateOneRequiredWithoutSongsNestedInput
    artists?: SongArtistUpdateManyWithoutSongNestedInput
    credits?: SongCreditUpdateManyWithoutSongNestedInput
    likedBy?: UserLikedSongUpdateManyWithoutSongNestedInput
    playlistItems?: PlaylistItemUpdateManyWithoutSongNestedInput
    playHistory?: PlayHistoryUpdateManyWithoutSongNestedInput
  }

  export type SongUncheckedUpdateWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    trackNumber?: IntFieldUpdateOperationsInput | number
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albumId?: StringFieldUpdateOperationsInput | string
    artists?: SongArtistUncheckedUpdateManyWithoutSongNestedInput
    credits?: SongCreditUncheckedUpdateManyWithoutSongNestedInput
    likedBy?: UserLikedSongUncheckedUpdateManyWithoutSongNestedInput
    playlistItems?: PlaylistItemUncheckedUpdateManyWithoutSongNestedInput
    playHistory?: PlayHistoryUncheckedUpdateManyWithoutSongNestedInput
  }

  export type GenreUpsertWithoutSongsInput = {
    update: XOR<GenreUpdateWithoutSongsInput, GenreUncheckedUpdateWithoutSongsInput>
    create: XOR<GenreCreateWithoutSongsInput, GenreUncheckedCreateWithoutSongsInput>
    where?: GenreWhereInput
  }

  export type GenreUpdateToOneWithWhereWithoutSongsInput = {
    where?: GenreWhereInput
    data: XOR<GenreUpdateWithoutSongsInput, GenreUncheckedUpdateWithoutSongsInput>
  }

  export type GenreUpdateWithoutSongsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    albums?: AlbumGenreUpdateManyWithoutGenreNestedInput
    artists?: ArtistGenreUpdateManyWithoutGenreNestedInput
  }

  export type GenreUncheckedUpdateWithoutSongsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    albums?: AlbumGenreUncheckedUpdateManyWithoutGenreNestedInput
    artists?: ArtistGenreUncheckedUpdateManyWithoutGenreNestedInput
  }

  export type AlbumCreateWithoutGenresInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    imageId: string
    albumType?: $Enums.AlbumType
    releaseDate?: Date | string
    totalTracks?: number
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    artist: ArtistCreateNestedOneWithoutAlbumsInput
    songs?: SongCreateNestedManyWithoutAlbumInput
    likedBy?: UserLikedAlbumCreateNestedManyWithoutAlbumInput
  }

  export type AlbumUncheckedCreateWithoutGenresInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    imageId: string
    albumType?: $Enums.AlbumType
    releaseDate?: Date | string
    totalTracks?: number
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    artistId: string
    songs?: SongUncheckedCreateNestedManyWithoutAlbumInput
    likedBy?: UserLikedAlbumUncheckedCreateNestedManyWithoutAlbumInput
  }

  export type AlbumCreateOrConnectWithoutGenresInput = {
    where: AlbumWhereUniqueInput
    create: XOR<AlbumCreateWithoutGenresInput, AlbumUncheckedCreateWithoutGenresInput>
  }

  export type GenreCreateWithoutAlbumsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    color?: string | null
    songs?: SongGenreCreateNestedManyWithoutGenreInput
    artists?: ArtistGenreCreateNestedManyWithoutGenreInput
  }

  export type GenreUncheckedCreateWithoutAlbumsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    color?: string | null
    songs?: SongGenreUncheckedCreateNestedManyWithoutGenreInput
    artists?: ArtistGenreUncheckedCreateNestedManyWithoutGenreInput
  }

  export type GenreCreateOrConnectWithoutAlbumsInput = {
    where: GenreWhereUniqueInput
    create: XOR<GenreCreateWithoutAlbumsInput, GenreUncheckedCreateWithoutAlbumsInput>
  }

  export type AlbumUpsertWithoutGenresInput = {
    update: XOR<AlbumUpdateWithoutGenresInput, AlbumUncheckedUpdateWithoutGenresInput>
    create: XOR<AlbumCreateWithoutGenresInput, AlbumUncheckedCreateWithoutGenresInput>
    where?: AlbumWhereInput
  }

  export type AlbumUpdateToOneWithWhereWithoutGenresInput = {
    where?: AlbumWhereInput
    data: XOR<AlbumUpdateWithoutGenresInput, AlbumUncheckedUpdateWithoutGenresInput>
  }

  export type AlbumUpdateWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: StringFieldUpdateOperationsInput | string
    albumType?: EnumAlbumTypeFieldUpdateOperationsInput | $Enums.AlbumType
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalTracks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUpdateOneRequiredWithoutAlbumsNestedInput
    songs?: SongUpdateManyWithoutAlbumNestedInput
    likedBy?: UserLikedAlbumUpdateManyWithoutAlbumNestedInput
  }

  export type AlbumUncheckedUpdateWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: StringFieldUpdateOperationsInput | string
    albumType?: EnumAlbumTypeFieldUpdateOperationsInput | $Enums.AlbumType
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalTracks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artistId?: StringFieldUpdateOperationsInput | string
    songs?: SongUncheckedUpdateManyWithoutAlbumNestedInput
    likedBy?: UserLikedAlbumUncheckedUpdateManyWithoutAlbumNestedInput
  }

  export type GenreUpsertWithoutAlbumsInput = {
    update: XOR<GenreUpdateWithoutAlbumsInput, GenreUncheckedUpdateWithoutAlbumsInput>
    create: XOR<GenreCreateWithoutAlbumsInput, GenreUncheckedCreateWithoutAlbumsInput>
    where?: GenreWhereInput
  }

  export type GenreUpdateToOneWithWhereWithoutAlbumsInput = {
    where?: GenreWhereInput
    data: XOR<GenreUpdateWithoutAlbumsInput, GenreUncheckedUpdateWithoutAlbumsInput>
  }

  export type GenreUpdateWithoutAlbumsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    songs?: SongGenreUpdateManyWithoutGenreNestedInput
    artists?: ArtistGenreUpdateManyWithoutGenreNestedInput
  }

  export type GenreUncheckedUpdateWithoutAlbumsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    songs?: SongGenreUncheckedUpdateManyWithoutGenreNestedInput
    artists?: ArtistGenreUncheckedUpdateManyWithoutGenreNestedInput
  }

  export type ArtistCreateWithoutGenresInput = {
    id?: string
    name: string
    slug: string
    bio?: string | null
    imageId: string
    verified?: boolean
    monthlyListeners?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    albums?: AlbumCreateNestedManyWithoutArtistInput
    songs?: SongArtistCreateNestedManyWithoutArtistInput
    likedBy?: UserLikedArtistCreateNestedManyWithoutArtistInput
    credits?: SongCreditCreateNestedManyWithoutArtistInput
  }

  export type ArtistUncheckedCreateWithoutGenresInput = {
    id?: string
    name: string
    slug: string
    bio?: string | null
    imageId: string
    verified?: boolean
    monthlyListeners?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    albums?: AlbumUncheckedCreateNestedManyWithoutArtistInput
    songs?: SongArtistUncheckedCreateNestedManyWithoutArtistInput
    likedBy?: UserLikedArtistUncheckedCreateNestedManyWithoutArtistInput
    credits?: SongCreditUncheckedCreateNestedManyWithoutArtistInput
  }

  export type ArtistCreateOrConnectWithoutGenresInput = {
    where: ArtistWhereUniqueInput
    create: XOR<ArtistCreateWithoutGenresInput, ArtistUncheckedCreateWithoutGenresInput>
  }

  export type GenreCreateWithoutArtistsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    color?: string | null
    songs?: SongGenreCreateNestedManyWithoutGenreInput
    albums?: AlbumGenreCreateNestedManyWithoutGenreInput
  }

  export type GenreUncheckedCreateWithoutArtistsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    color?: string | null
    songs?: SongGenreUncheckedCreateNestedManyWithoutGenreInput
    albums?: AlbumGenreUncheckedCreateNestedManyWithoutGenreInput
  }

  export type GenreCreateOrConnectWithoutArtistsInput = {
    where: GenreWhereUniqueInput
    create: XOR<GenreCreateWithoutArtistsInput, GenreUncheckedCreateWithoutArtistsInput>
  }

  export type ArtistUpsertWithoutGenresInput = {
    update: XOR<ArtistUpdateWithoutGenresInput, ArtistUncheckedUpdateWithoutGenresInput>
    create: XOR<ArtistCreateWithoutGenresInput, ArtistUncheckedCreateWithoutGenresInput>
    where?: ArtistWhereInput
  }

  export type ArtistUpdateToOneWithWhereWithoutGenresInput = {
    where?: ArtistWhereInput
    data: XOR<ArtistUpdateWithoutGenresInput, ArtistUncheckedUpdateWithoutGenresInput>
  }

  export type ArtistUpdateWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albums?: AlbumUpdateManyWithoutArtistNestedInput
    songs?: SongArtistUpdateManyWithoutArtistNestedInput
    likedBy?: UserLikedArtistUpdateManyWithoutArtistNestedInput
    credits?: SongCreditUpdateManyWithoutArtistNestedInput
  }

  export type ArtistUncheckedUpdateWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albums?: AlbumUncheckedUpdateManyWithoutArtistNestedInput
    songs?: SongArtistUncheckedUpdateManyWithoutArtistNestedInput
    likedBy?: UserLikedArtistUncheckedUpdateManyWithoutArtistNestedInput
    credits?: SongCreditUncheckedUpdateManyWithoutArtistNestedInput
  }

  export type GenreUpsertWithoutArtistsInput = {
    update: XOR<GenreUpdateWithoutArtistsInput, GenreUncheckedUpdateWithoutArtistsInput>
    create: XOR<GenreCreateWithoutArtistsInput, GenreUncheckedCreateWithoutArtistsInput>
    where?: GenreWhereInput
  }

  export type GenreUpdateToOneWithWhereWithoutArtistsInput = {
    where?: GenreWhereInput
    data: XOR<GenreUpdateWithoutArtistsInput, GenreUncheckedUpdateWithoutArtistsInput>
  }

  export type GenreUpdateWithoutArtistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    songs?: SongGenreUpdateManyWithoutGenreNestedInput
    albums?: AlbumGenreUpdateManyWithoutGenreNestedInput
  }

  export type GenreUncheckedUpdateWithoutArtistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    songs?: SongGenreUncheckedUpdateManyWithoutGenreNestedInput
    albums?: AlbumGenreUncheckedUpdateManyWithoutGenreNestedInput
  }

  export type UserCreateWithoutPlaylistsInput = {
    id?: string
    email: string
    username?: string | null
    name?: string | null
    password?: string | null
    imageId?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bio?: string | null
    country?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    likedSongs?: UserLikedSongCreateNestedManyWithoutUserInput
    likedAlbums?: UserLikedAlbumCreateNestedManyWithoutUserInput
    likedPlaylists?: UserLikedPlaylistCreateNestedManyWithoutUserInput
    likedArtists?: UserLikedArtistCreateNestedManyWithoutUserInput
    playHistory?: PlayHistoryCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowerInput
    following?: UserFollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutPlaylistsInput = {
    id?: string
    email: string
    username?: string | null
    name?: string | null
    password?: string | null
    imageId?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bio?: string | null
    country?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    likedSongs?: UserLikedSongUncheckedCreateNestedManyWithoutUserInput
    likedAlbums?: UserLikedAlbumUncheckedCreateNestedManyWithoutUserInput
    likedPlaylists?: UserLikedPlaylistUncheckedCreateNestedManyWithoutUserInput
    likedArtists?: UserLikedArtistUncheckedCreateNestedManyWithoutUserInput
    playHistory?: PlayHistoryUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutPlaylistsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlaylistsInput, UserUncheckedCreateWithoutPlaylistsInput>
  }

  export type PlaylistItemCreateWithoutPlaylistInput = {
    id?: string
    position: number
    addedAt?: Date | string
    song: SongCreateNestedOneWithoutPlaylistItemsInput
  }

  export type PlaylistItemUncheckedCreateWithoutPlaylistInput = {
    id?: string
    position: number
    addedAt?: Date | string
    songId: string
  }

  export type PlaylistItemCreateOrConnectWithoutPlaylistInput = {
    where: PlaylistItemWhereUniqueInput
    create: XOR<PlaylistItemCreateWithoutPlaylistInput, PlaylistItemUncheckedCreateWithoutPlaylistInput>
  }

  export type PlaylistItemCreateManyPlaylistInputEnvelope = {
    data: PlaylistItemCreateManyPlaylistInput | PlaylistItemCreateManyPlaylistInput[]
    skipDuplicates?: boolean
  }

  export type UserLikedPlaylistCreateWithoutPlaylistInput = {
    likedAt?: Date | string
    user: UserCreateNestedOneWithoutLikedPlaylistsInput
  }

  export type UserLikedPlaylistUncheckedCreateWithoutPlaylistInput = {
    userId: string
    likedAt?: Date | string
  }

  export type UserLikedPlaylistCreateOrConnectWithoutPlaylistInput = {
    where: UserLikedPlaylistWhereUniqueInput
    create: XOR<UserLikedPlaylistCreateWithoutPlaylistInput, UserLikedPlaylistUncheckedCreateWithoutPlaylistInput>
  }

  export type UserLikedPlaylistCreateManyPlaylistInputEnvelope = {
    data: UserLikedPlaylistCreateManyPlaylistInput | UserLikedPlaylistCreateManyPlaylistInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPlaylistsInput = {
    update: XOR<UserUpdateWithoutPlaylistsInput, UserUncheckedUpdateWithoutPlaylistsInput>
    create: XOR<UserCreateWithoutPlaylistsInput, UserUncheckedCreateWithoutPlaylistsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlaylistsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlaylistsInput, UserUncheckedUpdateWithoutPlaylistsInput>
  }

  export type UserUpdateWithoutPlaylistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    likedSongs?: UserLikedSongUpdateManyWithoutUserNestedInput
    likedAlbums?: UserLikedAlbumUpdateManyWithoutUserNestedInput
    likedPlaylists?: UserLikedPlaylistUpdateManyWithoutUserNestedInput
    likedArtists?: UserLikedArtistUpdateManyWithoutUserNestedInput
    playHistory?: PlayHistoryUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowerNestedInput
    following?: UserFollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutPlaylistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    likedSongs?: UserLikedSongUncheckedUpdateManyWithoutUserNestedInput
    likedAlbums?: UserLikedAlbumUncheckedUpdateManyWithoutUserNestedInput
    likedPlaylists?: UserLikedPlaylistUncheckedUpdateManyWithoutUserNestedInput
    likedArtists?: UserLikedArtistUncheckedUpdateManyWithoutUserNestedInput
    playHistory?: PlayHistoryUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type PlaylistItemUpsertWithWhereUniqueWithoutPlaylistInput = {
    where: PlaylistItemWhereUniqueInput
    update: XOR<PlaylistItemUpdateWithoutPlaylistInput, PlaylistItemUncheckedUpdateWithoutPlaylistInput>
    create: XOR<PlaylistItemCreateWithoutPlaylistInput, PlaylistItemUncheckedCreateWithoutPlaylistInput>
  }

  export type PlaylistItemUpdateWithWhereUniqueWithoutPlaylistInput = {
    where: PlaylistItemWhereUniqueInput
    data: XOR<PlaylistItemUpdateWithoutPlaylistInput, PlaylistItemUncheckedUpdateWithoutPlaylistInput>
  }

  export type PlaylistItemUpdateManyWithWhereWithoutPlaylistInput = {
    where: PlaylistItemScalarWhereInput
    data: XOR<PlaylistItemUpdateManyMutationInput, PlaylistItemUncheckedUpdateManyWithoutPlaylistInput>
  }

  export type UserLikedPlaylistUpsertWithWhereUniqueWithoutPlaylistInput = {
    where: UserLikedPlaylistWhereUniqueInput
    update: XOR<UserLikedPlaylistUpdateWithoutPlaylistInput, UserLikedPlaylistUncheckedUpdateWithoutPlaylistInput>
    create: XOR<UserLikedPlaylistCreateWithoutPlaylistInput, UserLikedPlaylistUncheckedCreateWithoutPlaylistInput>
  }

  export type UserLikedPlaylistUpdateWithWhereUniqueWithoutPlaylistInput = {
    where: UserLikedPlaylistWhereUniqueInput
    data: XOR<UserLikedPlaylistUpdateWithoutPlaylistInput, UserLikedPlaylistUncheckedUpdateWithoutPlaylistInput>
  }

  export type UserLikedPlaylistUpdateManyWithWhereWithoutPlaylistInput = {
    where: UserLikedPlaylistScalarWhereInput
    data: XOR<UserLikedPlaylistUpdateManyMutationInput, UserLikedPlaylistUncheckedUpdateManyWithoutPlaylistInput>
  }

  export type PlaylistCreateWithoutItemsInput = {
    id?: string
    title: string
    description?: string | null
    imageId?: string | null
    isPublic?: boolean
    isOfficial?: boolean
    totalTracks?: number
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutPlaylistsInput
    likedBy?: UserLikedPlaylistCreateNestedManyWithoutPlaylistInput
  }

  export type PlaylistUncheckedCreateWithoutItemsInput = {
    id?: string
    title: string
    description?: string | null
    imageId?: string | null
    isPublic?: boolean
    isOfficial?: boolean
    totalTracks?: number
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    likedBy?: UserLikedPlaylistUncheckedCreateNestedManyWithoutPlaylistInput
  }

  export type PlaylistCreateOrConnectWithoutItemsInput = {
    where: PlaylistWhereUniqueInput
    create: XOR<PlaylistCreateWithoutItemsInput, PlaylistUncheckedCreateWithoutItemsInput>
  }

  export type SongCreateWithoutPlaylistItemsInput = {
    id?: string
    title: string
    slug: string
    audioId: string
    duration: number
    trackNumber: number
    lyrics?: string | null
    isExplicit?: boolean
    playCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    album: AlbumCreateNestedOneWithoutSongsInput
    artists?: SongArtistCreateNestedManyWithoutSongInput
    credits?: SongCreditCreateNestedManyWithoutSongInput
    genres?: SongGenreCreateNestedManyWithoutSongInput
    likedBy?: UserLikedSongCreateNestedManyWithoutSongInput
    playHistory?: PlayHistoryCreateNestedManyWithoutSongInput
  }

  export type SongUncheckedCreateWithoutPlaylistItemsInput = {
    id?: string
    title: string
    slug: string
    audioId: string
    duration: number
    trackNumber: number
    lyrics?: string | null
    isExplicit?: boolean
    playCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    albumId: string
    artists?: SongArtistUncheckedCreateNestedManyWithoutSongInput
    credits?: SongCreditUncheckedCreateNestedManyWithoutSongInput
    genres?: SongGenreUncheckedCreateNestedManyWithoutSongInput
    likedBy?: UserLikedSongUncheckedCreateNestedManyWithoutSongInput
    playHistory?: PlayHistoryUncheckedCreateNestedManyWithoutSongInput
  }

  export type SongCreateOrConnectWithoutPlaylistItemsInput = {
    where: SongWhereUniqueInput
    create: XOR<SongCreateWithoutPlaylistItemsInput, SongUncheckedCreateWithoutPlaylistItemsInput>
  }

  export type PlaylistUpsertWithoutItemsInput = {
    update: XOR<PlaylistUpdateWithoutItemsInput, PlaylistUncheckedUpdateWithoutItemsInput>
    create: XOR<PlaylistCreateWithoutItemsInput, PlaylistUncheckedCreateWithoutItemsInput>
    where?: PlaylistWhereInput
  }

  export type PlaylistUpdateToOneWithWhereWithoutItemsInput = {
    where?: PlaylistWhereInput
    data: XOR<PlaylistUpdateWithoutItemsInput, PlaylistUncheckedUpdateWithoutItemsInput>
  }

  export type PlaylistUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isOfficial?: BoolFieldUpdateOperationsInput | boolean
    totalTracks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutPlaylistsNestedInput
    likedBy?: UserLikedPlaylistUpdateManyWithoutPlaylistNestedInput
  }

  export type PlaylistUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isOfficial?: BoolFieldUpdateOperationsInput | boolean
    totalTracks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    likedBy?: UserLikedPlaylistUncheckedUpdateManyWithoutPlaylistNestedInput
  }

  export type SongUpsertWithoutPlaylistItemsInput = {
    update: XOR<SongUpdateWithoutPlaylistItemsInput, SongUncheckedUpdateWithoutPlaylistItemsInput>
    create: XOR<SongCreateWithoutPlaylistItemsInput, SongUncheckedCreateWithoutPlaylistItemsInput>
    where?: SongWhereInput
  }

  export type SongUpdateToOneWithWhereWithoutPlaylistItemsInput = {
    where?: SongWhereInput
    data: XOR<SongUpdateWithoutPlaylistItemsInput, SongUncheckedUpdateWithoutPlaylistItemsInput>
  }

  export type SongUpdateWithoutPlaylistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    trackNumber?: IntFieldUpdateOperationsInput | number
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    album?: AlbumUpdateOneRequiredWithoutSongsNestedInput
    artists?: SongArtistUpdateManyWithoutSongNestedInput
    credits?: SongCreditUpdateManyWithoutSongNestedInput
    genres?: SongGenreUpdateManyWithoutSongNestedInput
    likedBy?: UserLikedSongUpdateManyWithoutSongNestedInput
    playHistory?: PlayHistoryUpdateManyWithoutSongNestedInput
  }

  export type SongUncheckedUpdateWithoutPlaylistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    trackNumber?: IntFieldUpdateOperationsInput | number
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albumId?: StringFieldUpdateOperationsInput | string
    artists?: SongArtistUncheckedUpdateManyWithoutSongNestedInput
    credits?: SongCreditUncheckedUpdateManyWithoutSongNestedInput
    genres?: SongGenreUncheckedUpdateManyWithoutSongNestedInput
    likedBy?: UserLikedSongUncheckedUpdateManyWithoutSongNestedInput
    playHistory?: PlayHistoryUncheckedUpdateManyWithoutSongNestedInput
  }

  export type UserCreateWithoutLikedSongsInput = {
    id?: string
    email: string
    username?: string | null
    name?: string | null
    password?: string | null
    imageId?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bio?: string | null
    country?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    likedAlbums?: UserLikedAlbumCreateNestedManyWithoutUserInput
    likedPlaylists?: UserLikedPlaylistCreateNestedManyWithoutUserInput
    likedArtists?: UserLikedArtistCreateNestedManyWithoutUserInput
    playHistory?: PlayHistoryCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowerInput
    following?: UserFollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutLikedSongsInput = {
    id?: string
    email: string
    username?: string | null
    name?: string | null
    password?: string | null
    imageId?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bio?: string | null
    country?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    likedAlbums?: UserLikedAlbumUncheckedCreateNestedManyWithoutUserInput
    likedPlaylists?: UserLikedPlaylistUncheckedCreateNestedManyWithoutUserInput
    likedArtists?: UserLikedArtistUncheckedCreateNestedManyWithoutUserInput
    playHistory?: PlayHistoryUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutLikedSongsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLikedSongsInput, UserUncheckedCreateWithoutLikedSongsInput>
  }

  export type SongCreateWithoutLikedByInput = {
    id?: string
    title: string
    slug: string
    audioId: string
    duration: number
    trackNumber: number
    lyrics?: string | null
    isExplicit?: boolean
    playCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    album: AlbumCreateNestedOneWithoutSongsInput
    artists?: SongArtistCreateNestedManyWithoutSongInput
    credits?: SongCreditCreateNestedManyWithoutSongInput
    genres?: SongGenreCreateNestedManyWithoutSongInput
    playlistItems?: PlaylistItemCreateNestedManyWithoutSongInput
    playHistory?: PlayHistoryCreateNestedManyWithoutSongInput
  }

  export type SongUncheckedCreateWithoutLikedByInput = {
    id?: string
    title: string
    slug: string
    audioId: string
    duration: number
    trackNumber: number
    lyrics?: string | null
    isExplicit?: boolean
    playCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    albumId: string
    artists?: SongArtistUncheckedCreateNestedManyWithoutSongInput
    credits?: SongCreditUncheckedCreateNestedManyWithoutSongInput
    genres?: SongGenreUncheckedCreateNestedManyWithoutSongInput
    playlistItems?: PlaylistItemUncheckedCreateNestedManyWithoutSongInput
    playHistory?: PlayHistoryUncheckedCreateNestedManyWithoutSongInput
  }

  export type SongCreateOrConnectWithoutLikedByInput = {
    where: SongWhereUniqueInput
    create: XOR<SongCreateWithoutLikedByInput, SongUncheckedCreateWithoutLikedByInput>
  }

  export type UserUpsertWithoutLikedSongsInput = {
    update: XOR<UserUpdateWithoutLikedSongsInput, UserUncheckedUpdateWithoutLikedSongsInput>
    create: XOR<UserCreateWithoutLikedSongsInput, UserUncheckedCreateWithoutLikedSongsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLikedSongsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLikedSongsInput, UserUncheckedUpdateWithoutLikedSongsInput>
  }

  export type UserUpdateWithoutLikedSongsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    likedAlbums?: UserLikedAlbumUpdateManyWithoutUserNestedInput
    likedPlaylists?: UserLikedPlaylistUpdateManyWithoutUserNestedInput
    likedArtists?: UserLikedArtistUpdateManyWithoutUserNestedInput
    playHistory?: PlayHistoryUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowerNestedInput
    following?: UserFollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutLikedSongsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    likedAlbums?: UserLikedAlbumUncheckedUpdateManyWithoutUserNestedInput
    likedPlaylists?: UserLikedPlaylistUncheckedUpdateManyWithoutUserNestedInput
    likedArtists?: UserLikedArtistUncheckedUpdateManyWithoutUserNestedInput
    playHistory?: PlayHistoryUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type SongUpsertWithoutLikedByInput = {
    update: XOR<SongUpdateWithoutLikedByInput, SongUncheckedUpdateWithoutLikedByInput>
    create: XOR<SongCreateWithoutLikedByInput, SongUncheckedCreateWithoutLikedByInput>
    where?: SongWhereInput
  }

  export type SongUpdateToOneWithWhereWithoutLikedByInput = {
    where?: SongWhereInput
    data: XOR<SongUpdateWithoutLikedByInput, SongUncheckedUpdateWithoutLikedByInput>
  }

  export type SongUpdateWithoutLikedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    trackNumber?: IntFieldUpdateOperationsInput | number
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    album?: AlbumUpdateOneRequiredWithoutSongsNestedInput
    artists?: SongArtistUpdateManyWithoutSongNestedInput
    credits?: SongCreditUpdateManyWithoutSongNestedInput
    genres?: SongGenreUpdateManyWithoutSongNestedInput
    playlistItems?: PlaylistItemUpdateManyWithoutSongNestedInput
    playHistory?: PlayHistoryUpdateManyWithoutSongNestedInput
  }

  export type SongUncheckedUpdateWithoutLikedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    trackNumber?: IntFieldUpdateOperationsInput | number
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albumId?: StringFieldUpdateOperationsInput | string
    artists?: SongArtistUncheckedUpdateManyWithoutSongNestedInput
    credits?: SongCreditUncheckedUpdateManyWithoutSongNestedInput
    genres?: SongGenreUncheckedUpdateManyWithoutSongNestedInput
    playlistItems?: PlaylistItemUncheckedUpdateManyWithoutSongNestedInput
    playHistory?: PlayHistoryUncheckedUpdateManyWithoutSongNestedInput
  }

  export type UserCreateWithoutLikedAlbumsInput = {
    id?: string
    email: string
    username?: string | null
    name?: string | null
    password?: string | null
    imageId?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bio?: string | null
    country?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    likedSongs?: UserLikedSongCreateNestedManyWithoutUserInput
    likedPlaylists?: UserLikedPlaylistCreateNestedManyWithoutUserInput
    likedArtists?: UserLikedArtistCreateNestedManyWithoutUserInput
    playHistory?: PlayHistoryCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowerInput
    following?: UserFollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutLikedAlbumsInput = {
    id?: string
    email: string
    username?: string | null
    name?: string | null
    password?: string | null
    imageId?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bio?: string | null
    country?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    likedSongs?: UserLikedSongUncheckedCreateNestedManyWithoutUserInput
    likedPlaylists?: UserLikedPlaylistUncheckedCreateNestedManyWithoutUserInput
    likedArtists?: UserLikedArtistUncheckedCreateNestedManyWithoutUserInput
    playHistory?: PlayHistoryUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutLikedAlbumsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLikedAlbumsInput, UserUncheckedCreateWithoutLikedAlbumsInput>
  }

  export type AlbumCreateWithoutLikedByInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    imageId: string
    albumType?: $Enums.AlbumType
    releaseDate?: Date | string
    totalTracks?: number
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    artist: ArtistCreateNestedOneWithoutAlbumsInput
    songs?: SongCreateNestedManyWithoutAlbumInput
    genres?: AlbumGenreCreateNestedManyWithoutAlbumInput
  }

  export type AlbumUncheckedCreateWithoutLikedByInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    imageId: string
    albumType?: $Enums.AlbumType
    releaseDate?: Date | string
    totalTracks?: number
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    artistId: string
    songs?: SongUncheckedCreateNestedManyWithoutAlbumInput
    genres?: AlbumGenreUncheckedCreateNestedManyWithoutAlbumInput
  }

  export type AlbumCreateOrConnectWithoutLikedByInput = {
    where: AlbumWhereUniqueInput
    create: XOR<AlbumCreateWithoutLikedByInput, AlbumUncheckedCreateWithoutLikedByInput>
  }

  export type UserUpsertWithoutLikedAlbumsInput = {
    update: XOR<UserUpdateWithoutLikedAlbumsInput, UserUncheckedUpdateWithoutLikedAlbumsInput>
    create: XOR<UserCreateWithoutLikedAlbumsInput, UserUncheckedCreateWithoutLikedAlbumsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLikedAlbumsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLikedAlbumsInput, UserUncheckedUpdateWithoutLikedAlbumsInput>
  }

  export type UserUpdateWithoutLikedAlbumsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    likedSongs?: UserLikedSongUpdateManyWithoutUserNestedInput
    likedPlaylists?: UserLikedPlaylistUpdateManyWithoutUserNestedInput
    likedArtists?: UserLikedArtistUpdateManyWithoutUserNestedInput
    playHistory?: PlayHistoryUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowerNestedInput
    following?: UserFollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutLikedAlbumsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    likedSongs?: UserLikedSongUncheckedUpdateManyWithoutUserNestedInput
    likedPlaylists?: UserLikedPlaylistUncheckedUpdateManyWithoutUserNestedInput
    likedArtists?: UserLikedArtistUncheckedUpdateManyWithoutUserNestedInput
    playHistory?: PlayHistoryUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type AlbumUpsertWithoutLikedByInput = {
    update: XOR<AlbumUpdateWithoutLikedByInput, AlbumUncheckedUpdateWithoutLikedByInput>
    create: XOR<AlbumCreateWithoutLikedByInput, AlbumUncheckedCreateWithoutLikedByInput>
    where?: AlbumWhereInput
  }

  export type AlbumUpdateToOneWithWhereWithoutLikedByInput = {
    where?: AlbumWhereInput
    data: XOR<AlbumUpdateWithoutLikedByInput, AlbumUncheckedUpdateWithoutLikedByInput>
  }

  export type AlbumUpdateWithoutLikedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: StringFieldUpdateOperationsInput | string
    albumType?: EnumAlbumTypeFieldUpdateOperationsInput | $Enums.AlbumType
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalTracks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUpdateOneRequiredWithoutAlbumsNestedInput
    songs?: SongUpdateManyWithoutAlbumNestedInput
    genres?: AlbumGenreUpdateManyWithoutAlbumNestedInput
  }

  export type AlbumUncheckedUpdateWithoutLikedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: StringFieldUpdateOperationsInput | string
    albumType?: EnumAlbumTypeFieldUpdateOperationsInput | $Enums.AlbumType
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalTracks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artistId?: StringFieldUpdateOperationsInput | string
    songs?: SongUncheckedUpdateManyWithoutAlbumNestedInput
    genres?: AlbumGenreUncheckedUpdateManyWithoutAlbumNestedInput
  }

  export type UserCreateWithoutLikedArtistsInput = {
    id?: string
    email: string
    username?: string | null
    name?: string | null
    password?: string | null
    imageId?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bio?: string | null
    country?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    likedSongs?: UserLikedSongCreateNestedManyWithoutUserInput
    likedAlbums?: UserLikedAlbumCreateNestedManyWithoutUserInput
    likedPlaylists?: UserLikedPlaylistCreateNestedManyWithoutUserInput
    playHistory?: PlayHistoryCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowerInput
    following?: UserFollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutLikedArtistsInput = {
    id?: string
    email: string
    username?: string | null
    name?: string | null
    password?: string | null
    imageId?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bio?: string | null
    country?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    likedSongs?: UserLikedSongUncheckedCreateNestedManyWithoutUserInput
    likedAlbums?: UserLikedAlbumUncheckedCreateNestedManyWithoutUserInput
    likedPlaylists?: UserLikedPlaylistUncheckedCreateNestedManyWithoutUserInput
    playHistory?: PlayHistoryUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutLikedArtistsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLikedArtistsInput, UserUncheckedCreateWithoutLikedArtistsInput>
  }

  export type ArtistCreateWithoutLikedByInput = {
    id?: string
    name: string
    slug: string
    bio?: string | null
    imageId: string
    verified?: boolean
    monthlyListeners?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    albums?: AlbumCreateNestedManyWithoutArtistInput
    songs?: SongArtistCreateNestedManyWithoutArtistInput
    genres?: ArtistGenreCreateNestedManyWithoutArtistInput
    credits?: SongCreditCreateNestedManyWithoutArtistInput
  }

  export type ArtistUncheckedCreateWithoutLikedByInput = {
    id?: string
    name: string
    slug: string
    bio?: string | null
    imageId: string
    verified?: boolean
    monthlyListeners?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    albums?: AlbumUncheckedCreateNestedManyWithoutArtistInput
    songs?: SongArtistUncheckedCreateNestedManyWithoutArtistInput
    genres?: ArtistGenreUncheckedCreateNestedManyWithoutArtistInput
    credits?: SongCreditUncheckedCreateNestedManyWithoutArtistInput
  }

  export type ArtistCreateOrConnectWithoutLikedByInput = {
    where: ArtistWhereUniqueInput
    create: XOR<ArtistCreateWithoutLikedByInput, ArtistUncheckedCreateWithoutLikedByInput>
  }

  export type UserUpsertWithoutLikedArtistsInput = {
    update: XOR<UserUpdateWithoutLikedArtistsInput, UserUncheckedUpdateWithoutLikedArtistsInput>
    create: XOR<UserCreateWithoutLikedArtistsInput, UserUncheckedCreateWithoutLikedArtistsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLikedArtistsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLikedArtistsInput, UserUncheckedUpdateWithoutLikedArtistsInput>
  }

  export type UserUpdateWithoutLikedArtistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    likedSongs?: UserLikedSongUpdateManyWithoutUserNestedInput
    likedAlbums?: UserLikedAlbumUpdateManyWithoutUserNestedInput
    likedPlaylists?: UserLikedPlaylistUpdateManyWithoutUserNestedInput
    playHistory?: PlayHistoryUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowerNestedInput
    following?: UserFollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutLikedArtistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    likedSongs?: UserLikedSongUncheckedUpdateManyWithoutUserNestedInput
    likedAlbums?: UserLikedAlbumUncheckedUpdateManyWithoutUserNestedInput
    likedPlaylists?: UserLikedPlaylistUncheckedUpdateManyWithoutUserNestedInput
    playHistory?: PlayHistoryUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type ArtistUpsertWithoutLikedByInput = {
    update: XOR<ArtistUpdateWithoutLikedByInput, ArtistUncheckedUpdateWithoutLikedByInput>
    create: XOR<ArtistCreateWithoutLikedByInput, ArtistUncheckedCreateWithoutLikedByInput>
    where?: ArtistWhereInput
  }

  export type ArtistUpdateToOneWithWhereWithoutLikedByInput = {
    where?: ArtistWhereInput
    data: XOR<ArtistUpdateWithoutLikedByInput, ArtistUncheckedUpdateWithoutLikedByInput>
  }

  export type ArtistUpdateWithoutLikedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albums?: AlbumUpdateManyWithoutArtistNestedInput
    songs?: SongArtistUpdateManyWithoutArtistNestedInput
    genres?: ArtistGenreUpdateManyWithoutArtistNestedInput
    credits?: SongCreditUpdateManyWithoutArtistNestedInput
  }

  export type ArtistUncheckedUpdateWithoutLikedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albums?: AlbumUncheckedUpdateManyWithoutArtistNestedInput
    songs?: SongArtistUncheckedUpdateManyWithoutArtistNestedInput
    genres?: ArtistGenreUncheckedUpdateManyWithoutArtistNestedInput
    credits?: SongCreditUncheckedUpdateManyWithoutArtistNestedInput
  }

  export type UserCreateWithoutLikedPlaylistsInput = {
    id?: string
    email: string
    username?: string | null
    name?: string | null
    password?: string | null
    imageId?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bio?: string | null
    country?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    likedSongs?: UserLikedSongCreateNestedManyWithoutUserInput
    likedAlbums?: UserLikedAlbumCreateNestedManyWithoutUserInput
    likedArtists?: UserLikedArtistCreateNestedManyWithoutUserInput
    playHistory?: PlayHistoryCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowerInput
    following?: UserFollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutLikedPlaylistsInput = {
    id?: string
    email: string
    username?: string | null
    name?: string | null
    password?: string | null
    imageId?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bio?: string | null
    country?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    likedSongs?: UserLikedSongUncheckedCreateNestedManyWithoutUserInput
    likedAlbums?: UserLikedAlbumUncheckedCreateNestedManyWithoutUserInput
    likedArtists?: UserLikedArtistUncheckedCreateNestedManyWithoutUserInput
    playHistory?: PlayHistoryUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutLikedPlaylistsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLikedPlaylistsInput, UserUncheckedCreateWithoutLikedPlaylistsInput>
  }

  export type PlaylistCreateWithoutLikedByInput = {
    id?: string
    title: string
    description?: string | null
    imageId?: string | null
    isPublic?: boolean
    isOfficial?: boolean
    totalTracks?: number
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutPlaylistsInput
    items?: PlaylistItemCreateNestedManyWithoutPlaylistInput
  }

  export type PlaylistUncheckedCreateWithoutLikedByInput = {
    id?: string
    title: string
    description?: string | null
    imageId?: string | null
    isPublic?: boolean
    isOfficial?: boolean
    totalTracks?: number
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    items?: PlaylistItemUncheckedCreateNestedManyWithoutPlaylistInput
  }

  export type PlaylistCreateOrConnectWithoutLikedByInput = {
    where: PlaylistWhereUniqueInput
    create: XOR<PlaylistCreateWithoutLikedByInput, PlaylistUncheckedCreateWithoutLikedByInput>
  }

  export type UserUpsertWithoutLikedPlaylistsInput = {
    update: XOR<UserUpdateWithoutLikedPlaylistsInput, UserUncheckedUpdateWithoutLikedPlaylistsInput>
    create: XOR<UserCreateWithoutLikedPlaylistsInput, UserUncheckedCreateWithoutLikedPlaylistsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLikedPlaylistsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLikedPlaylistsInput, UserUncheckedUpdateWithoutLikedPlaylistsInput>
  }

  export type UserUpdateWithoutLikedPlaylistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    likedSongs?: UserLikedSongUpdateManyWithoutUserNestedInput
    likedAlbums?: UserLikedAlbumUpdateManyWithoutUserNestedInput
    likedArtists?: UserLikedArtistUpdateManyWithoutUserNestedInput
    playHistory?: PlayHistoryUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowerNestedInput
    following?: UserFollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutLikedPlaylistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    likedSongs?: UserLikedSongUncheckedUpdateManyWithoutUserNestedInput
    likedAlbums?: UserLikedAlbumUncheckedUpdateManyWithoutUserNestedInput
    likedArtists?: UserLikedArtistUncheckedUpdateManyWithoutUserNestedInput
    playHistory?: PlayHistoryUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type PlaylistUpsertWithoutLikedByInput = {
    update: XOR<PlaylistUpdateWithoutLikedByInput, PlaylistUncheckedUpdateWithoutLikedByInput>
    create: XOR<PlaylistCreateWithoutLikedByInput, PlaylistUncheckedCreateWithoutLikedByInput>
    where?: PlaylistWhereInput
  }

  export type PlaylistUpdateToOneWithWhereWithoutLikedByInput = {
    where?: PlaylistWhereInput
    data: XOR<PlaylistUpdateWithoutLikedByInput, PlaylistUncheckedUpdateWithoutLikedByInput>
  }

  export type PlaylistUpdateWithoutLikedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isOfficial?: BoolFieldUpdateOperationsInput | boolean
    totalTracks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutPlaylistsNestedInput
    items?: PlaylistItemUpdateManyWithoutPlaylistNestedInput
  }

  export type PlaylistUncheckedUpdateWithoutLikedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isOfficial?: BoolFieldUpdateOperationsInput | boolean
    totalTracks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    items?: PlaylistItemUncheckedUpdateManyWithoutPlaylistNestedInput
  }

  export type UserCreateWithoutFollowersInput = {
    id?: string
    email: string
    username?: string | null
    name?: string | null
    password?: string | null
    imageId?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bio?: string | null
    country?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    likedSongs?: UserLikedSongCreateNestedManyWithoutUserInput
    likedAlbums?: UserLikedAlbumCreateNestedManyWithoutUserInput
    likedPlaylists?: UserLikedPlaylistCreateNestedManyWithoutUserInput
    likedArtists?: UserLikedArtistCreateNestedManyWithoutUserInput
    playHistory?: PlayHistoryCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    following?: UserFollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutFollowersInput = {
    id?: string
    email: string
    username?: string | null
    name?: string | null
    password?: string | null
    imageId?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bio?: string | null
    country?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    likedSongs?: UserLikedSongUncheckedCreateNestedManyWithoutUserInput
    likedAlbums?: UserLikedAlbumUncheckedCreateNestedManyWithoutUserInput
    likedPlaylists?: UserLikedPlaylistUncheckedCreateNestedManyWithoutUserInput
    likedArtists?: UserLikedArtistUncheckedCreateNestedManyWithoutUserInput
    playHistory?: PlayHistoryUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutFollowersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
  }

  export type UserCreateWithoutFollowingInput = {
    id?: string
    email: string
    username?: string | null
    name?: string | null
    password?: string | null
    imageId?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bio?: string | null
    country?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    likedSongs?: UserLikedSongCreateNestedManyWithoutUserInput
    likedAlbums?: UserLikedAlbumCreateNestedManyWithoutUserInput
    likedPlaylists?: UserLikedPlaylistCreateNestedManyWithoutUserInput
    likedArtists?: UserLikedArtistCreateNestedManyWithoutUserInput
    playHistory?: PlayHistoryCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowerInput
  }

  export type UserUncheckedCreateWithoutFollowingInput = {
    id?: string
    email: string
    username?: string | null
    name?: string | null
    password?: string | null
    imageId?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bio?: string | null
    country?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    likedSongs?: UserLikedSongUncheckedCreateNestedManyWithoutUserInput
    likedAlbums?: UserLikedAlbumUncheckedCreateNestedManyWithoutUserInput
    likedPlaylists?: UserLikedPlaylistUncheckedCreateNestedManyWithoutUserInput
    likedArtists?: UserLikedArtistUncheckedCreateNestedManyWithoutUserInput
    playHistory?: PlayHistoryUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type UserCreateOrConnectWithoutFollowingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
  }

  export type UserUpsertWithoutFollowersInput = {
    update: XOR<UserUpdateWithoutFollowersInput, UserUncheckedUpdateWithoutFollowersInput>
    create: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowersInput, UserUncheckedUpdateWithoutFollowersInput>
  }

  export type UserUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    likedSongs?: UserLikedSongUpdateManyWithoutUserNestedInput
    likedAlbums?: UserLikedAlbumUpdateManyWithoutUserNestedInput
    likedPlaylists?: UserLikedPlaylistUpdateManyWithoutUserNestedInput
    likedArtists?: UserLikedArtistUpdateManyWithoutUserNestedInput
    playHistory?: PlayHistoryUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    following?: UserFollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    likedSongs?: UserLikedSongUncheckedUpdateManyWithoutUserNestedInput
    likedAlbums?: UserLikedAlbumUncheckedUpdateManyWithoutUserNestedInput
    likedPlaylists?: UserLikedPlaylistUncheckedUpdateManyWithoutUserNestedInput
    likedArtists?: UserLikedArtistUncheckedUpdateManyWithoutUserNestedInput
    playHistory?: PlayHistoryUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserUpsertWithoutFollowingInput = {
    update: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type UserUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    likedSongs?: UserLikedSongUpdateManyWithoutUserNestedInput
    likedAlbums?: UserLikedAlbumUpdateManyWithoutUserNestedInput
    likedPlaylists?: UserLikedPlaylistUpdateManyWithoutUserNestedInput
    likedArtists?: UserLikedArtistUpdateManyWithoutUserNestedInput
    playHistory?: PlayHistoryUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowerNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    likedSongs?: UserLikedSongUncheckedUpdateManyWithoutUserNestedInput
    likedAlbums?: UserLikedAlbumUncheckedUpdateManyWithoutUserNestedInput
    likedPlaylists?: UserLikedPlaylistUncheckedUpdateManyWithoutUserNestedInput
    likedArtists?: UserLikedArtistUncheckedUpdateManyWithoutUserNestedInput
    playHistory?: PlayHistoryUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type UserCreateWithoutPlayHistoryInput = {
    id?: string
    email: string
    username?: string | null
    name?: string | null
    password?: string | null
    imageId?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bio?: string | null
    country?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    likedSongs?: UserLikedSongCreateNestedManyWithoutUserInput
    likedAlbums?: UserLikedAlbumCreateNestedManyWithoutUserInput
    likedPlaylists?: UserLikedPlaylistCreateNestedManyWithoutUserInput
    likedArtists?: UserLikedArtistCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowerInput
    following?: UserFollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutPlayHistoryInput = {
    id?: string
    email: string
    username?: string | null
    name?: string | null
    password?: string | null
    imageId?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bio?: string | null
    country?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    likedSongs?: UserLikedSongUncheckedCreateNestedManyWithoutUserInput
    likedAlbums?: UserLikedAlbumUncheckedCreateNestedManyWithoutUserInput
    likedPlaylists?: UserLikedPlaylistUncheckedCreateNestedManyWithoutUserInput
    likedArtists?: UserLikedArtistUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutPlayHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlayHistoryInput, UserUncheckedCreateWithoutPlayHistoryInput>
  }

  export type SongCreateWithoutPlayHistoryInput = {
    id?: string
    title: string
    slug: string
    audioId: string
    duration: number
    trackNumber: number
    lyrics?: string | null
    isExplicit?: boolean
    playCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    album: AlbumCreateNestedOneWithoutSongsInput
    artists?: SongArtistCreateNestedManyWithoutSongInput
    credits?: SongCreditCreateNestedManyWithoutSongInput
    genres?: SongGenreCreateNestedManyWithoutSongInput
    likedBy?: UserLikedSongCreateNestedManyWithoutSongInput
    playlistItems?: PlaylistItemCreateNestedManyWithoutSongInput
  }

  export type SongUncheckedCreateWithoutPlayHistoryInput = {
    id?: string
    title: string
    slug: string
    audioId: string
    duration: number
    trackNumber: number
    lyrics?: string | null
    isExplicit?: boolean
    playCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    albumId: string
    artists?: SongArtistUncheckedCreateNestedManyWithoutSongInput
    credits?: SongCreditUncheckedCreateNestedManyWithoutSongInput
    genres?: SongGenreUncheckedCreateNestedManyWithoutSongInput
    likedBy?: UserLikedSongUncheckedCreateNestedManyWithoutSongInput
    playlistItems?: PlaylistItemUncheckedCreateNestedManyWithoutSongInput
  }

  export type SongCreateOrConnectWithoutPlayHistoryInput = {
    where: SongWhereUniqueInput
    create: XOR<SongCreateWithoutPlayHistoryInput, SongUncheckedCreateWithoutPlayHistoryInput>
  }

  export type UserUpsertWithoutPlayHistoryInput = {
    update: XOR<UserUpdateWithoutPlayHistoryInput, UserUncheckedUpdateWithoutPlayHistoryInput>
    create: XOR<UserCreateWithoutPlayHistoryInput, UserUncheckedCreateWithoutPlayHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlayHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlayHistoryInput, UserUncheckedUpdateWithoutPlayHistoryInput>
  }

  export type UserUpdateWithoutPlayHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    likedSongs?: UserLikedSongUpdateManyWithoutUserNestedInput
    likedAlbums?: UserLikedAlbumUpdateManyWithoutUserNestedInput
    likedPlaylists?: UserLikedPlaylistUpdateManyWithoutUserNestedInput
    likedArtists?: UserLikedArtistUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowerNestedInput
    following?: UserFollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutPlayHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    likedSongs?: UserLikedSongUncheckedUpdateManyWithoutUserNestedInput
    likedAlbums?: UserLikedAlbumUncheckedUpdateManyWithoutUserNestedInput
    likedPlaylists?: UserLikedPlaylistUncheckedUpdateManyWithoutUserNestedInput
    likedArtists?: UserLikedArtistUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type SongUpsertWithoutPlayHistoryInput = {
    update: XOR<SongUpdateWithoutPlayHistoryInput, SongUncheckedUpdateWithoutPlayHistoryInput>
    create: XOR<SongCreateWithoutPlayHistoryInput, SongUncheckedCreateWithoutPlayHistoryInput>
    where?: SongWhereInput
  }

  export type SongUpdateToOneWithWhereWithoutPlayHistoryInput = {
    where?: SongWhereInput
    data: XOR<SongUpdateWithoutPlayHistoryInput, SongUncheckedUpdateWithoutPlayHistoryInput>
  }

  export type SongUpdateWithoutPlayHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    trackNumber?: IntFieldUpdateOperationsInput | number
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    album?: AlbumUpdateOneRequiredWithoutSongsNestedInput
    artists?: SongArtistUpdateManyWithoutSongNestedInput
    credits?: SongCreditUpdateManyWithoutSongNestedInput
    genres?: SongGenreUpdateManyWithoutSongNestedInput
    likedBy?: UserLikedSongUpdateManyWithoutSongNestedInput
    playlistItems?: PlaylistItemUpdateManyWithoutSongNestedInput
  }

  export type SongUncheckedUpdateWithoutPlayHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    trackNumber?: IntFieldUpdateOperationsInput | number
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albumId?: StringFieldUpdateOperationsInput | string
    artists?: SongArtistUncheckedUpdateManyWithoutSongNestedInput
    credits?: SongCreditUncheckedUpdateManyWithoutSongNestedInput
    genres?: SongGenreUncheckedUpdateManyWithoutSongNestedInput
    likedBy?: UserLikedSongUncheckedUpdateManyWithoutSongNestedInput
    playlistItems?: PlaylistItemUncheckedUpdateManyWithoutSongNestedInput
  }

  export type UserCreateWithoutSearchHistoryInput = {
    id?: string
    email: string
    username?: string | null
    name?: string | null
    password?: string | null
    imageId?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bio?: string | null
    country?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    likedSongs?: UserLikedSongCreateNestedManyWithoutUserInput
    likedAlbums?: UserLikedAlbumCreateNestedManyWithoutUserInput
    likedPlaylists?: UserLikedPlaylistCreateNestedManyWithoutUserInput
    likedArtists?: UserLikedArtistCreateNestedManyWithoutUserInput
    playHistory?: PlayHistoryCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowerInput
    following?: UserFollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutSearchHistoryInput = {
    id?: string
    email: string
    username?: string | null
    name?: string | null
    password?: string | null
    imageId?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bio?: string | null
    country?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    likedSongs?: UserLikedSongUncheckedCreateNestedManyWithoutUserInput
    likedAlbums?: UserLikedAlbumUncheckedCreateNestedManyWithoutUserInput
    likedPlaylists?: UserLikedPlaylistUncheckedCreateNestedManyWithoutUserInput
    likedArtists?: UserLikedArtistUncheckedCreateNestedManyWithoutUserInput
    playHistory?: PlayHistoryUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutSearchHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSearchHistoryInput, UserUncheckedCreateWithoutSearchHistoryInput>
  }

  export type UserUpsertWithoutSearchHistoryInput = {
    update: XOR<UserUpdateWithoutSearchHistoryInput, UserUncheckedUpdateWithoutSearchHistoryInput>
    create: XOR<UserCreateWithoutSearchHistoryInput, UserUncheckedCreateWithoutSearchHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSearchHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSearchHistoryInput, UserUncheckedUpdateWithoutSearchHistoryInput>
  }

  export type UserUpdateWithoutSearchHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    likedSongs?: UserLikedSongUpdateManyWithoutUserNestedInput
    likedAlbums?: UserLikedAlbumUpdateManyWithoutUserNestedInput
    likedPlaylists?: UserLikedPlaylistUpdateManyWithoutUserNestedInput
    likedArtists?: UserLikedArtistUpdateManyWithoutUserNestedInput
    playHistory?: PlayHistoryUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowerNestedInput
    following?: UserFollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutSearchHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    likedSongs?: UserLikedSongUncheckedUpdateManyWithoutUserNestedInput
    likedAlbums?: UserLikedAlbumUncheckedUpdateManyWithoutUserNestedInput
    likedPlaylists?: UserLikedPlaylistUncheckedUpdateManyWithoutUserNestedInput
    likedArtists?: UserLikedArtistUncheckedUpdateManyWithoutUserNestedInput
    playHistory?: PlayHistoryUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type ChartItemCreateWithoutChartInput = {
    position: number
    itemType: string
    itemId: string
    plays?: number
  }

  export type ChartItemUncheckedCreateWithoutChartInput = {
    position: number
    itemType: string
    itemId: string
    plays?: number
  }

  export type ChartItemCreateOrConnectWithoutChartInput = {
    where: ChartItemWhereUniqueInput
    create: XOR<ChartItemCreateWithoutChartInput, ChartItemUncheckedCreateWithoutChartInput>
  }

  export type ChartItemCreateManyChartInputEnvelope = {
    data: ChartItemCreateManyChartInput | ChartItemCreateManyChartInput[]
    skipDuplicates?: boolean
  }

  export type ChartItemUpsertWithWhereUniqueWithoutChartInput = {
    where: ChartItemWhereUniqueInput
    update: XOR<ChartItemUpdateWithoutChartInput, ChartItemUncheckedUpdateWithoutChartInput>
    create: XOR<ChartItemCreateWithoutChartInput, ChartItemUncheckedCreateWithoutChartInput>
  }

  export type ChartItemUpdateWithWhereUniqueWithoutChartInput = {
    where: ChartItemWhereUniqueInput
    data: XOR<ChartItemUpdateWithoutChartInput, ChartItemUncheckedUpdateWithoutChartInput>
  }

  export type ChartItemUpdateManyWithWhereWithoutChartInput = {
    where: ChartItemScalarWhereInput
    data: XOR<ChartItemUpdateManyMutationInput, ChartItemUncheckedUpdateManyWithoutChartInput>
  }

  export type ChartItemScalarWhereInput = {
    AND?: ChartItemScalarWhereInput | ChartItemScalarWhereInput[]
    OR?: ChartItemScalarWhereInput[]
    NOT?: ChartItemScalarWhereInput | ChartItemScalarWhereInput[]
    chartId?: StringFilter<"ChartItem"> | string
    position?: IntFilter<"ChartItem"> | number
    itemType?: StringFilter<"ChartItem"> | string
    itemId?: StringFilter<"ChartItem"> | string
    plays?: IntFilter<"ChartItem"> | number
  }

  export type ChartCreateWithoutItemsInput = {
    id?: string
    name: string
    type: $Enums.ChartType
    period: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
  }

  export type ChartUncheckedCreateWithoutItemsInput = {
    id?: string
    name: string
    type: $Enums.ChartType
    period: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
  }

  export type ChartCreateOrConnectWithoutItemsInput = {
    where: ChartWhereUniqueInput
    create: XOR<ChartCreateWithoutItemsInput, ChartUncheckedCreateWithoutItemsInput>
  }

  export type ChartUpsertWithoutItemsInput = {
    update: XOR<ChartUpdateWithoutItemsInput, ChartUncheckedUpdateWithoutItemsInput>
    create: XOR<ChartCreateWithoutItemsInput, ChartUncheckedCreateWithoutItemsInput>
    where?: ChartWhereInput
  }

  export type ChartUpdateToOneWithWhereWithoutItemsInput = {
    where?: ChartWhereInput
    data: XOR<ChartUpdateWithoutItemsInput, ChartUncheckedUpdateWithoutItemsInput>
  }

  export type ChartUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumChartTypeFieldUpdateOperationsInput | $Enums.ChartType
    period?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumChartTypeFieldUpdateOperationsInput | $Enums.ChartType
    period?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type PlaylistCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    imageId?: string | null
    isPublic?: boolean
    isOfficial?: boolean
    totalTracks?: number
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserLikedSongCreateManyUserInput = {
    songId: string
    likedAt?: Date | string
  }

  export type UserLikedAlbumCreateManyUserInput = {
    albumId: string
    likedAt?: Date | string
  }

  export type UserLikedPlaylistCreateManyUserInput = {
    playlistId: string
    likedAt?: Date | string
  }

  export type UserLikedArtistCreateManyUserInput = {
    artistId: string
    likedAt?: Date | string
  }

  export type PlayHistoryCreateManyUserInput = {
    id?: string
    playedAt?: Date | string
    duration: number
    deviceType?: string | null
    songId: string
  }

  export type SearchHistoryCreateManyUserInput = {
    id?: string
    query: string
    resultType?: string | null
    resultId?: string | null
    searchedAt?: Date | string
  }

  export type UserFollowCreateManyFollowerInput = {
    followingId: string
    followedAt?: Date | string
  }

  export type UserFollowCreateManyFollowingInput = {
    followerId: string
    followedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaylistUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isOfficial?: BoolFieldUpdateOperationsInput | boolean
    totalTracks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PlaylistItemUpdateManyWithoutPlaylistNestedInput
    likedBy?: UserLikedPlaylistUpdateManyWithoutPlaylistNestedInput
  }

  export type PlaylistUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isOfficial?: BoolFieldUpdateOperationsInput | boolean
    totalTracks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PlaylistItemUncheckedUpdateManyWithoutPlaylistNestedInput
    likedBy?: UserLikedPlaylistUncheckedUpdateManyWithoutPlaylistNestedInput
  }

  export type PlaylistUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isOfficial?: BoolFieldUpdateOperationsInput | boolean
    totalTracks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLikedSongUpdateWithoutUserInput = {
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    song?: SongUpdateOneRequiredWithoutLikedByNestedInput
  }

  export type UserLikedSongUncheckedUpdateWithoutUserInput = {
    songId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLikedSongUncheckedUpdateManyWithoutUserInput = {
    songId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLikedAlbumUpdateWithoutUserInput = {
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    album?: AlbumUpdateOneRequiredWithoutLikedByNestedInput
  }

  export type UserLikedAlbumUncheckedUpdateWithoutUserInput = {
    albumId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLikedAlbumUncheckedUpdateManyWithoutUserInput = {
    albumId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLikedPlaylistUpdateWithoutUserInput = {
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playlist?: PlaylistUpdateOneRequiredWithoutLikedByNestedInput
  }

  export type UserLikedPlaylistUncheckedUpdateWithoutUserInput = {
    playlistId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLikedPlaylistUncheckedUpdateManyWithoutUserInput = {
    playlistId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLikedArtistUpdateWithoutUserInput = {
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUpdateOneRequiredWithoutLikedByNestedInput
  }

  export type UserLikedArtistUncheckedUpdateWithoutUserInput = {
    artistId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLikedArtistUncheckedUpdateManyWithoutUserInput = {
    artistId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    song?: SongUpdateOneRequiredWithoutPlayHistoryNestedInput
  }

  export type PlayHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    songId?: StringFieldUpdateOperationsInput | string
  }

  export type PlayHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    songId?: StringFieldUpdateOperationsInput | string
  }

  export type SearchHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    resultType?: NullableStringFieldUpdateOperationsInput | string | null
    resultId?: NullableStringFieldUpdateOperationsInput | string | null
    searchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    resultType?: NullableStringFieldUpdateOperationsInput | string | null
    resultId?: NullableStringFieldUpdateOperationsInput | string | null
    searchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    resultType?: NullableStringFieldUpdateOperationsInput | string | null
    resultId?: NullableStringFieldUpdateOperationsInput | string | null
    searchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowUpdateWithoutFollowerInput = {
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    following?: UserUpdateOneRequiredWithoutFollowingNestedInput
  }

  export type UserFollowUncheckedUpdateWithoutFollowerInput = {
    followingId?: StringFieldUpdateOperationsInput | string
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowUncheckedUpdateManyWithoutFollowerInput = {
    followingId?: StringFieldUpdateOperationsInput | string
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowUpdateWithoutFollowingInput = {
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: UserUpdateOneRequiredWithoutFollowersNestedInput
  }

  export type UserFollowUncheckedUpdateWithoutFollowingInput = {
    followerId?: StringFieldUpdateOperationsInput | string
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowUncheckedUpdateManyWithoutFollowingInput = {
    followerId?: StringFieldUpdateOperationsInput | string
    followedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlbumCreateManyArtistInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    imageId: string
    albumType?: $Enums.AlbumType
    releaseDate?: Date | string
    totalTracks?: number
    duration?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SongArtistCreateManyArtistInput = {
    id?: string
    songId: string
    role?: $Enums.ArtistRole
    order?: number
  }

  export type ArtistGenreCreateManyArtistInput = {
    genreId: string
  }

  export type UserLikedArtistCreateManyArtistInput = {
    userId: string
    likedAt?: Date | string
  }

  export type SongCreditCreateManyArtistInput = {
    id?: string
    songId: string
    name: string
    role: $Enums.CreditRole
    details?: string | null
    order?: number
  }

  export type AlbumUpdateWithoutArtistInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: StringFieldUpdateOperationsInput | string
    albumType?: EnumAlbumTypeFieldUpdateOperationsInput | $Enums.AlbumType
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalTracks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    songs?: SongUpdateManyWithoutAlbumNestedInput
    genres?: AlbumGenreUpdateManyWithoutAlbumNestedInput
    likedBy?: UserLikedAlbumUpdateManyWithoutAlbumNestedInput
  }

  export type AlbumUncheckedUpdateWithoutArtistInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: StringFieldUpdateOperationsInput | string
    albumType?: EnumAlbumTypeFieldUpdateOperationsInput | $Enums.AlbumType
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalTracks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    songs?: SongUncheckedUpdateManyWithoutAlbumNestedInput
    genres?: AlbumGenreUncheckedUpdateManyWithoutAlbumNestedInput
    likedBy?: UserLikedAlbumUncheckedUpdateManyWithoutAlbumNestedInput
  }

  export type AlbumUncheckedUpdateManyWithoutArtistInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: StringFieldUpdateOperationsInput | string
    albumType?: EnumAlbumTypeFieldUpdateOperationsInput | $Enums.AlbumType
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalTracks?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SongArtistUpdateWithoutArtistInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumArtistRoleFieldUpdateOperationsInput | $Enums.ArtistRole
    order?: IntFieldUpdateOperationsInput | number
    song?: SongUpdateOneRequiredWithoutArtistsNestedInput
  }

  export type SongArtistUncheckedUpdateWithoutArtistInput = {
    id?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
    role?: EnumArtistRoleFieldUpdateOperationsInput | $Enums.ArtistRole
    order?: IntFieldUpdateOperationsInput | number
  }

  export type SongArtistUncheckedUpdateManyWithoutArtistInput = {
    id?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
    role?: EnumArtistRoleFieldUpdateOperationsInput | $Enums.ArtistRole
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ArtistGenreUpdateWithoutArtistInput = {
    genre?: GenreUpdateOneRequiredWithoutArtistsNestedInput
  }

  export type ArtistGenreUncheckedUpdateWithoutArtistInput = {
    genreId?: StringFieldUpdateOperationsInput | string
  }

  export type ArtistGenreUncheckedUpdateManyWithoutArtistInput = {
    genreId?: StringFieldUpdateOperationsInput | string
  }

  export type UserLikedArtistUpdateWithoutArtistInput = {
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikedArtistsNestedInput
  }

  export type UserLikedArtistUncheckedUpdateWithoutArtistInput = {
    userId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLikedArtistUncheckedUpdateManyWithoutArtistInput = {
    userId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SongCreditUpdateWithoutArtistInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumCreditRoleFieldUpdateOperationsInput | $Enums.CreditRole
    details?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    song?: SongUpdateOneRequiredWithoutCreditsNestedInput
  }

  export type SongCreditUncheckedUpdateWithoutArtistInput = {
    id?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumCreditRoleFieldUpdateOperationsInput | $Enums.CreditRole
    details?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type SongCreditUncheckedUpdateManyWithoutArtistInput = {
    id?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumCreditRoleFieldUpdateOperationsInput | $Enums.CreditRole
    details?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type SongCreateManyAlbumInput = {
    id?: string
    title: string
    slug: string
    audioId: string
    duration: number
    trackNumber: number
    lyrics?: string | null
    isExplicit?: boolean
    playCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlbumGenreCreateManyAlbumInput = {
    genreId: string
  }

  export type UserLikedAlbumCreateManyAlbumInput = {
    userId: string
    likedAt?: Date | string
  }

  export type SongUpdateWithoutAlbumInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    trackNumber?: IntFieldUpdateOperationsInput | number
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artists?: SongArtistUpdateManyWithoutSongNestedInput
    credits?: SongCreditUpdateManyWithoutSongNestedInput
    genres?: SongGenreUpdateManyWithoutSongNestedInput
    likedBy?: UserLikedSongUpdateManyWithoutSongNestedInput
    playlistItems?: PlaylistItemUpdateManyWithoutSongNestedInput
    playHistory?: PlayHistoryUpdateManyWithoutSongNestedInput
  }

  export type SongUncheckedUpdateWithoutAlbumInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    trackNumber?: IntFieldUpdateOperationsInput | number
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artists?: SongArtistUncheckedUpdateManyWithoutSongNestedInput
    credits?: SongCreditUncheckedUpdateManyWithoutSongNestedInput
    genres?: SongGenreUncheckedUpdateManyWithoutSongNestedInput
    likedBy?: UserLikedSongUncheckedUpdateManyWithoutSongNestedInput
    playlistItems?: PlaylistItemUncheckedUpdateManyWithoutSongNestedInput
    playHistory?: PlayHistoryUncheckedUpdateManyWithoutSongNestedInput
  }

  export type SongUncheckedUpdateManyWithoutAlbumInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    trackNumber?: IntFieldUpdateOperationsInput | number
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    playCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlbumGenreUpdateWithoutAlbumInput = {
    genre?: GenreUpdateOneRequiredWithoutAlbumsNestedInput
  }

  export type AlbumGenreUncheckedUpdateWithoutAlbumInput = {
    genreId?: StringFieldUpdateOperationsInput | string
  }

  export type AlbumGenreUncheckedUpdateManyWithoutAlbumInput = {
    genreId?: StringFieldUpdateOperationsInput | string
  }

  export type UserLikedAlbumUpdateWithoutAlbumInput = {
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikedAlbumsNestedInput
  }

  export type UserLikedAlbumUncheckedUpdateWithoutAlbumInput = {
    userId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLikedAlbumUncheckedUpdateManyWithoutAlbumInput = {
    userId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SongArtistCreateManySongInput = {
    id?: string
    artistId: string
    role?: $Enums.ArtistRole
    order?: number
  }

  export type SongCreditCreateManySongInput = {
    id?: string
    artistId?: string | null
    name: string
    role: $Enums.CreditRole
    details?: string | null
    order?: number
  }

  export type SongGenreCreateManySongInput = {
    genreId: string
  }

  export type UserLikedSongCreateManySongInput = {
    userId: string
    likedAt?: Date | string
  }

  export type PlaylistItemCreateManySongInput = {
    id?: string
    position: number
    addedAt?: Date | string
    playlistId: string
  }

  export type PlayHistoryCreateManySongInput = {
    id?: string
    playedAt?: Date | string
    duration: number
    deviceType?: string | null
    userId: string
  }

  export type SongArtistUpdateWithoutSongInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumArtistRoleFieldUpdateOperationsInput | $Enums.ArtistRole
    order?: IntFieldUpdateOperationsInput | number
    artist?: ArtistUpdateOneRequiredWithoutSongsNestedInput
  }

  export type SongArtistUncheckedUpdateWithoutSongInput = {
    id?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    role?: EnumArtistRoleFieldUpdateOperationsInput | $Enums.ArtistRole
    order?: IntFieldUpdateOperationsInput | number
  }

  export type SongArtistUncheckedUpdateManyWithoutSongInput = {
    id?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    role?: EnumArtistRoleFieldUpdateOperationsInput | $Enums.ArtistRole
    order?: IntFieldUpdateOperationsInput | number
  }

  export type SongCreditUpdateWithoutSongInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumCreditRoleFieldUpdateOperationsInput | $Enums.CreditRole
    details?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    artist?: ArtistUpdateOneWithoutCreditsNestedInput
  }

  export type SongCreditUncheckedUpdateWithoutSongInput = {
    id?: StringFieldUpdateOperationsInput | string
    artistId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumCreditRoleFieldUpdateOperationsInput | $Enums.CreditRole
    details?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type SongCreditUncheckedUpdateManyWithoutSongInput = {
    id?: StringFieldUpdateOperationsInput | string
    artistId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumCreditRoleFieldUpdateOperationsInput | $Enums.CreditRole
    details?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type SongGenreUpdateWithoutSongInput = {
    genre?: GenreUpdateOneRequiredWithoutSongsNestedInput
  }

  export type SongGenreUncheckedUpdateWithoutSongInput = {
    genreId?: StringFieldUpdateOperationsInput | string
  }

  export type SongGenreUncheckedUpdateManyWithoutSongInput = {
    genreId?: StringFieldUpdateOperationsInput | string
  }

  export type UserLikedSongUpdateWithoutSongInput = {
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikedSongsNestedInput
  }

  export type UserLikedSongUncheckedUpdateWithoutSongInput = {
    userId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLikedSongUncheckedUpdateManyWithoutSongInput = {
    userId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaylistItemUpdateWithoutSongInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playlist?: PlaylistUpdateOneRequiredWithoutItemsNestedInput
  }

  export type PlaylistItemUncheckedUpdateWithoutSongInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playlistId?: StringFieldUpdateOperationsInput | string
  }

  export type PlaylistItemUncheckedUpdateManyWithoutSongInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playlistId?: StringFieldUpdateOperationsInput | string
  }

  export type PlayHistoryUpdateWithoutSongInput = {
    id?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutPlayHistoryNestedInput
  }

  export type PlayHistoryUncheckedUpdateWithoutSongInput = {
    id?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type PlayHistoryUncheckedUpdateManyWithoutSongInput = {
    id?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SongGenreCreateManyGenreInput = {
    songId: string
  }

  export type AlbumGenreCreateManyGenreInput = {
    albumId: string
  }

  export type ArtistGenreCreateManyGenreInput = {
    artistId: string
  }

  export type SongGenreUpdateWithoutGenreInput = {
    song?: SongUpdateOneRequiredWithoutGenresNestedInput
  }

  export type SongGenreUncheckedUpdateWithoutGenreInput = {
    songId?: StringFieldUpdateOperationsInput | string
  }

  export type SongGenreUncheckedUpdateManyWithoutGenreInput = {
    songId?: StringFieldUpdateOperationsInput | string
  }

  export type AlbumGenreUpdateWithoutGenreInput = {
    album?: AlbumUpdateOneRequiredWithoutGenresNestedInput
  }

  export type AlbumGenreUncheckedUpdateWithoutGenreInput = {
    albumId?: StringFieldUpdateOperationsInput | string
  }

  export type AlbumGenreUncheckedUpdateManyWithoutGenreInput = {
    albumId?: StringFieldUpdateOperationsInput | string
  }

  export type ArtistGenreUpdateWithoutGenreInput = {
    artist?: ArtistUpdateOneRequiredWithoutGenresNestedInput
  }

  export type ArtistGenreUncheckedUpdateWithoutGenreInput = {
    artistId?: StringFieldUpdateOperationsInput | string
  }

  export type ArtistGenreUncheckedUpdateManyWithoutGenreInput = {
    artistId?: StringFieldUpdateOperationsInput | string
  }

  export type PlaylistItemCreateManyPlaylistInput = {
    id?: string
    position: number
    addedAt?: Date | string
    songId: string
  }

  export type UserLikedPlaylistCreateManyPlaylistInput = {
    userId: string
    likedAt?: Date | string
  }

  export type PlaylistItemUpdateWithoutPlaylistInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    song?: SongUpdateOneRequiredWithoutPlaylistItemsNestedInput
  }

  export type PlaylistItemUncheckedUpdateWithoutPlaylistInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    songId?: StringFieldUpdateOperationsInput | string
  }

  export type PlaylistItemUncheckedUpdateManyWithoutPlaylistInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    songId?: StringFieldUpdateOperationsInput | string
  }

  export type UserLikedPlaylistUpdateWithoutPlaylistInput = {
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikedPlaylistsNestedInput
  }

  export type UserLikedPlaylistUncheckedUpdateWithoutPlaylistInput = {
    userId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLikedPlaylistUncheckedUpdateManyWithoutPlaylistInput = {
    userId?: StringFieldUpdateOperationsInput | string
    likedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartItemCreateManyChartInput = {
    position: number
    itemType: string
    itemId: string
    plays?: number
  }

  export type ChartItemUpdateWithoutChartInput = {
    position?: IntFieldUpdateOperationsInput | number
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    plays?: IntFieldUpdateOperationsInput | number
  }

  export type ChartItemUncheckedUpdateWithoutChartInput = {
    position?: IntFieldUpdateOperationsInput | number
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    plays?: IntFieldUpdateOperationsInput | number
  }

  export type ChartItemUncheckedUpdateManyWithoutChartInput = {
    position?: IntFieldUpdateOperationsInput | number
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    plays?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}